<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2017-07-25T16:08:41.686Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="https://caixueyuan.github.io/2017/07/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2017/07/25/Java多线程基础/</id>
    <published>2017-07-25T14:26:28.000Z</published>
    <updated>2017-07-25T16:08:41.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><blockquote>
<p>1,Volatile变量具有synchronized的可见性特性，但是不具备原子特性。</p>
<ul>
<li>原理：</li>
</ul>
</blockquote>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>
<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>
<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>
<p>多个变量之间或者某个变量的当前值与修改后值之间没有约束。<br>对于x++等递增操作，要保证是原子操作，然后不能够只是使用volatile<br>但是呢，volatile的性能比较好。</p>
<blockquote>
<p>2,保证有序性</p>
</blockquote>
<p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<p>正确使用的方法：</p>
<blockquote>
<ul>
<li>状态标志<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</div><div class="line">    shutdownRequested=<span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(!shutdownRequested)&#123;</div><div class="line">        <span class="comment">//do stuff</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一次性安全发布</p>
</blockquote>
<p>被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>
<blockquote>
<p>独立观察：</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class UserManager &#123;</div><div class="line">    public volatile String lastUser;</div><div class="line"> </div><div class="line">    public boolean authenticate(String user, String password) &#123;</div><div class="line">        boolean valid = passwordIsValid(user, password);</div><div class="line">        <span class="keyword">if</span> (valid) &#123;</div><div class="line">           <span class="built_in"> User </span>u = new User();</div><div class="line">            activeUsers.<span class="builtin-name">add</span>(u);</div><div class="line">            lastUser =<span class="built_in"> user;</span></div><div class="line">        &#125;</div><div class="line">        return valid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改</p>
<blockquote>
<p>开销很低的读-写策略<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesyCounter</span> &#123;</div><div class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></div><div class="line">    <span class="comment">// All mutative operations MUST be done with the 'this' lock held</span></div><div class="line">    @GuardedBy(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">value</span>; &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">int</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="ThreadLocal（线程局部变量（thread-local-variable"><a href="#ThreadLocal（线程局部变量（thread-local-variable" class="headerlink" title="ThreadLocal（线程局部变量（thread-local  variable)"></a>ThreadLocal（线程局部变量（thread-local  variable)</h2><h3 id="作用：用来存储线程中的局部变量"><a href="#作用：用来存储线程中的局部变量" class="headerlink" title="作用：用来存储线程中的局部变量"></a><strong>作用</strong>：用来存储线程中的局部变量</h3><p>因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且是在线程内部任何地方都可以使用，线程之间互不影响，这样就不会存在线程安全问题，也不会严重影响程序执行性能，考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
<h3 id="深入解析ThreadLocal类"><a href="#深入解析ThreadLocal类" class="headerlink" title="深入解析ThreadLocal类"></a>深入解析ThreadLocal类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//获取在当前线程中保存的变量副本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>) </span>&#123; &#125;<span class="comment">//设置当前线程中变量的副本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//移除当前线程中的变量的副本</span></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//延迟加载</span></div></pre></td></tr></table></figure>
<p>首先的话，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的变量的threadLocals,这个threadLocals就是用来存储实际的变量的副本的，键值为当前的ThreadLocal变量，value为变量的副本。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>在进行get之前，必须先set，否则会报空指针异常；</p>
<p><strong>例子</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</div><div class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</div><div class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</div><div class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>
<p>线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Volatile&quot;&gt;&lt;a href=&quot;#Volatile&quot; class=&quot;headerlink&quot; title=&quot;Volatile&quot;&gt;&lt;/a&gt;Volatile&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1,Volatile变量具有synchronized的可见性特性，
    
    </summary>
    
      <category term="Java学习笔记" scheme="https://caixueyuan.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java多线程基础" scheme="https://caixueyuan.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程-线程-Java</title>
    <link href="https://caixueyuan.github.io/2017/07/25/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-Java/"/>
    <id>https://caixueyuan.github.io/2017/07/25/进程-线程-Java/</id>
    <published>2017-07-24T16:02:51.000Z</published>
    <updated>2017-07-24T16:08:39.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>进程</p>
<ul>
<li>进程是具有一定独立功能的程序关于某个数据集合中的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源</li>
<li>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行</li>
<li>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列</li>
</ul>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<blockquote>
<p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</blockquote>
<h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><blockquote>
<ul>
<li>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。进程是操作系统分配资源的单位</li>
<li>线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
</blockquote>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成：<br>总线程数&lt;= CPU数量：并行运行<br>总线程数&gt; CPU数量：并发运行</p>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><blockquote>
<p>通过集成Thread来创建线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</div><div class="line">        thread1.start();</div><div class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</div><div class="line">        thread2.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"name:"</span>+name+<span class="string">" 子线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://incdn1.b0.upaiyun.com/2016/08/28c8edde3d61a0411511d3b1866f0636.jpg" alt="运行结果"></p>
<blockquote>
<p>Thread.start()我们可以知道新线程的建立不会阻塞主线程的后续执行<br>Thread.run()并没有建立新的线程，而是在原来的线程上直接运行run方法，跟普通的函数调用没有区别</p>
</blockquote>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID："</span>+Thread.currentThread().getId());</div><div class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程ID："</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以把Runnable接口看成一个子任务，然后把子任务分配给Thread来运行就可以了。</p>
<p>但是不能够直接调用<code>MyRunnable</code>，因为这样实际上没有新建线程，而是在原来的主线程来调用Runnable</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>虽然可以是使用start(),stop(),stop(Throwable),suspend(),destroy(),resume(),但是这些方法只有start()保留下来。<br>SUN公司推荐的代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread blinker; </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; </div><div class="line">        blinker = <span class="keyword">null</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        Thread thisThread = Thread.currentThread(); </div><div class="line">        <span class="keyword">while</span> (blinker == thisThread) &#123; </div><div class="line">            <span class="keyword">try</span> &#123; </div><div class="line">                thisThread.sleep(interval); </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123; </div><div class="line">            &#125; </div><div class="line">            repaint(); </div><div class="line">        &#125; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当线程处于下面的状况时，属于非运行状态（当sleep方法被调用，当wait方法被调用，当被I/O阻塞，可能是文件或者网络）：<br>可以使用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread tmpBlinker = blinker;</div><div class="line">        blinker = <span class="keyword">null</span>; <span class="keyword">if</span> (tmpBlinker != <span class="keyword">null</span>) &#123;</div><div class="line">           tmpBlinker.interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当interrupt()被调用的时候，InterruptedException将被抛出，所以你可以再run方法中捕获这个异常，让线程安全退出</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   ....</div><div class="line">   wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException iex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Interrupted"</span>,iex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>要点</strong></p>
<blockquote>
<p>如果该线程正阻塞于Object类的wait()、wait(long)、wait(long, int)方法，或者Thread类的join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)方法，则该线程的中断状态将被清除，并收到一个java.lang.InterruptedException<br>interrupted()与isInterrupted()的唯一区别是，前者会读取并清除中断状态，后者仅读取状态。<br>任何时候捕获到InterruptedException，要么继续上抛，要么重置中断状态，这是最安全的做法</p>
</blockquote>
<p><strong>最佳实践：Shared Variable</strong></p>
<p>通过使用violate boolean 变量来标识线程是否停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestPractice</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;   <span class="comment">// ① volatile条件变量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span> </span>&#123;</div><div class="line">        finished = <span class="keyword">true</span>;    <span class="comment">// ② 发出停止信号</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!finished) &#123;    <span class="comment">// ③ 检测条件变量</span></div><div class="line">            <span class="comment">// do dirty work   // ④业务代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
    
    </summary>
    
      <category term="操作系统" scheme="https://caixueyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="多线程编程" scheme="https://caixueyuan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Thinking In Java</title>
    <link href="https://caixueyuan.github.io/2017/07/23/Thinking-In-Java/"/>
    <id>https://caixueyuan.github.io/2017/07/23/Thinking-In-Java/</id>
    <published>2017-07-23T15:11:41.000Z</published>
    <updated>2017-07-24T16:08:11.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p><strong>访问控制</strong></p>
<blockquote>
<ul>
<li>第一个存在的原因：让客户端无法触及到程序员他们不能够触及到的部分</li>
<li>第二个存在的原因：允许客户端可以改变内部的工作方式而不是担心会影响到客户端程序员</li>
</ul>
</blockquote>
<p><strong>继承</strong>：使得基类与导出类产生差异</p>
<blockquote>
<ul>
<li>直接在导出类中添加新方法</li>
<li>覆盖Override，改变现有的基类的方法</li>
</ul>
<p>如果只是简单的Override，那么导出类<code>is-a</code>基类<br>如果还添加新方法，那么导出类<code>is-like-a</code>基类</p>
<p>Java中具体类或者抽象类是单根继承结构，但是Java接口确是多根继承结构</p>
</blockquote>
<h3 id="一起都是对象"><a href="#一起都是对象" class="headerlink" title="一起都是对象"></a>一起都是对象</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象导论&quot;&gt;&lt;a href=&quot;#对象导论&quot; class=&quot;headerlink&quot; title=&quot;对象导论&quot;&gt;&lt;/a&gt;对象导论&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;访问控制&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一个存在的原因：让客户端无
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java学习笔记" scheme="https://caixueyuan.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="https://caixueyuan.github.io/2017/07/23/Java%E9%9B%86%E5%90%88/"/>
    <id>https://caixueyuan.github.io/2017/07/23/Java集合/</id>
    <published>2017-07-23T08:10:23.000Z</published>
    <updated>2017-07-23T14:53:18.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="Java中集合的接口的继承关系图"><a href="#Java中集合的接口的继承关系图" class="headerlink" title="Java中集合的接口的继承关系图"></a>Java中集合的接口的继承关系图</h3><p><img src="http://images.cnitblog.com/blog/490648/201308/18174126-653273ab5abe491bb9724353360ed252.png" alt="Java集合"></p>
<p>1,<strong><code>Set</code></strong>:</p>
<p><strong>TreeSet</strong>：在这里是要进行排序的，</p>
<blockquote>
<ul>
<li>自然排序（Comparable）：<br>TreeSet类的add会对对象实例的compareTo()方法和集合中的对象进行比较，根据比较的结果来进行排序</li>
<li>比较器顺序（Comparator）：<br>在外部创建一个比较器来进行比较对象的大小</li>
</ul>
</blockquote>
<p><strong>HashSet</strong>：这是一个实现类</p>
<blockquote>
<ul>
<li>不能够保证元素的排列顺序</li>
</ul>
</blockquote>
<p><strong>LinkedHashSet</strong>：集成于HashSet</p>
<blockquote>
<ul>
<li>能够进行排序（根据hashcode来决定元素的存储位置，同时使用链表维护元素的次序</li>
</ul>
</blockquote>
<p><strong>EnumSet</strong>:专门为枚举类设计，能够枚举各个属性</p>
<p><strong>List接口</strong></p>
<blockquote>
<ul>
<li><strong>ArrayList</strong>:数组（适合随机的set和get）</li>
<li><strong>Vector</strong>：数组，线程安全，但是效率较低</li>
<li><strong>LinkedList</strong>：链表（适合更多的新增或者删除）（是一个双向链表）</li>
</ul>
</blockquote>
<p><strong>Queue</strong>:队列，先进先出</p>
<blockquote>
<ul>
<li>Deque:双端队列，能够在双端中增加或者删除，使用Stack</li>
<li>PriorityQueue:能够进行排序，也是先进先出的。</li>
</ul>
</blockquote>
<p><strong>HashMap</strong>：<br><strong>Hashtable</strong>：</p>
<blockquote>
<ul>
<li>Hashtable在遇到null时，会抛出NullPointException异常</li>
<li>线程安全</li>
<li>通过Initial Capacity和Load Factor两个参数来调整性能，通常来说Load Factor为0.75，较好地实现时间和空间的均衡，增大Load Factor可以节省空间但相应的查找时间会增加<br><strong>HashMap</strong>：</li>
<li>HashMap是支持null键和null值的</li>
<li>线程不安全</li>
<li>将Key做Hash算法，然后将Hash值映射到内存地址，直接取得Key对应的数据</li>
</ul>
</blockquote>
<p><strong>TreeMap</strong>:</p>
<blockquote>
<ul>
<li>按照顺序进行排列（红黑树）</li>
<li>插入和删除比HashMap的效率低一些，但是呢，有序</li>
</ul>
</blockquote>
<p><strong>WeakhashMap</strong>:是一种弄改进的HashMap，对Key实现“弱引用”,如果一个Key不再被外部引用，那么该Key可能被GC回收。如果Key没有其他的引用，那么Map会自动丢弃该值。</p>
<blockquote>
<ul>
<li>特别之处在于WeakHashMap里的Entry可能会被GC自动删除，即使程序员没有调用remove或者clear方法</li>
</ul>
<ul>
<li>可能会出现以下的现象：</li>
</ul>
<p>调用两次size()方法返回不同的值；<br>两次调用isEmpty()方法，第一次返回false，第二次返回true；<br>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；<br>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</p>
</blockquote>
<p>弱引用（WeakReference）：通过GC自动管理，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</p>
<p><strong>LinkedHashMap</strong>:根据元素增加或者访问的先后顺序进行排序，而TreeMap根据元素的Key的大小来进行排序</p>
<h3 id="Java的四种引用："><a href="#Java的四种引用：" class="headerlink" title="Java的四种引用："></a>Java的四种引用：</h3><blockquote>
<ul>
<li>强引用：垃圾收集机制绝不会回收它，当内存空间出现不足，Java虚拟机抛出OutOfMemoryError错误，使得程序异常终止</li>
<li>软引用：内存空间足够，不会回收；内存空间不足，回收</li>
<li>弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
<li>虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</li>
</ul>
</blockquote>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><blockquote>
<ul>
<li><code>expungeStaleEntries</code>:会在大部分共有方法中被调用，将ReferenceQueue中所有的失效的引用从Map中去除</li>
<li>WeakHashMap的Key是弱引用，Value不是。WeakHashMap不会自动释放失效的弱引用，仅当包含了expungeStaleEntries（）的公有方法被调用的时候才会释放</li>
</ul>
</blockquote>
<h3 id="用弱引用堵住内存泄露"><a href="#用弱引用堵住内存泄露" class="headerlink" title="用弱引用堵住内存泄露"></a>用弱引用堵住内存泄露</h3><p>要让垃圾收集（GC）回收程序不再使用的对象，对象的逻辑 生命周期（应用程序使用它的时间）和对该对象拥有的引用的实际 生命周期必须是相同的</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new HashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">    public void removeUser(Socket s) &#123;</div><div class="line">        m.<span class="builtin-name">remove</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">SocketManager socketManager;</div><div class="line">socketManager.setUser(socket, user);</div></pre></td></tr></table></figure>
<p>如果没有显性的删除和增加，那么Socket和User对象都会一直存在于内存中，可能会出现OutOfMemoryError</p>
<p>对于大多数程序来说，可以将内存使用分为两部分：baseline 使用和 current load 使用。对于服务器应用程序，baseline 使用就是应用程序在没有任何负荷、但是已经准备好接受请求时的内存使用，current load 使用是在处理请求过程中使用的、但是在请求处理完成后会释放的内存。只要负荷大体上是恒定的，应用程序通常会很快达到一个稳定的内存使用水平。如果在应用程序已经完成了其初始化并且负荷没有增加的情况下，内存使用持续增加，那么程序就可能在处理前面的请求时保留了生成的对象。</p>
<p>SocketManager 的问题是 Socket-User 映射的生命周期应当与 Socket 的生命周期相匹配。弱引用是对一个对象（称为 referent）的引用的持有者。使用弱引用后，可以维持对 referent 的引用，而不会阻止它被垃圾收集。当垃圾收集器跟踪堆的时候，如果对一个对象的引用只有弱引用，那么这个 referent 就会成为垃圾收集的候选对象，就像没有任何剩余的引用一样，而且所有剩余的弱引用都被清除。（只有弱引用的对象称为弱可及（weakly reachable）。）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new WeakHashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakReference.get() 是否返回 null 来区分死的映射和活的映射.可以通过周期性地扫描 Map，对每一个弱引用调用 get()，并在 get() 返回 null 时删除那个映射而消除死映射</p>
<p>WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射.用引用队列代替定期扫描内容的方法来清理 Map 更有效，因为清理过程不会触及活的项，只有在有实际加入队列的引用时它才工作<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> expungeStaleEntries() &#123;</div><div class="line">Entry&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">while</span> ( (e = (Entry&lt;K,V&gt;) queue.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> hash = e.hash;</div><div class="line">        Entry&lt;K,V&gt; prev = getChain(hash);</div><div class="line">        Entry&lt;K,V&gt; cur = prev;</div><div class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; <span class="keyword">next</span> = cur.<span class="keyword">next</span>;</div><div class="line">            <span class="keyword">if</span> (cur == e) &#123;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    setChain(hash, <span class="keyword">next</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            prev = cur;</div><div class="line">            cur = <span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/index.html" target="_blank" rel="external">具体的链接如下：</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java集合&quot;&gt;&lt;a href=&quot;#Java集合&quot; class=&quot;headerlink&quot; title=&quot;Java集合&quot;&gt;&lt;/a&gt;Java集合&lt;/h2&gt;&lt;h3 id=&quot;Java中集合的接口的继承关系图&quot;&gt;&lt;a href=&quot;#Java中集合的接口的继承关系图&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java基础" scheme="https://caixueyuan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程间通讯</title>
    <link href="https://caixueyuan.github.io/2017/07/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2017/07/19/进程间通讯/</id>
    <published>2017-07-19T15:46:57.000Z</published>
    <updated>2017-07-19T15:48:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><h3 id="1-管道-匿名管道（pipe）"><a href="#1-管道-匿名管道（pipe）" class="headerlink" title="1,管道/匿名管道（pipe）"></a>1,管道/匿名管道（pipe）</h3><blockquote>
<ul>
<li>管道都是半双工，数据只能向一个方向流动</li>
<li>只能用于父子进程或者兄弟进程之间</li>
<li>单独构成一种独立的文件系统（就是有输入输出)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程间通讯&quot;&gt;&lt;a href=&quot;#进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;进程间通讯&quot;&gt;&lt;/a&gt;进程间通讯&lt;/h2&gt;&lt;h3 id=&quot;1-管道-匿名管道（pipe）&quot;&gt;&lt;a href=&quot;#1-管道-匿名管道（pipe）&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/JavaScript学习笔记/</id>
    <published>2017-07-04T15:10:15.000Z</published>
    <updated>2017-07-04T15:10:15.692Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/Spring学习笔记/</id>
    <published>2017-07-04T12:16:49.000Z</published>
    <updated>2017-07-04T12:27:28.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="1，Spring-Security功能性要求："><a href="#1，Spring-Security功能性要求：" class="headerlink" title="1，Spring Security功能性要求："></a>1，Spring Security功能性要求：</h3><blockquote>
<ul>
<li>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问</li>
<li>还能够使用Spring AOP保护方法调用————借助于对象代理和使用通知，能够保护只有具备适当权限的用户才能访问安全保护的方法。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Security&quot;&gt;&lt;a href=&quot;#Spring-Security&quot; class=&quot;headerlink&quot; title=&quot;Spring Security&quot;&gt;&lt;/a&gt;Spring Security&lt;/h2&gt;&lt;h3 id=&quot;1，Spring-Secu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java框架，笔记" scheme="https://caixueyuan.github.io/tags/Java%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP/</id>
    <published>2017-07-03T13:11:49.000Z</published>
    <updated>2017-07-03T13:32:05.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="1，对于告知服务器意图的HTTP方法："><a href="#1，对于告知服务器意图的HTTP方法：" class="headerlink" title="1，对于告知服务器意图的HTTP方法："></a>1，对于告知服务器意图的HTTP方法：</h3><blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<h3 id="2，持久连接节省通信量"><a href="#2，持久连接节省通信量" class="headerlink" title="2，持久连接节省通信量"></a>2，持久连接节省通信量</h3><blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<h3 id="3，使用Cookie的状态管理"><a href="#3，使用Cookie的状态管理" class="headerlink" title="3，使用Cookie的状态管理"></a>3，使用Cookie的状态管理</h3><p>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<h2 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h2></blockquote>
<h3 id="3，编码提升传输速率"><a href="#3，编码提升传输速率" class="headerlink" title="3，编码提升传输速率"></a>3，编码提升传输速率</h3><blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<h3 id="4，发送多种数据的多部分对象集合"><a href="#4，发送多种数据的多部分对象集合" class="headerlink" title="4，发送多种数据的多部分对象集合"></a>4，发送多种数据的多部分对象集合</h3><blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<h3 id="5，获取部分内容的范围请求（Range-Request）"><a href="#5，获取部分内容的范围请求（Range-Request）" class="headerlink" title="5，获取部分内容的范围请求（Range Request）"></a>5，获取部分内容的范围请求（Range Request）</h3><h3 id="6，内容协调Content-Negotiation返回最合适的内容"><a href="#6，内容协调Content-Negotiation返回最合适的内容" class="headerlink" title="6，内容协调Content Negotiation返回最合适的内容"></a>6，内容协调<code>Content Negotiation</code>返回最合适的内容</h3><blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<h2 id="返回结果的HTTP状态"><a href="#返回结果的HTTP状态" class="headerlink" title="返回结果的HTTP状态"></a>返回结果的HTTP状态</h2><h3 id="1，1XX接收的请求正在处理"><a href="#1，1XX接收的请求正在处理" class="headerlink" title="1，1XX接收的请求正在处理"></a>1，1XX接收的请求正在处理</h3><h3 id="2，2XX成功"><a href="#2，2XX成功" class="headerlink" title="2，2XX成功"></a>2，2XX成功</h3><blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<h3 id="3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"><a href="#3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求" class="headerlink" title="3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"></a>3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</h3><blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<h3 id="4-4XX客户端是发生错误的原因"><a href="#4-4XX客户端是发生错误的原因" class="headerlink" title="4,4XX客户端是发生错误的原因"></a>4,4XX客户端是发生错误的原因</h3><blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<h3 id="5，5XX：服务器本身错误"><a href="#5，5XX：服务器本身错误" class="headerlink" title="5，5XX：服务器本身错误"></a>5，5XX：服务器本身错误</h3><blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<h2 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h2><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1,用单台虚拟主机实现多个域名"></a>1,用单台虚拟主机实现多个域名</h3><blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<h3 id="2-通信数据转发程序"><a href="#2-通信数据转发程序" class="headerlink" title="2,通信数据转发程序"></a>2,通信数据转发程序</h3><blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<h3 id="3，保存资源缓存"><a href="#3，保存资源缓存" class="headerlink" title="3，保存资源缓存"></a>3，保存资源缓存</h3><blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="1，HTTP首部字段传递重要信息"><a href="#1，HTTP首部字段传递重要信息" class="headerlink" title="1，HTTP首部字段传递重要信息"></a>1，HTTP首部字段传递重要信息</h3><blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<h2 id="2，HTTP首部字段类型："><a href="#2，HTTP首部字段类型：" class="headerlink" title="2，HTTP首部字段类型："></a>2，HTTP首部字段类型：</h2><blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<h3 id="3，HTTP-1-1通用首部字段"><a href="#3，HTTP-1-1通用首部字段" class="headerlink" title="3，HTTP/1.1通用首部字段"></a>3，HTTP/1.1通用首部字段</h3><blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<h3 id="4，Cookie："><a href="#4，Cookie：" class="headerlink" title="4，Cookie："></a>4，Cookie：</h3><blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<h2 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h2><h3 id="1，HTTP的缺点"><a href="#1，HTTP的缺点" class="headerlink" title="1，HTTP的缺点"></a>1，HTTP的缺点</h3><blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<h3 id="2，HTTPS（加密，认证，完整性保护）"><a href="#2，HTTPS（加密，认证，完整性保护）" class="headerlink" title="2，HTTPS（加密，认证，完整性保护）"></a>2，HTTPS（加密，认证，完整性保护）</h3><blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<h2 id="确保访问用户身份的认证"><a href="#确保访问用户身份的认证" class="headerlink" title="确保访问用户身份的认证"></a>确保访问用户身份的认证</h2><h3 id="1，BASIC认证"><a href="#1，BASIC认证" class="headerlink" title="1，BASIC认证"></a>1，BASIC认证</h3><blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<h3 id="2-DIGEST认证"><a href="#2-DIGEST认证" class="headerlink" title="2,DIGEST认证"></a>2,DIGEST认证</h3><blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<h3 id="3，SSL客户端认证"><a href="#3，SSL客户端认证" class="headerlink" title="3，SSL客户端认证"></a>3，SSL客户端认证</h3><blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<h3 id="4-基于表单认证"><a href="#4-基于表单认证" class="headerlink" title="4,基于表单认证"></a>4,基于表单认证</h3><blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h3><blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<h3 id="WekSocket"><a href="#WekSocket" class="headerlink" title="WekSocket"></a>WekSocket</h3><blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的HTTP协议&quot;&gt;&lt;a href=&quot;#简单的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;简单的HTTP协议&quot;&gt;&lt;/a&gt;简单的HTTP协议&lt;/h2&gt;&lt;h3 id=&quot;1，对于告知服务器意图的HTTP方法：&quot;&gt;&lt;a href=&quot;#1，对于告知
    
    </summary>
    
    
      <category term="网络协议" scheme="https://caixueyuan.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/hello-world/"/>
    <id>https://caixueyuan.github.io/2017/07/03/hello-world/</id>
    <published>2017-07-03T12:45:33.878Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP%20(2)/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP (2)/</id>
    <published>2017-07-02T16:00:00.000Z</published>
    <updated>2017-07-03T13:27:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p>##简单的HTTP协议</p>
<p>###1，对于告知服务器意图的HTTP方法：</p>
<blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<p>###2，持久连接节省通信量</p>
<blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<p>###3，使用Cookie的状态管理<br>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<p>##HTTP报文内的HTTP信息</p>
</blockquote>
<p>###3，编码提升传输速率</p>
<blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<p>###4，发送多种数据的多部分对象集合</p>
<blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<p>###5，获取部分内容的范围请求（Range Request）</p>
<p>###6，内容协调<code>Content Negotiation</code>返回最合适的内容</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<p>##返回结果的HTTP状态</p>
<p>###1，1XX接收的请求正在处理</p>
<p>###2，2XX成功</p>
<blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<p>###3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</p>
<blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<p>###4,4XX客户端是发生错误的原因</p>
<blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<p>###5，5XX：服务器本身错误</p>
<blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<p>##与HTTP协作的Web服务器</p>
<p>###1,用单台虚拟主机实现多个域名</p>
<blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<p>###2,通信数据转发程序</p>
<blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<p>###3，保存资源缓存</p>
<blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<p>##HTTP首部</p>
<p>###1，HTTP首部字段传递重要信息</p>
<blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<p>##2，HTTP首部字段类型：</p>
<blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<p>###3，HTTP/1.1通用首部字段</p>
<blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<p>###4，Cookie：</p>
<blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<p>##确保Web安全的HTTPS</p>
<p>###1，HTTP的缺点</p>
<blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<p>###2，HTTPS（加密，认证，完整性保护）</p>
<blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<p>##确保访问用户身份的认证</p>
<p>###1，BASIC认证</p>
<blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<p>###2,DIGEST认证</p>
<blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<p>###3，SSL客户端认证</p>
<blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<p>###4,基于表单认证</p>
<blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<p>##基于HTTP的功能追加协议</p>
<p>###HTTP的瓶颈：</p>
<blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<p>###WekSocket</p>
<blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
