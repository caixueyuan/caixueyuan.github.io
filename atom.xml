<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2017-07-19T15:48:29.486Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程间通讯</title>
    <link href="https://caixueyuan.github.io/2017/07/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2017/07/19/进程间通讯/</id>
    <published>2017-07-19T15:46:57.000Z</published>
    <updated>2017-07-19T15:48:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><h3 id="1-管道-匿名管道（pipe）"><a href="#1-管道-匿名管道（pipe）" class="headerlink" title="1,管道/匿名管道（pipe）"></a>1,管道/匿名管道（pipe）</h3><blockquote>
<ul>
<li>管道都是半双工，数据只能向一个方向流动</li>
<li>只能用于父子进程或者兄弟进程之间</li>
<li>单独构成一种独立的文件系统（就是有输入输出)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程间通讯&quot;&gt;&lt;a href=&quot;#进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;进程间通讯&quot;&gt;&lt;/a&gt;进程间通讯&lt;/h2&gt;&lt;h3 id=&quot;1-管道-匿名管道（pipe）&quot;&gt;&lt;a href=&quot;#1-管道-匿名管道（pipe）&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/JavaScript学习笔记/</id>
    <published>2017-07-04T15:10:15.000Z</published>
    <updated>2017-07-04T15:10:15.692Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/Spring学习笔记/</id>
    <published>2017-07-04T12:16:49.000Z</published>
    <updated>2017-07-04T12:27:28.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="1，Spring-Security功能性要求："><a href="#1，Spring-Security功能性要求：" class="headerlink" title="1，Spring Security功能性要求："></a>1，Spring Security功能性要求：</h3><blockquote>
<ul>
<li>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问</li>
<li>还能够使用Spring AOP保护方法调用————借助于对象代理和使用通知，能够保护只有具备适当权限的用户才能访问安全保护的方法。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Security&quot;&gt;&lt;a href=&quot;#Spring-Security&quot; class=&quot;headerlink&quot; title=&quot;Spring Security&quot;&gt;&lt;/a&gt;Spring Security&lt;/h2&gt;&lt;h3 id=&quot;1，Spring-Secu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java框架，笔记" scheme="https://caixueyuan.github.io/tags/Java%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP/</id>
    <published>2017-07-03T13:11:49.000Z</published>
    <updated>2017-07-03T13:32:05.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="1，对于告知服务器意图的HTTP方法："><a href="#1，对于告知服务器意图的HTTP方法：" class="headerlink" title="1，对于告知服务器意图的HTTP方法："></a>1，对于告知服务器意图的HTTP方法：</h3><blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<h3 id="2，持久连接节省通信量"><a href="#2，持久连接节省通信量" class="headerlink" title="2，持久连接节省通信量"></a>2，持久连接节省通信量</h3><blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<h3 id="3，使用Cookie的状态管理"><a href="#3，使用Cookie的状态管理" class="headerlink" title="3，使用Cookie的状态管理"></a>3，使用Cookie的状态管理</h3><p>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<h2 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h2></blockquote>
<h3 id="3，编码提升传输速率"><a href="#3，编码提升传输速率" class="headerlink" title="3，编码提升传输速率"></a>3，编码提升传输速率</h3><blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<h3 id="4，发送多种数据的多部分对象集合"><a href="#4，发送多种数据的多部分对象集合" class="headerlink" title="4，发送多种数据的多部分对象集合"></a>4，发送多种数据的多部分对象集合</h3><blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<h3 id="5，获取部分内容的范围请求（Range-Request）"><a href="#5，获取部分内容的范围请求（Range-Request）" class="headerlink" title="5，获取部分内容的范围请求（Range Request）"></a>5，获取部分内容的范围请求（Range Request）</h3><h3 id="6，内容协调Content-Negotiation返回最合适的内容"><a href="#6，内容协调Content-Negotiation返回最合适的内容" class="headerlink" title="6，内容协调Content Negotiation返回最合适的内容"></a>6，内容协调<code>Content Negotiation</code>返回最合适的内容</h3><blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<h2 id="返回结果的HTTP状态"><a href="#返回结果的HTTP状态" class="headerlink" title="返回结果的HTTP状态"></a>返回结果的HTTP状态</h2><h3 id="1，1XX接收的请求正在处理"><a href="#1，1XX接收的请求正在处理" class="headerlink" title="1，1XX接收的请求正在处理"></a>1，1XX接收的请求正在处理</h3><h3 id="2，2XX成功"><a href="#2，2XX成功" class="headerlink" title="2，2XX成功"></a>2，2XX成功</h3><blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<h3 id="3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"><a href="#3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求" class="headerlink" title="3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"></a>3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</h3><blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<h3 id="4-4XX客户端是发生错误的原因"><a href="#4-4XX客户端是发生错误的原因" class="headerlink" title="4,4XX客户端是发生错误的原因"></a>4,4XX客户端是发生错误的原因</h3><blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<h3 id="5，5XX：服务器本身错误"><a href="#5，5XX：服务器本身错误" class="headerlink" title="5，5XX：服务器本身错误"></a>5，5XX：服务器本身错误</h3><blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<h2 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h2><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1,用单台虚拟主机实现多个域名"></a>1,用单台虚拟主机实现多个域名</h3><blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<h3 id="2-通信数据转发程序"><a href="#2-通信数据转发程序" class="headerlink" title="2,通信数据转发程序"></a>2,通信数据转发程序</h3><blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<h3 id="3，保存资源缓存"><a href="#3，保存资源缓存" class="headerlink" title="3，保存资源缓存"></a>3，保存资源缓存</h3><blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="1，HTTP首部字段传递重要信息"><a href="#1，HTTP首部字段传递重要信息" class="headerlink" title="1，HTTP首部字段传递重要信息"></a>1，HTTP首部字段传递重要信息</h3><blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<h2 id="2，HTTP首部字段类型："><a href="#2，HTTP首部字段类型：" class="headerlink" title="2，HTTP首部字段类型："></a>2，HTTP首部字段类型：</h2><blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<h3 id="3，HTTP-1-1通用首部字段"><a href="#3，HTTP-1-1通用首部字段" class="headerlink" title="3，HTTP/1.1通用首部字段"></a>3，HTTP/1.1通用首部字段</h3><blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<h3 id="4，Cookie："><a href="#4，Cookie：" class="headerlink" title="4，Cookie："></a>4，Cookie：</h3><blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<h2 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h2><h3 id="1，HTTP的缺点"><a href="#1，HTTP的缺点" class="headerlink" title="1，HTTP的缺点"></a>1，HTTP的缺点</h3><blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<h3 id="2，HTTPS（加密，认证，完整性保护）"><a href="#2，HTTPS（加密，认证，完整性保护）" class="headerlink" title="2，HTTPS（加密，认证，完整性保护）"></a>2，HTTPS（加密，认证，完整性保护）</h3><blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<h2 id="确保访问用户身份的认证"><a href="#确保访问用户身份的认证" class="headerlink" title="确保访问用户身份的认证"></a>确保访问用户身份的认证</h2><h3 id="1，BASIC认证"><a href="#1，BASIC认证" class="headerlink" title="1，BASIC认证"></a>1，BASIC认证</h3><blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<h3 id="2-DIGEST认证"><a href="#2-DIGEST认证" class="headerlink" title="2,DIGEST认证"></a>2,DIGEST认证</h3><blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<h3 id="3，SSL客户端认证"><a href="#3，SSL客户端认证" class="headerlink" title="3，SSL客户端认证"></a>3，SSL客户端认证</h3><blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<h3 id="4-基于表单认证"><a href="#4-基于表单认证" class="headerlink" title="4,基于表单认证"></a>4,基于表单认证</h3><blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h3><blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<h3 id="WekSocket"><a href="#WekSocket" class="headerlink" title="WekSocket"></a>WekSocket</h3><blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的HTTP协议&quot;&gt;&lt;a href=&quot;#简单的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;简单的HTTP协议&quot;&gt;&lt;/a&gt;简单的HTTP协议&lt;/h2&gt;&lt;h3 id=&quot;1，对于告知服务器意图的HTTP方法：&quot;&gt;&lt;a href=&quot;#1，对于告知
    
    </summary>
    
    
      <category term="网络协议" scheme="https://caixueyuan.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/hello-world/"/>
    <id>https://caixueyuan.github.io/2017/07/03/hello-world/</id>
    <published>2017-07-03T12:45:33.878Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP%20(2)/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP (2)/</id>
    <published>2017-07-02T16:00:00.000Z</published>
    <updated>2017-07-03T13:27:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p>##简单的HTTP协议</p>
<p>###1，对于告知服务器意图的HTTP方法：</p>
<blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<p>###2，持久连接节省通信量</p>
<blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<p>###3，使用Cookie的状态管理<br>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<p>##HTTP报文内的HTTP信息</p>
</blockquote>
<p>###3，编码提升传输速率</p>
<blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<p>###4，发送多种数据的多部分对象集合</p>
<blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<p>###5，获取部分内容的范围请求（Range Request）</p>
<p>###6，内容协调<code>Content Negotiation</code>返回最合适的内容</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<p>##返回结果的HTTP状态</p>
<p>###1，1XX接收的请求正在处理</p>
<p>###2，2XX成功</p>
<blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<p>###3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</p>
<blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<p>###4,4XX客户端是发生错误的原因</p>
<blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<p>###5，5XX：服务器本身错误</p>
<blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<p>##与HTTP协作的Web服务器</p>
<p>###1,用单台虚拟主机实现多个域名</p>
<blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<p>###2,通信数据转发程序</p>
<blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<p>###3，保存资源缓存</p>
<blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<p>##HTTP首部</p>
<p>###1，HTTP首部字段传递重要信息</p>
<blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<p>##2，HTTP首部字段类型：</p>
<blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<p>###3，HTTP/1.1通用首部字段</p>
<blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<p>###4，Cookie：</p>
<blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<p>##确保Web安全的HTTPS</p>
<p>###1，HTTP的缺点</p>
<blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<p>###2，HTTPS（加密，认证，完整性保护）</p>
<blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<p>##确保访问用户身份的认证</p>
<p>###1，BASIC认证</p>
<blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<p>###2,DIGEST认证</p>
<blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<p>###3，SSL客户端认证</p>
<blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<p>###4,基于表单认证</p>
<blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<p>##基于HTTP的功能追加协议</p>
<p>###HTTP的瓶颈：</p>
<blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<p>###WekSocket</p>
<blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
