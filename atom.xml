<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2017-07-03T12:45:33.879Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2019/02/14/hello-world/"/>
    <id>https://caixueyuan.github.io/2019/02/14/hello-world/</id>
    <published>2019-02-13T16:10:35.276Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&#39;C++类&#39;</title>
    <link href="https://caixueyuan.github.io/2018/10/08/C-%E7%B1%BB/"/>
    <id>https://caixueyuan.github.io/2018/10/08/C-类/</id>
    <published>2018-10-08T15:36:33.000Z</published>
    <updated>2018-10-17T14:30:04.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类概念"><a href="#类概念" class="headerlink" title="类概念"></a>类概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> bookNo&#125;</div><div class="line">    Sales_data&amp; combine(<span class="keyword">const</span> Sales_data&amp;);</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>std::string isbn() const{return this-&gt;bookNo;}</code>this的目的总是指向这个对象，this是一个常量指针，不能够修改this中保存的地址。<br>const的作用是修改隐式this指针的类型，相当于const int i =1;中const的作用。<br>默认情况下，this的类型是指向类类型的非常量版本的常量指针。</p>
<p>C++编译顺序：首先编译成员的声明，然后才轮到成员函数体。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用class和struct定义唯一的区别是默认的访问权限，struct的默认权限是public，而class的默认权限是private</p>
<p>不管是在类内，还是在类外，都可以将函数转为内联函数。</p>
<p><strong>可变数据成员</strong>：mutable size_t access_cst;//任何成员函数，包括const函数在内都能够修改它的值。</p>
<p>返回*this的成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos,pos,<span class="keyword">char</span>)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(<span class="keyword">char</span> c)</div><div class="line">&#123;</div><div class="line">    contents[cursor] = c;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//将this对象作为左值返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回引用的函数是左值的，意味这些函数返回的是对象本身而非对象的副本。<br><code>myScreen.move(4,0).set(&#39;#&#39;);</code>//返回的是对象的引用，所以可以这样使用<br>如果返回的是对象的话，也就是<code>inline Screen Screen::set(char c)</code>的话，那么<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Screen temp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);<span class="comment">//对返回值进行拷贝</span></div><div class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);<span class="comment">//不会修改myScreen的contents</span></div></pre></td></tr></table></figure></p>
<p>因此调用set只能改变临时副本，而不能修改myScreen的值</p>
<p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></div><div class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有成员</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//如果一个类指定了友元类，则友元类的成员函数可以访问次类包括非公有成员在内的所有成员</span></div></pre></td></tr></table></figure>
<p>友元关系不存在传递性<br>每个类负责控制自己的友元类或友元函数</p>
<p><strong>让成员函数作为友元</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line"></div><div class="line">    <span class="comment">//Window_mgr:clear必须在Screen类之前被声明</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);<span class="comment">//这样的话只有Window_mgr中的函数clear能够访问Screen中的非公有成员</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;, Screen &amp;)</span></span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;,Screen &amp;)</span></span>;<span class="comment">//storeOn的中ostream版本能够访问Screen对象的私有部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类概念&quot;&gt;&lt;a href=&quot;#类概念&quot; class=&quot;headerlink&quot; title=&quot;类概念&quot;&gt;&lt;/a&gt;类概念&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++基础知识&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-基础知识/</id>
    <published>2018-09-23T13:10:59.000Z</published>
    <updated>2018-10-17T14:30:25.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>case标签</strong>：switch…case中case标签必须是整形常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(deltype(s.size())index = <span class="number">0</span>;index!= s.size() &amp;&amp; !<span class="built_in">isspace</span>(s[index]);++index)&#123;</div><div class="line">    s[index]=<span class="built_in">toupper</span>(s[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误类型</p>
<blockquote>
<ul>
<li>exception最常见的问题</li>
<li>runtime_error只有在运行的时候才能够检测出来的问题</li>
<li>range_error运行时错误，生成的结果超过了有意义的值域范围</li>
<li>overflow_error:运行时错误：计算上溢</li>
<li>underflow_error:运行时错误：计算下溢</li>
<li>logic_error：程序逻辑错误</li>
<li>domain_error:逻辑错误：参数对应的结果不存在</li>
<li>invalid_argument:逻辑错误：无效参数</li>
<li>length_error：逻辑错误，试图创建一个超出该类型最大长度的对象</li>
<li>out_of_range：逻辑错误：使用一个超过有效范围的值</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> runtime_error(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(runtime_error err)&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;err.what()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数的返回值不能是数组类型或者函数类型，但可以是指向数组或函数的指针</strong></p>
<p><strong>局部静态对象</strong>：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;<span class="comment">//调用结束后，这个值仍然有效</span></div><div class="line">    <span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><p>分离式编译<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span></div><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span> -o main</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CC -c factMain<span class="selector-class">.cc</span></div><div class="line">CC -c fact<span class="selector-class">.cc</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span> -o main</div></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>传值参数</strong>：</p>
<blockquote>
<ul>
<li>传基本类型</li>
<li>指针形参：指针也是值，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span></div><div class="line">&#123;</div><div class="line">    *ip = <span class="number">0</span>;<span class="comment">//改变指针ip所指对象的值</span></div><div class="line">    ip = <span class="number">0</span>;<span class="comment">//只改变了ip的局部拷贝，实参没有改变</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>传引用参数</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></div><div class="line">&#123;</div><div class="line">    i = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用引用的好处是：</p>
<blockquote>
<ul>
<li>使用引用避免拷贝</li>
<li>使用引用形参返回额外信息。</li>
</ul>
</blockquote>
<p>顶层和底层const<br><strong>顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;<span class="comment">//不能够修改p1的值，这是一个顶层const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能修改ci的值，这是一个顶层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">//允许修改p2的值，这是一个底层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;case标签&lt;/strong&gt;：switch…case中case标签必须是整形常量表达式。&lt;/p&gt;
&lt;figure clas
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++算术运算符&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-算术运算符/</id>
    <published>2018-09-23T09:25:11.000Z</published>
    <updated>2018-09-23T11:15:34.079Z</updated>
    
    <content type="html"><![CDATA[<p>##赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">while</span>((i=get_value()) != <span class="number">42</span>)&#123;</div><div class="line">    <span class="comment">//其他处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<blockquote>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1</li>
<li>对引用类型执行sizeof运算得到被引用对象所占的空间的大小</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得到的结果求和</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz=<span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);<span class="comment">//得到ia元素的个数</span></div></pre></td></tr></table></figure>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p><strong>static_cast</strong>:作用域任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* p = &amp;d;<span class="comment">//正确：任何非常量对象的地址都能够存入void*</span></div><div class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);<span class="comment">//正确，将void*转换回初始的指针类型</span></div></pre></td></tr></table></figure></p>
<p><strong>const_cast</strong>:只能改变运算对象的底层const。能够将常量对象转换成非常量对象的行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##赋值运算符&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>指针与引用</title>
    <link href="https://caixueyuan.github.io/2018/09/11/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2018/09/11/指针与引用/</id>
    <published>2018-09-11T14:07:02.000Z</published>
    <updated>2018-09-23T07:57:16.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。<br><code>int &amp;refVal4 = 10</code>这种引用类型不是一个对象。</p>
<p>指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象。其二,指针无需在定义时赋初值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//&amp;是取地址符，存放变量ival的地址，或者说p是指向变量ival的指针。</span></div><div class="line"><span class="comment">//第二条语句把p定义为一个指向int的指针，随后初始化p让其指向名为ival的int对象。</span></div><div class="line"><span class="keyword">int</span> *p;</div><div class="line">p = &amp;ival;</div></pre></td></tr></table></figure></p>
<p>在constexpr声明中，如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是一个指向整形常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是一个指向整数的常量指针</span></div></pre></td></tr></table></figure></p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</div><div class="line"><span class="keyword">using</span> SI= Sales_Item;</div></pre></td></tr></table></figure>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;<span class="comment">//sum的类型就是函数f的返回类型</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci =<span class="number">0</span>,&amp;cj = ci;</div><div class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是const int</span></div><div class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></div><div class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误，引用不能够为空</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p = &amp;i;</div><div class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//解引用指针可以得到指针所指定的对象，而且给这个对象赋值，因为结果是int&amp;</span></div></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>)<span class="comment">//v1有10个元素，每个元素的值都是0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;<span class="comment">//v2有1个元素，元素的值为0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//v3有10个元素，每个元素的值都是1</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125;<span class="comment">//v4有2个元素，元素的值为10,1</span></div></pre></td></tr></table></figure>
<p>vector对象的下标对象运算符可用于访问已存在的元素,而不能够用于添加元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</div><div class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;</div><div class="line">    <span class="keyword">auto</span> it = s.begin();</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); it++)&#123;</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>迭代器类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读写类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">string</span>::iterator it2;</div><div class="line"><span class="comment">//只读类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</div><div class="line"><span class="built_in">string</span>::const_iterator it4;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</div><div class="line"><span class="keyword">auto</span> it1 = v.begin();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></div><div class="line"><span class="keyword">auto</span> it2 = cv.begin();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line"><span class="keyword">auto</span> it3 = v.cbegin();<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line">（*it).empty()等于it-&gt;empty()<span class="comment">//it为迭代器</span></div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义数组时一定要保证数组的个数为常量，定义数组时一定要定义数组的类型，不能够是使用auto<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> cnt = <span class="number">12</span>;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> cnt1 = <span class="number">12</span>;<span class="comment">//常量表达式</span></div><div class="line"><span class="built_in">string</span> bad[cnt];<span class="comment">//错误，cnt不是常量表达式</span></div></pre></td></tr></table></figure></p>
<p>字符数组的特殊性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span><span class="comment">//自动添加表示字符串结束的空字符</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Deniel"</span>;<span class="comment">//错误，没有空间可存放空字符</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：不能够将数组拷贝给其他数组作为初始值</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int (*Parray)[<span class="number">10</span>] = <span class="meta">&amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span></div><div class="line">int (<span class="meta">&amp;arrRef)[10] = arr;<span class="comment">//arrRef引用一个含有10个整数的数组</span></span></div></pre></td></tr></table></figure>
<p><strong>指针和数组</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>];</div><div class="line"><span class="built_in">string</span> *p2 = nums;<span class="comment">//等价于string *p = &amp;nums[0];</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(nums)</span></span>;<span class="comment">//ia2是一个整形指针，指向ia的第一个元素</span></div></pre></td></tr></table></figure></p>
<p>数组输出全部元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *e = &amp;arr[<span class="number">10</span>];<span class="comment">//arr有10个元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = &amp;arr;b!=e;b++)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数组的函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line">int *pbeg = begin(arr);</div><div class="line">int *pend = end(arr);</div><div class="line">while(pbeg != pend &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</div><div class="line">    ++pbeg;</div></pre></td></tr></table></figure></p>
<p>只有同一相关对象的指针才能够比较，不相关对象的指针不能够进行比较。</p>
<h3 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;</div><div class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</div><div class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];<span class="comment">//把row绑定到ia的第二个4元素数组上</span></div><div class="line"><span class="comment">//把row定义为一个含有4个整数的数组的引用，然后将其绑定到ia的第2行。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。&lt;br&gt;&lt;code&gt;int &amp;amp;refVal4 
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ string字符串</title>
    <link href="https://caixueyuan.github.io/2018/09/09/string%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://caixueyuan.github.io/2018/09/09/string字符串/</id>
    <published>2018-09-09T15:14:50.000Z</published>
    <updated>2018-09-23T07:57:20.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化有两种，直接初始化和拷贝初始化。<br>拷贝初始化<code>string a = &#39;abc&#39;</code><br>直接初始化<code>string a {&#39;abc&#39;}</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>C++语法中的字符串字面值并不是标准库中的string的对象。字符串字面量和string是不同的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> a = <span class="string">"abc"</span>;</div><div class="line"><span class="built_in">string</span> b = a+<span class="string">"def"</span>+<span class="string">"ghi"</span>;<span class="comment">//正确，(a+"def")+"ghi"</span></div><div class="line"><span class="built_in">string</span> c = <span class="string">"def"</span>+<span class="string">"ghi"</span>+a；<span class="comment">//错误，("def"+"ghi")+a</span></div></pre></td></tr></table></figure>
<p>C++能够改变字符串中的字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s &#123;<span class="string">"abc"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;temp : s)</div><div class="line">&#123;</div><div class="line">    temp = <span class="built_in">toupper</span>(temp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将第一个词变成大写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//isspace()使用这些函数时需要添加头文件#include&lt;cctype&gt;</span></div><div class="line"><span class="built_in">string</span> s1&#123;<span class="string">"Hello World!!!"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s1.size()) index = <span class="number">0</span>; index &lt; s1.size() &amp;&amp; !<span class="built_in">isspace</span>(s1[index]); index++)</div><div class="line">&#123;</div><div class="line">    s1[index] = <span class="built_in">toupper</span>(s1[index]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><code>string::size_type n</code>用于访问字符串的下标</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL表</title>
    <link href="https://caixueyuan.github.io/2018/08/12/MySQL%E8%A1%A8/"/>
    <id>https://caixueyuan.github.io/2018/08/12/MySQL表/</id>
    <published>2018-08-12T15:36:07.000Z</published>
    <updated>2018-09-23T07:57:23.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p><strong>索引组织表</strong>：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主键<br><code>_rowid</code>可以显示表的主键，只能够查看单个列为主键的情况，并且为非空唯一索引。</p>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>表空间（tablespace)–&gt;端（segment)—&gt;区（extent)—&gt;页（page)—&gt;块（block)</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。所有的数据都存放在这个表空间中。如果弃用了参数innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。</p>
<p>表空间只存放数据、索引和插入缓冲Bitmap页，其他的数据（如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）还是存放在原来的共享表空间中。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>常见的段有数据段、索引段、回滚段。数据段为B+树的叶子节点，而索引段为B+树的非索引节点</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>由连续页组成的空间，在任何情况下每个区的大小都是1MB，在默认情况下页的大小为16KB，即一个区中一共有64个连续的页。<br>可以通过参数innodb_page_size来设置默认页的大小</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB存储引擎是面向列的，数据都是按照行来进行存放的，最多允许存放16KB/2-200行的记录，也就是7992行</p>
<h2 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h2><p>使用<code>show table status like &#39;table_name&#39;</code>来查看当前表使用的行格式。</p>
<h3 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h3><p>MySQL5.0引入的，其设计的目的是高效地存储数据。<br>一个页中存放的行数据越多，其性能就越高。<br>在compact格式下，NULL值都不占用任何存储空间，不管是CHAR类型或者是VARCHAR类型</p>
<h3 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h3><p>MySQL5.0之前的。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>BLOB可以不将数据放在溢出页面中，而且即使是VARCHAR列数据类型，依然有可能被存放为行溢出数据。通过实际测试，VARCHAR的类型的最大长度为65532.VARCHAR类型最大支持65535字节。</p>
<p>MySQL官方手册中定义的65535长度是指所有的VARCHAR列的长度总和，如果列的长度总和超过了这个长度，依然无法创建。</p>
<p>InnoDB存储引擎的页为16KB，也就是16384字节，在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。</p>
<p>一个页存放数据，如果为两条数据的话，那么每条的最大的阈值为8098.</p>
<h3 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h3><p>InnoDB1.0.x引入新的文件格式，Compressed和Dynamic<br>新的两种记录格式对于存放在BLOB中的数据采用完全的行溢出的方式。同时，存储在其中的行数据会以zlib的算法进行压缩，</p>
<h3 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h3><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度</p>
<p>CHAR(2)保存的是2个字符，不管是GBK，还是UTF-8，还是latin，都是2个字符，而不是2个字节。所以存储的字节是变化的。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>包括7个部分：</p>
<blockquote>
<ul>
<li>File Header(文件头)</li>
<li>Page Header(页头)</li>
<li>infimum和Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer(文件结尾信息)</li>
</ul>
</blockquote>
<h2 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引组织表&quot;&gt;&lt;a href=&quot;#索引组织表&quot; class=&quot;headerlink&quot; title=&quot;索引组织表&quot;&gt;&lt;/a&gt;索引组织表&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引组织表&lt;/strong&gt;：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件</title>
    <link href="https://caixueyuan.github.io/2018/08/12/MySQL%E6%96%87%E4%BB%B6/"/>
    <id>https://caixueyuan.github.io/2018/08/12/MySQL文件/</id>
    <published>2018-08-12T09:42:46.000Z</published>
    <updated>2018-08-12T16:14:08.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><p>告诉MySQL实例启动时在哪里，指定初始化参数，定义某些内存结构的大小</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer%'</span>;显示查询参数</div><div class="line"><span class="keyword">set</span> read_buffer_size = <span class="number">100100</span>;//设置查询参数</div><div class="line"><span class="keyword">select</span> @@session.read_buffer_size;</div></pre></td></tr></table></figure>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>记录影响MySQL数据库的各种类型活动</p>
<blockquote>
<ul>
<li><strong>错误日志</strong>:对MySQL的启动、运动、关闭过程进行记录，<code>Show Variables like &#39;log_error&#39;</code></li>
<li><strong>查询日志</strong>：记录了所有对MySQL数据库请求的信息。</li>
<li><strong>二进制日志</strong>：记录对MySQL数据库执行更改的所有操作，不包括SELECT和SHOW等操作<code>SHOW MASTER STATUS</code></li>
<li><strong>套接字</strong>：在Unix域套接字</li>
<li>pid文件：将自己的进程ID写入到一个文件中</li>
<li>表结构定义文件：MySQL数据的存储是根据表进行的，每个表都有与之对应的文件</li>
<li>InnoDB存储引擎文件：</li>
</ul>
</blockquote>
<p><strong>表空间文件</strong>：将存储的数据按照表空间进行存放的设计，在默认配置下为10M，多个文件可以组成一个表空间。<br>重做日志文件：当实例或者介质失败时，重做日志文件就有用，用来恢复数据</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数文件&quot;&gt;&lt;a href=&quot;#参数文件&quot; class=&quot;headerlink&quot; title=&quot;参数文件&quot;&gt;&lt;/a&gt;参数文件&lt;/h2&gt;&lt;p&gt;告诉MySQL实例启动时在哪里，指定初始化参数，定义某些内存结构的大小&lt;/p&gt;
&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="https://caixueyuan.github.io/2018/08/12/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://caixueyuan.github.io/2018/08/12/InnoDB存储引擎/</id>
    <published>2018-08-12T08:12:23.000Z</published>
    <updated>2018-08-12T09:42:12.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p><strong>后台线程</strong>：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据，将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态</p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><blockquote>
<ul>
<li>Master Thread<br>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲和UNDO页的回收</li>
<li><p>IO Thread<br>负责异步IO请求的回调</p>
</li>
<li><p>Purge Thread<br>在事务被提交后，所使用的undolog可能不需要，负责来回收已经使用并分配的undo页。</p>
</li>
<li><p>Page Cleaner Thread<br>将之前版本中脏页的刷新操作都放入到单独的线程中来完成，减轻Master Thread的工作和对于用户查询线程的阻塞。</p>
</li>
</ul>
</blockquote>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><blockquote>
<ul>
<li><p>缓冲池：使用CheckPoint的机制刷新内存页，缓存的数据包括：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息。</p>
</li>
<li><p>LRU List、Free List和Flush List</p>
</li>
<li><p>重做日志缓冲</p>
</li>
</ul>
</blockquote>
<h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><blockquote>
<ul>
<li><p>插入缓冲：<br><strong>Insert Buffer</strong>：当索引是辅助索引，索引不是唯一的<br><strong>Change Buffer</strong>：对DML操作（INSERT,DELETE,UPDATE)进行缓冲<br><strong>Merge Insert Buffer</strong>：合并插入缓存到磁盘中</p>
</li>
<li><p>两次写：两次写入提高效率</p>
</li>
<li>自适应哈希索引：提高查询的效率，比B+树的查找更快</li>
<li>异步IO：将多个IO合并为1个IO请求</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;InnoDB体系结构&quot;&gt;&lt;a href=&quot;#InnoDB体系结构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系结构&quot;&gt;&lt;/a&gt;InnoDB体系结构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;后台线程&lt;/strong&gt;：负责刷新内存池中的数据，保证缓冲
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 学习笔记（一）</title>
    <link href="https://caixueyuan.github.io/2018/08/06/MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://caixueyuan.github.io/2018/08/06/MySQL-学习笔记（一）/</id>
    <published>2018-08-06T15:38:46.000Z</published>
    <updated>2018-08-06T16:05:52.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h2><blockquote>
<ul>
<li>数据库：物理操作系统文件或者其他文件类型的集合</li>
<li>实例: 应用程序，数据库程序真正操作与数据库文件</li>
</ul>
</blockquote>
<p><strong>注意</strong>：MySQL是一个单进程多线程的数据库，使用代码来查找<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> mysqld</div></pre></td></tr></table></figure></p>
<p>查看配置文件的位置，用mysql–help.</p>
<p>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合，数据库实例是应用程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义等等都是在数据库实例下进行的，应用程序只有通过数据库实例才能够与数据库打交道</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/sql/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="MySQL体系结构"></p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎对于MySQL来说是可插拔的</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>特点：支持事务，行级锁，支持外键，非锁定读（也就是说默认读取活动不会产生锁）<br>每张表的存储都是按照主键的顺序来存储的</p>
<h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>特点：不支持事务，表锁设计，支持全文索引，同时有一个大的不同就是只缓存索引文件而不缓存数据文件</p>
<p>可以使用<code>show engines</code>来显示所用的存储引擎</p>
<h2 id="链接MySQL的方式"><a href="#链接MySQL的方式" class="headerlink" title="链接MySQL的方式"></a>链接MySQL的方式</h2><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>这是默认的方式，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">-h</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">-u</span> <span class="selector-tag">dbuser</span> <span class="selector-tag">-p</span></div></pre></td></tr></table></figure></p>
<p>可以使用mysql数据库下的user表来查看用户的信息</p>
<h3 id="命名管道或者共享内存"><a href="#命名管道或者共享内存" class="headerlink" title="命名管道或者共享内存"></a>命名管道或者共享内存</h3><p>Windows中的，只要使用–enable-named-pipe</p>
<h3 id="Unix-域套接字"><a href="#Unix-域套接字" class="headerlink" title="Unix 域套接字"></a>Unix 域套接字</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u dbuser -s <span class="regexp">/tmp/my</span>sql.sock</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库与实例&quot;&gt;&lt;a href=&quot;#数据库与实例&quot; class=&quot;headerlink&quot; title=&quot;数据库与实例&quot;&gt;&lt;/a&gt;数据库与实例&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据库：物理操作系统文件或者其他文件类型的集合&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="https://caixueyuan.github.io/2018/08/01/Oracle/"/>
    <id>https://caixueyuan.github.io/2018/08/01/Oracle/</id>
    <published>2018-07-31T16:01:18.000Z</published>
    <updated>2018-08-06T16:05:02.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><strong>多表插入</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">insert</span> all</div><div class="line"> <span class="keyword">when</span> sum_order &lt;<span class="number">10000</span> <span class="keyword">then</span></div><div class="line"> <span class="built_in">int</span> small_customers</div><div class="line"> <span class="keyword">when</span> sum_orders &gt;= <span class="number">10000</span> <span class="keyword">and</span> sum_orders &lt; <span class="number">100000</span> <span class="keyword">then</span></div><div class="line"> <span class="built_in">int</span> medium_customers</div><div class="line"> <span class="keyword">else</span></div><div class="line"> <span class="keyword">into</span> large_customers</div><div class="line"> <span class="keyword">select</span> customer_id,<span class="keyword">sum</span>(order_total)</div><div class="line"> <span class="keyword">from</span> oe.orders</div><div class="line"> <span class="keyword">group</span> <span class="keyword">by</span> customer_id;</div></pre></td></tr></table></figure></p>
<h2 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL执行</h2><h3 id="共享池"><a href="#共享池" class="headerlink" title="共享池"></a>共享池</h3><p>就是内存中缓存用户进行SQL查询的一块空间。不管有多少个用户想要执行同样的SQL语句，Oracle都会只解析该语句一次，然后在想要使用的用户之间共享。</p>
<p>在执行每一句SQL语句时必然会发生的事情是它必须被解析并载入到库高速缓存中，库高速缓存是共享池中用来保存之前已经解析过的语句区域。当解析通过之后，就要确定这个语句是否执行过。如果已经执行过，那就是软解析，直接得到解析的过程。如果没有找到语句，那就要生成执行计划，这叫做硬解析。<br>锁存器是为了检查你要执行的SQL语句是否已经存在而要在库高速缓存中获取一个锁存器。而互斥锁是为了阻止多个线程同时访问一个共享结构。</p>
<p>绑定变量能够很好地减少硬编码，提高效率</p>
<p><strong>重要</strong>：</p>
<blockquote>
<ul>
<li>数据的写入器不会阻塞数据读取器。重复一遍：写入不阻塞读取。这和其他大部分数据库从根本上是不同的，其他数据库写入阻塞读取。</li>
<li>用OPEN 命令返回<br>的结果集，当打开表时，接触的已不是表中的单块数据，而是已经确定好的结果。在提取数据之前，并不知道结果。然而从游标上看，结果是不会变的。打开游标时，Oracle 并不是把上面所有数据复制到其他地方；实际上是delete命令把数据复制到一个称为回滚段的数据区域保存。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本语句&quot;&gt;&lt;a href=&quot;#基本语句&quot; class=&quot;headerlink&quot; title=&quot;基本语句&quot;&gt;&lt;/a&gt;基本语句&lt;/h2&gt;&lt;h3 id=&quot;insert&quot;&gt;&lt;a href=&quot;#insert&quot; class=&quot;headerlink&quot; title=&quot;inser
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://caixueyuan.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL</title>
    <link href="https://caixueyuan.github.io/2018/07/29/T-SQL/"/>
    <id>https://caixueyuan.github.io/2018/07/29/T-SQL/</id>
    <published>2018-07-29T08:49:12.000Z</published>
    <updated>2018-07-29T16:07:45.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>定义用户数据类型<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sp_addtype dbname2,<span class="symbol">'varchar</span>(<span class="number">10</span>)<span class="string">','</span><span class="keyword">not</span> null'</div></pre></td></tr></table></figure></p>
<p>显示用户定义的数据类型<strong>sp_help</strong><br>删除用户定义的数据类型<strong>sp_droptype dbname2</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="meta">@var</span>1 <span class="keyword">int</span><span class="comment">//定义局部变量</span></div><div class="line"><span class="keyword">declare</span> @<span class="meta">@var</span>2 <span class="keyword">int</span><span class="comment">//定义全局变量</span></div></pre></td></tr></table></figure>
<h3 id="数据库设备"><a href="#数据库设备" class="headerlink" title="数据库设备"></a>数据库设备</h3><p>使用SQL命令创建数据库设备<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Disk Init</div><div class="line">name = 'mydev2',</div><div class="line">physname = 'e:\devices\mydev2.dat',</div><div class="line">vdevno = 2,</div><div class="line">size = 1024</div><div class="line">go</div></pre></td></tr></table></figure></p>
<p>指定默认的数据库设备<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_diskdefault</span> mydev,defaulton</div></pre></td></tr></table></figure></p>
<p>显示数据库设别的信息<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_diskdefault</span> mydev,defaultoff</div></pre></td></tr></table></figure></p>
<p>删设备<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_dropdevice</span> logical_name</div></pre></td></tr></table></figure></p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sp_rename objname,newname<span class="comment">//修改名字</span></div><div class="line">Alter <span class="keyword">table</span> newroysched <span class="comment">partition 4</span>//将表所在的段分割表</div><div class="line">sp_help,sp_helpartition.<span class="comment">//查看表的分割信息</span></div><div class="line">alter <span class="keyword">table</span> newroysched <span class="comment">unpartition</span>//删除表的分割</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">unique</span>(clustered) <span class="keyword">index</span> <span class="keyword">on</span> tablename.columnname//创建索引</div><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span> tablename.columnname//删除索引</div></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create <span class="keyword">default</span> datefault <span class="keyword">as</span> getdate()<span class="comment">//创建默认值</span></div><div class="line">sp_binddefault datefault,<span class="string">"sale.date"</span><span class="comment">//对列关联默认值</span></div></pre></td></tr></table></figure>
<p><strong>规则</strong>：当进行insert或者update操作时，自动用关联的规则，检查所输入的数据的有效性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> Rule daterule <span class="keyword">as</span> @pub_id <span class="keyword">between</span> <span class="string">"1900.1.1"</span> <span class="keyword">and</span> <span class="keyword">getdate</span>()//创建故障</div><div class="line">sp_birdrule Rule_Name <span class="string">"sale.date"</span>//对列关联规则</div></pre></td></tr></table></figure>
<p><strong>视图</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">view</span> pub_view <span class="keyword">as</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span></div></pre></td></tr></table></figure></p>
<p>使用With Check Option选项允许检查视图的数据，有利于从视图中删除不良的DML语句</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://caixueyuan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Spring Boot&#39;</title>
    <link href="https://caixueyuan.github.io/2018/06/22/Spring-Boot/"/>
    <id>https://caixueyuan.github.io/2018/06/22/Spring-Boot/</id>
    <published>2018-06-22T07:41:42.000Z</published>
    <updated>2018-06-22T08:03:17.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot核心"><a href="#Spring-Boot核心" class="headerlink" title="Spring Boot核心"></a>Spring Boot核心</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong>@SpringBootApplication</strong>:表示一个入口类<br><strong>@EnableAutoConfiguration</strong>:让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置</p>
<blockquote>
<ul>
<li>Spring-boot-starter-web:自动添加Tomcat和Spring MVC的依赖</li>
<li>spring-boot-starter-data-jpa:自动进行JPA相关的配置</li>
</ul>
</blockquote>
<p><strong>关闭特定的自动配置</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**使用XML配置**:```@ImportResource(&#123;&quot;classpath:some-context.xml&quot;,&quot;classpath:another-context.xml&quot;&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Boot核心&quot;&gt;&lt;a href=&quot;#Spring-Boot核心&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot核心&quot;&gt;&lt;/a&gt;Spring Boot核心&lt;/h2&gt;&lt;h3 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot;
    
    </summary>
    
      <category term="Java框架" scheme="https://caixueyuan.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://caixueyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>&#39;SpringBoot-Spring-Security-JWT-登陆&#39;</title>
    <link href="https://caixueyuan.github.io/2018/04/14/SpringBoot-Spring-Security-JWT-%E7%99%BB%E9%99%86/"/>
    <id>https://caixueyuan.github.io/2018/04/14/SpringBoot-Spring-Security-JWT-登陆/</id>
    <published>2018-04-14T15:59:24.000Z</published>
    <updated>2018-04-15T12:45:45.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-Spring-Security-JWT-登陆"><a href="#SpringBoot-Spring-Security-JWT-登陆" class="headerlink" title="SpringBoot Spring Security JWT 登陆"></a>SpringBoot Spring Security JWT 登陆</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/2409835-4798863c521de365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641" alt="JWT SpringBoot"></p>
<p>传统的登陆验证方式主要是Cookie认证机制，为解决HTTP无状态协议下服务器如何识别用户的问题，其原理是在用户登陆通过验证后，服务器将数据加密后保存到客户端浏览器的Cookie中，同时，服务器保留相应的Session，用户之后发起的请求都会携带Cookie信息，服务端根据Cookie寻回对应的session，完成验证。<br>缺点：</p>
<blockquote>
<ul>
<li>session保存到服务器内存中，每次请求都要携带Cookie，占据带宽，服务器开销明显增大</li>
<li>扩展性：在分布式应用上，限制了负载均衡器的能力和扩展能力</li>
<li>CSRF和XSS攻击：Cookie存放在客户端，Cookie很容易被获取，进行跨站请求伪造攻击</li>
</ul>
</blockquote>
<p><strong>JWT Spring boot</strong><br>构成：</p>
<blockquote>
<ul>
<li>header，声明类型，加密算法</li>
<li>playload(载荷）,标准注册声明，公共声明，私有声明</li>
<li>signature：服务器端的私钥</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>使用JSON，可以进行跨语言支持</li>
<li>便于传输，构成简单，字节占用很小</li>
<li>不需要在服务器保存会话信息，易于应用扩展</li>
<li>防止XSS攻击</li>
<li>保证前后端分离</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>客户通过将其凭据发送给身份提供者进行登录。</li>
<li>身份提供者验证凭证; 如果一切正常，它将检索用户数据，生成一个包含将用于访问服务的用户详细信息和权限的JWT，并且还会在JWT（可能不受限制）上设置到期日期。</li>
<li>身份提供商签名，并在需要时加密JWT，并将其作为初始请求的凭据响应发送给客户端。</li>
<li>客户根据身份提供商设置的有效期限将JWT存储有限或无限的时间。</li>
<li>客户端将每个请求的授权标头中存储的JWT发送给服务提供商。</li>
<li>对于每个请求，服务提供者都从Authorization头部获取JWT 并对其进行解密（如果需要），验证签名，如果一切正常，则提取用户数据和权限。仅根据这些数据，再次查看数据库中的进一步细节或联系身份提供者，它可以接受或拒绝客户端请求。唯一的要求是身份和服务提供商就加密达成一致，以便服务可以验证签名或甚至解密哪个身份已加密。</li>
</ul>
</blockquote>
<p><a href="https://www.jianshu.com/p/ec9b7bc47de9" target="_blank" rel="external">查看博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot-Spring-Security-JWT-登陆&quot;&gt;&lt;a href=&quot;#SpringBoot-Spring-Security-JWT-登陆&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Spring Security
    
    </summary>
    
      <category term="毕业设计" scheme="https://caixueyuan.github.io/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="毕业设计" scheme="https://caixueyuan.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JQuery基础知识</title>
    <link href="https://caixueyuan.github.io/2018/04/06/JQuery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2018/04/06/JQuery基础知识/</id>
    <published>2018-04-06T07:26:55.000Z</published>
    <updated>2018-04-11T08:50:22.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识JQuery"><a href="#认识JQuery" class="headerlink" title="认识JQuery"></a>认识JQuery</h2><h3 id="JQuery和JavaScript的转换"><a href="#JQuery和JavaScript的转换" class="headerlink" title="JQuery和JavaScript的转换"></a>JQuery和JavaScript的转换</h3><hr>
<p>JQuery对象转换为DOM对象</p>
<blockquote>
<ul>
<li><p>通过[index]的方法得到相应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</div><div class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>通过get(index)方法得到相应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</div><div class="line"><span class="keyword">var</span> cr = $cr.get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<hr>
<hr>
<p>DOM对象转化为JQuery对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cr = <span class="built_in">document</span>.getElementById(<span class="string">"cr"</span>);</div><div class="line"><span class="keyword">var</span> $cr = $(cr);</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</div><div class="line">cr.checked</div><div class="line"></div><div class="line">$cr.is(<span class="string">":checked"</span>)</div></pre></td></tr></table></figure>
<h3 id="解决jQuery和其他库的冲突"><a href="#解决jQuery和其他库的冲突" class="headerlink" title="解决jQuery和其他库的冲突"></a>解决jQuery和其他库的冲突</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//(1)自定义快捷方式</span></div><div class="line"><span class="keyword">var</span> $j = jQuery.noConflict();</div><div class="line"></div><div class="line"><span class="comment">//(2)在函数内部默认都是指定jQuery</span></div><div class="line">jQuery.noconflict();</div><div class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert($(<span class="keyword">this</span>).text));</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="jQuery选择器的优势"><a href="#jQuery选择器的优势" class="headerlink" title="jQuery选择器的优势"></a>jQuery选择器的优势</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    $(<span class="string">'#tt'</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);<span class="comment">//如果没有元素tt的话，就不会执行下面的语句</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="jQuery选择器-1"><a href="#jQuery选择器-1" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><p><strong>层次选择器</strong>：</p>
<p><code>$(&quot;body div&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变<body>内所有<div>的背景色，将整个div的都改变背景色<br><code>$(&#39;body &gt; div&#39;).css(&#39;background&#39;,&quot;#bbffaa&quot;)</code>改变<body>内子<div>元素的背景色，将整个div中不包括子元素的空白部分改变背景色</div></body></div></body></p>
<p><strong>过滤选择器</strong><br><code>$(&#39;:header&#39;)</code>选取网页中的所有的</p><h1>，<h2>,<h3><br><code>$(&#39;:animated&#39;)</code>选取当前正在执行动画的所有元素<br><code>$(&#39;:focus&#39;)</code>选取当前获取焦点的元素<p></p>
<p><strong>内容过滤选择器</strong><br><code>$(&quot;div:parent&quot;)</code>选择拥有子元素的<div>元素</div></p>
<p><strong>可见性过滤选择器</strong><br><code>$(&quot;:hidden&quot;)</code>选取所有不可见的元素。包括<code>&lt;input type=&quot;hidden&quot;/&gt;</code>,<code>&lt;div style=&quot;display:none;&quot;&gt;</code>和<code>&lt;div style=&quot;visibility:hidden;&quot;&gt;</code><br><code>$(&#39;:visible)</code>选取所有可见的元素</p>
<p><strong>属性过滤选择器</strong><br><code>$(&quot;div[title|= &#39;en&#39;]&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变属性title等于en或者以en为前缀的元素的背景色<br><code>$(&quot;div[title ~= &#39;uk&#39;]&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变属性title用空格分隔的值中包含uk的元素的背景色</p>
<p><strong>子元素过滤选择器</strong><br><code>:nth-child(index/even/odd/equation)</code>选取每个父元素下的第index个子元素或者奇偶元素（index从1算起）</p>
<p><strong>表单对象属性过滤选择器</strong><br><code>:selected</code>:选取所有被选中的选项元素,下拉列表<br><code>:checked</code>:选取所有被选中的元素，单选框和复选框</p>
<h2 id="jQuery中的DOM操作"><a href="#jQuery中的DOM操作" class="headerlink" title="jQuery中的DOM操作"></a>jQuery中的DOM操作</h2><blockquote>
<ul>
<li><p><strong>remove()</strong>和<strong>detach()</strong>：都是从DOM中去掉所有匹配的元素，这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove()不同的是，所有绑定的事件、附加的数据都会保留下来</p>
</li>
<li><p><strong>empty()</strong>：清空节点，清空元素中的所有后代节点</p>
</li>
<li><p><strong>clone()</strong>复制节点后，被复制的新元素并不具有任何行为，如果需要新元素也具有复制功能（绑定在元素中的事件），应该加上true</p>
</li>
<li>replaceWith()将所有匹配的元素都替换成指定的HTML或者DOM元素</li>
<li>wrapAll()将所有匹配的元素用一个元素包裹起来</li>
<li>wrapInner()将每一个匹配的元素的子内容（包括文本节点）用其他结构的标记包裹起来</li>
<li>attr()可以获取或者设置元素的属性</li>
<li><p>toggle()交替执行代码3和代码4，如果元素原来是显示的，那么隐藏她，如果是隐藏的，那么显示它。也就是控制行为上的重复切换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$toggleBtn.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//3</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></div><div class="line">    <span class="regexp">//</span><span class="number">4</span></div><div class="line">));</div></pre></td></tr></table></figure>
</li>
<li><p>html()读取或者设置某个元素中的HTML内容，相当于innerHTML</p>
</li>
<li>text()读取或者设置某个元素中的文本内容，相当于innerText属性</li>
<li>this.defaultValue就是当前文本框的默认值</li>
<li><p>val()不仅能设置元素的值，通过也能够获取元素的值，还能够使得select，checkbox，radio相应的选项被选中</p>
</li>
<li><p>children()获取匹配元素的所有子元素的个数</p>
</li>
<li>next(),prev()匹配元素前面近邻的同辈元素</li>
<li>siblings()获取匹配元素的所有兄弟节点</li>
<li>closest()取得最近的匹配元素，首先检查当前元素是否匹配的，如果匹配则直接返回元素本身，如果不匹配，向上查找父元素，逐渐向上直到找到匹配选择器的元素。</li>
<li>offset()获取元素在当前视窗的相对偏移</li>
<li>position()获取元素相对于最近的一个position样式设置为relative或者absolute的祖先节点的相对偏移</li>
<li>scrollTop()和scrollLeft()获取元素的滚动条据顶端的距离和距离左侧的距离</li>
</ul>
</blockquote>
<hr>
<p><strong>parent()</strong>和<strong>parents()</strong>和<strong>closest</strong>的区别<br><strong>parent</strong>获取集合中的每个匹配元素的父级元素<br><strong>parents</strong>获取集合中的每个匹配元素的祖先元素，包括父级，父级以上</p>
<h2 id="closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素"><a href="#closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素" class="headerlink" title="closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素"></a><strong>closest</strong>：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素</h2><h2 id="jQuery中的事件和动画"><a href="#jQuery中的事件和动画" class="headerlink" title="jQuery中的事件和动画"></a>jQuery中的事件和动画</h2><h3 id="jQuery中的事件"><a href="#jQuery中的事件" class="headerlink" title="jQuery中的事件"></a>jQuery中的事件</h3><p><strong>$(document).ready()</strong>和<strong>window.onload</strong></p>
<blockquote>
<ul>
<li>window.onload方法是在$(document).ready()网页中所有元素完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素<br>$(document).ready()在DOM完全就绪时就可以被调用，此时，网页中所有元素对jQuery而言都是可以访问的，但是，并不意味着这些元素关联按的文件都已经下载完备</li>
<li>window.onload事件一次只能够保存对一个函数的引用，因此不能在现有的行为上添加新的行为，<br>$(document).ready()会在现有的行为上追加新的行为，会根据注册的顺序依次执行</li>
</ul>
</blockquote>
<p><strong>event.stopPropagation()</strong>:停止事件冒泡<br><strong>event.preventDefault</strong>：阻止元素的默认行为<br><strong>event.type</strong>:获取到事件的类型<br><strong>event.target</strong>:获取到触发事件的元素<br><strong>event.pageX</strong>:获取到光标相对于页面的x坐标和y坐标<br><strong>event.which</strong>:在鼠标单击事件中获取到鼠标的左右中键<br><strong>event.metaKey</strong>:获取<ctrl>按键</ctrl></p>
<p><strong>trigger()</strong>:模拟操作，比如模拟单击按钮来触发click事件，或者触发自定义事件<br><strong>triggerHandler()</strong>触发事件而不是触发默认事件<br><strong>trigger(“click”)</strong>:匹配所有不包含在命名空间中的click方法</p>
<h3 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h3><p><strong>fadeIn()</strong>和<strong>fadeOut()</strong>只改变元素的不透明度，直到元素完全消失<br><strong>slideUp()</strong>和<strong>slideDown()</strong>:只会改变元素的高度，down是由上向下延伸显示，而up是由下到上缩短隐藏</p>
<p><strong>stop()</strong>:第一个参数设置为true，会吧当前元素接下来的动画队列都清空，第二个参数可以用于让正在执行的动画直接到达结束时刻的状态，通常用于后一个动画需要基于前一个动画的末状态的情况<br><strong><code>:animatd</code></strong>:判断元素是否正处于动画状态<br><strong><code>decay()</code></strong>:延迟操作</p>
<h2 id="jQuery对表单、表格的操作及更多应用"><a href="#jQuery对表单、表格的操作及更多应用" class="headerlink" title="jQuery对表单、表格的操作及更多应用"></a>jQuery对表单、表格的操作及更多应用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.focus</span>&#123;</div><div class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#f00</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#fcc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="string">":input"</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="keyword">this</span>).addClass(<span class="string">"focus"</span>);</div><div class="line">    &#125;)</div><div class="line">    .blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="keyword">this</span>).removeClass(<span class="string">"focus"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>keyup</code>事件能在用户每次松开按键时触发，实现即时提醒</p>
<p><code>$(&quot;tr:odd&quot;)</code>和<code>$(&quot;tr:even&quot;)</code>选择器中索引是从0开始的，因为第1行是偶数</p>
<p>load()方法通常用来从Web服务器上获取静态的数据文件</p>
</h3></h2></h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识JQuery&quot;&gt;&lt;a href=&quot;#认识JQuery&quot; class=&quot;headerlink&quot; title=&quot;认识JQuery&quot;&gt;&lt;/a&gt;认识JQuery&lt;/h2&gt;&lt;h3 id=&quot;JQuery和JavaScript的转换&quot;&gt;&lt;a href=&quot;#JQuery和Ja
    
    </summary>
    
      <category term="JQuery学习笔记" scheme="https://caixueyuan.github.io/categories/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JQuery学习笔记" scheme="https://caixueyuan.github.io/tags/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 API</title>
    <link href="https://caixueyuan.github.io/2018/04/02/HTML5-API/"/>
    <id>https://caixueyuan.github.io/2018/04/02/HTML5-API/</id>
    <published>2018-04-02T12:33:51.000Z</published>
    <updated>2018-04-11T08:50:25.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><code>navigator.geolocation.getCurrentPosition()</code>获取用户当前位置<br><code>navigator.geolocation.watchPosition()</code>获取当前位置，同时不断地检视当前位置<br><code>navigator.gerlocation.clearWatch()</code>停止检视用户位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取经纬度</span></div><div class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">pos</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> latitude = pos.coords.latitude;</div><div class="line">    <span class="keyword">var</span> longitude = pos.coords.longitude;</div><div class="line">    alert(<span class="string">"Your position:"</span> + latitude+<span class="string">", "</span>+longitude);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过获取地理位置信息在地图上显示当前位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getmap</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!navigator.geolocation)</div><div class="line">        <span class="keyword">throw</span> <span class="string">"Geolocation not supported"</span>;</div><div class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">    navigator.geolocation.getCurrentPosition(setMapURL);</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMapURL</span>(<span class="params">pos</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> latitude = pos.coords.latitude;</div><div class="line">    <span class="keyword">var</span> longitude = pos.coords.longitude;</div><div class="line">    <span class="keyword">var</span> accuracy = pos.coords.accuracy;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> url = <span class="string">"http://maps.google.com/maps/api/staticmap"</span>+</div><div class="line">        <span class="string">"?center = "</span>+latitude + <span class="string">", "</span>+longitude +<span class="string">"&amp;size = 640*640&amp;sensor=true"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> zoomlevel = <span class="number">20</span>;</div><div class="line">    <span class="keyword">if</span>(accuracy &gt; <span class="number">80</span>)</div><div class="line">        zoomlevel -= <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.log(accuracy/<span class="number">50</span>)/<span class="built_in">Math</span>.LN2);</div><div class="line">        url += <span class="string">"&amp;zoom="</span>+zoomlevel;</div><div class="line"></div><div class="line">        image.src= url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="历史记录管理"><a href="#历史记录管理" class="headerlink" title="历史记录管理"></a>历史记录管理</h2><p><code>location.hash</code>会更新显示在地址栏中的URL，同时会在浏览器的历史记录中添加一条记录。hash属性设置URL的片段标识符，通过是用于指定要滚动到的文档中的某一部分的ID，它可以设置成任何的字符串</p>
<p>支持HTML5的浏览器一旦发现片段标识符发生了改变，就会在Window对象上触发一个hashchange事件，可以通过设置onhashChange为一个处理程序函数</p>
<p>HTML5，该方法包含了history.pushStatus()方法和popstate事件，当一个Web应用进入一个新的状态的时候，会调用history.pushState()方法将该状态添加到浏览器的浏览历史记录中。</p>
<p>还有另外一个方法，history.replaceState()，用新的状态来代替当前的历史状态</p>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>客户端JavaScript都是单线程</p>
<p>Web Workers处在一个自包含的执行环境中，无法访问Window对象和Document对象，和主线程之间的童心也只能通过异步消息传递机制来实现，并行改变DOM是不可能的</p>
<h3 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a>Worker对象</h3><p><code>var loader = new Worker(&quot;utils/loader.js&quot;);</code><br>如果指定的URL采用的是绝对路径，要保证该脚本的文档是同源的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;地理位置&quot;&gt;&lt;a href=&quot;#地理位置&quot; class=&quot;headerlink&quot; title=&quot;地理位置&quot;&gt;&lt;/a&gt;地理位置&lt;/h2&gt;&lt;p&gt;&lt;code&gt;navigator.geolocation.getCurrentPosition()&lt;/code&gt;获取用户当前位
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript多媒体和图形编程</title>
    <link href="https://caixueyuan.github.io/2018/04/02/JavaScript%E5%A4%9A%E5%AA%92%E4%BD%93%E5%92%8C%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    <id>https://caixueyuan.github.io/2018/04/02/JavaScript多媒体和图形编程/</id>
    <published>2018-04-02T08:39:15.000Z</published>
    <updated>2018-04-02T12:33:04.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚本化图片"><a href="#脚本化图片" class="headerlink" title="脚本化图片"></a>脚本化图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">(<span class="keyword">new</span> Image()).src = <span class="string">"images/help_rollover.gif"</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//预加载图片</div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"images/help.gif"</span></span></div><div class="line">    <span class="attr">onmouseover</span> = <span class="string">"this.src = 'images/help_rollover.gif'"</span></div><div class="line">    <span class="attr">onmouseout</span> = <span class="string">"this.src = 'images/help_rollout.gif'"</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="优雅的图片翻转实现方式"><a href="#优雅的图片翻转实现方式" class="headerlink" title="优雅的图片翻转实现方式"></a>优雅的图片翻转实现方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 要创建图片翻转效果，将次此模块引入HTML文件中，然后在任意&lt;img&gt;元素上使用data-rollover属性来指定翻转图片的URL即可</div><div class="line"> */</div><div class="line"></div><div class="line">onLoad(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="built_in">document</span>.images.length; i++)&#123;</div><div class="line">        <span class="keyword">var</span> img = <span class="built_in">document</span>.images[i];</div><div class="line">        <span class="keyword">var</span> rollover = img.getAttribute(<span class="string">"data_rollover"</span>);</div><div class="line">        <span class="keyword">if</span>(!rollover)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        (<span class="keyword">new</span> Image()).src = rollover;</div><div class="line">        img.setAttribute(<span class="string">"data-rollout"</span>,img.src);</div><div class="line">        img.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.src = <span class="keyword">this</span>.getAttribute(<span class="string">"data_rollover"</span>);</div><div class="line">        &#125;;</div><div class="line">        img.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.src = <span class="keyword">this</span>.getAttribute(<span class="string">"data_rollout"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="脚本化音频或者视频"><a href="#脚本化音频或者视频" class="headerlink" title="脚本化音频或者视频"></a>脚本化音频或者视频</h3><p><strong><code>&lt;audio&gt;</code></strong>和<strong><code>&lt;video</code></strong></p>
<blockquote>
<ul>
<li>controls属性：将会显示一系列播放控件</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Audio();</div><div class="line"><span class="keyword">if</span>(a.canPlayType(<span class="string">"audio/wav"</span>))&#123;</div><div class="line">    a.src = <span class="string">"soundeffect.wav"</span>;</div><div class="line">    a.play();</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"music"</span>).play();</div><div class="line">&#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="SVG-可伸缩的矢量图形"><a href="#SVG-可伸缩的矢量图形" class="headerlink" title="SVG:可伸缩的矢量图形"></a>SVG:可伸缩的矢量图形</h3><p>SVG是一种用于描述图形的XML语法<br><figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version = <span class="string">"1.0"</span>&gt;</span></div><div class="line">&lt;html xmlns = <span class="string">"http://www.w3.org/1999/xhtml"</span></div><div class="line">    xmls:svg = <span class="string">"http://www.w3.ogr/2000/svg"</span>&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;svg:svg width = <span class="string">"10"</span> height = <span class="string">"10"</span>&gt;</div><div class="line">        &lt;svg:rec x = <span class="string">"0"</span> y =<span class="string">"0"</span> width = <span class="string">"10"</span> height = <span class="string">"10"</span> fill =<span class="string">"red"</span>/&gt;</div><div class="line">    &lt;/svg:svg&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span> = <span class="string">"10"</span> <span class="attr">height</span> = <span class="string">"10"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span> = <span class="string">"0"</span> <span class="attr">y</span> =<span class="string">"0"</span> <span class="attr">width</span> =<span class="string">"10"</span> <span class="attr">height</span> = <span class="string">"10"</span> <span class="attr">fill</span> =<span class="string">"red"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="中的图形"><a href="#中的图形" class="headerlink" title="中的图形"></a><canvas>中的图形</canvas></h3><p><code>&lt;canvas&gt;</code>元素和SVG之间的一个重要的区别是：使用canvas来绘制图形是通过调用它提供的方法而使用SVG绘制图形是通过构建一个XML元素树来实现的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"my_canvas_id"</span>);</div><div class="line"><span class="keyword">var</span> c = canvas.getContext(<span class="string">"2d"</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>c.beginPath();开始一条新的路径</li>
<li>c.moveTo()开始定义一条新的路径</li>
<li>c.lineTo()绘制一条路径</li>
<li>c.stroke()绘制边</li>
<li>c.fill()填充图形</li>
<li>c.closePath()起点和终点连接</li>
<li>restore()恢复最后一次保存的图形状态</li>
<li>save()保存图形状态</li>
<li>translate()将坐标原点进行上下左右移动</li>
<li>rotate()将坐标轴根据指定角度进行顺时针旋转</li>
<li>scale()实现对X轴和Y轴上的距离进行延长或者缩短</li>
<li>arc()添加圆弧</li>
<li>arcTo()添加圆弧和一条直线</li>
<li>fillRect()使用当前的fillStyle来填充指定的矩阵</li>
<li>strokeRect()使用当前的strokeStyle和其他线段的属性来勾勒指定矩阵的外边框</li>
<li>clearRect()忽略当前填充样式</li>
<li>rect()画矩阵路线</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;脚本化图片&quot;&gt;&lt;a href=&quot;#脚本化图片&quot; class=&quot;headerlink&quot; title=&quot;脚本化图片&quot;&gt;&lt;/a&gt;脚本化图片&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>客户端存储</title>
    <link href="https://caixueyuan.github.io/2018/04/02/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <id>https://caixueyuan.github.io/2018/04/02/客户端存储/</id>
    <published>2018-04-02T07:09:36.000Z</published>
    <updated>2018-04-02T08:36:55.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h2><p>客户端存储遵循“同源策略”，不同站点的页面是无法互相读取对方存储的数据，而同一个站点的不同页面之间是可以互相存储数据的，它为我们提供了一种通信机制。</p>
<p>所有的数据都是以字符串的形式来存储的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">localStorage.x =<span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> x= <span class="built_in">parseInt</span>(localStorage.x);</div><div class="line"></div><div class="line">localStorage.lastRead = (<span class="keyword">new</span> <span class="built_in">Date</span>()).toUTCString();</div><div class="line"><span class="keyword">var</span> lastRead = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(localStorage.lastRead));</div><div class="line"></div><div class="line">localStorage.data = <span class="built_in">JSON</span>.stringify(data);</div><div class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(localStorage.data);</div></pre></td></tr></table></figure></p>
<h3 id="localStorage和sessionStorage"><a href="#localStorage和sessionStorage" class="headerlink" title="localStorage和sessionStorage"></a>localStorage和sessionStorage</h3><blockquote>
<ul>
<li>localStorage:存储的数据是永久的，限定在文档源，同源的文档同享同样的localStorage数据，都是采用广播机制的，浏览器会对目前正在访问同样站点的所有的窗口发送消息</li>
<li>sessionStorage:有效期和存储数据的脚本所在的最顶层的窗口或者浏览器标签页是一样的，一旦窗口被关闭或者标签页被永远关闭，就删除数据，限定在文档源的级别，sessionStorage的改变只有相牵连的窗口的时候才会触发存储时间</li>
</ul>
</blockquote>
<p><strong>Cookie</strong><br>在JavaScript中，cookie用于保存状态以及能够为Web浏览器提供一种身份识别机制</p>
<blockquote>
<ul>
<li>检测Cookie是否启用：<code>navigator.cookieEnabled</code></li>
<li>Cookie属性：只能够持续到Web浏览器的会话期间，一旦用户关闭浏览器，Cookie保存的数据就会丢失Cookie的作用期并不是局限在浏览器的单个窗口，它的有效期和整个浏览器进程而不是单个浏览器窗口（sessionStorage）</li>
<li>JavaScript核心的全局函数encodeURIComponent()对值进行编码，读取cookie值的时候需要采用decodeURIComponent()函数解码</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> cookie = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> all = <span class="built_in">document</span>.cookie;</div><div class="line">    <span class="keyword">if</span>(all === <span class="string">''</span>)</div><div class="line">        <span class="keyword">return</span> cookie;</div><div class="line">    <span class="keyword">var</span> list = all.split(<span class="string">"; "</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;list.length;i++)&#123;</div><div class="line">        <span class="keyword">var</span> cookie = list[i];</div><div class="line">        <span class="keyword">var</span> p = cookie.indexOf(<span class="string">"="</span>);</div><div class="line">        <span class="keyword">var</span> p = cookie.substring(<span class="number">0</span>,p):</div><div class="line">        <span class="keyword">var</span> value = cookie.substring(p+<span class="number">1</span>);</div><div class="line">        value = <span class="built_in">decodeURIComponent</span>(value);</div><div class="line">        cookie[name] = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cookie;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;客户端存储&quot;&gt;&lt;a href=&quot;#客户端存储&quot; class=&quot;headerlink&quot; title=&quot;客户端存储&quot;&gt;&lt;/a&gt;客户端存储&lt;/h2&gt;&lt;p&gt;客户端存储遵循“同源策略”，不同站点的页面是无法互相读取对方存储的数据，而同一个站点的不同页面之间是可以互相存储数据
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>客户端JavaScript</title>
    <link href="https://caixueyuan.github.io/2018/03/27/%E5%AE%A2%E6%88%B7%E7%AB%AFJavaScript/"/>
    <id>https://caixueyuan.github.io/2018/03/27/客户端JavaScript/</id>
    <published>2018-03-27T12:29:49.000Z</published>
    <updated>2018-04-02T07:06:51.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web浏览器中的JavaScript"><a href="#web浏览器中的JavaScript" class="headerlink" title="web浏览器中的JavaScript"></a>web浏览器中的JavaScript</h2><h3 id="在HTML中嵌入JavaScript"><a href="#在HTML中嵌入JavaScript" class="headerlink" title="在HTML中嵌入JavaScript"></a>在HTML中嵌入JavaScript</h3><p>如果使用XHTML，最好把所有的JavaScript代码放入到一个CDATA部分里<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">&lt;![CDATA[</span></span></div><div class="line">    //这里是你的JavaScript代码</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="同步、异步和延迟的脚本"><a href="#同步、异步和延迟的脚本" class="headerlink" title="同步、异步和延迟的脚本"></a>同步、异步和延迟的脚本</h3><blockquote>
<ul>
<li>脚本的执行只在默认情况下是同步和阻塞的</li>
<li>defer和async属性都像是在告诉浏览器链接近来的脚本不会使用document.write()，也不会生成文档内容，因此浏览器可以在下载脚本时候继续解析和渲染文档</li>
<li>defer 使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作</li>
<li>async属性使得浏览器可以尽快地执行脚本，不用在下载脚本时阻塞文档解析<br><strong>异步载入并执行一个指定URL中的脚本</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadasync</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    s.src = url;</div><div class="line">    head.appendChild(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="客户端JavaScript线程模型"><a href="#客户端JavaScript线程模型" class="headerlink" title="客户端JavaScript线程模型"></a>客户端JavaScript线程模型</h3><p><strong>JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制，所有JavaScript中的执行都是单线程</strong></p>
<blockquote>
<p>HTML5定义了一个并发的控制方式，叫做”Web worker”.Web worker是一个用来自计算密集任务而不冻结用户界面的后台线程。运行在Web Worker线程中的代码不能够访问文档内容，不能和主线程或其他worker共享状态，只可以和主线程和其他worker通过异步事件进行通信，所以主线程不能够检测并发性。</p>
</blockquote>
<p><strong>客户端JavaScript时间线</strong></p>
<blockquote>
<ul>
<li>Web浏览器创建Document对象，并开始解析Web页面，解析HTML元素和它的文本内容后添加Element对象和Text对象节点到文档中。document.readystate = loading;</li>
<li>当HTML解析器遇到没有async和defer属性的<code>&lt;script&gt;</code>元素时，把这些元素添加到文档中，然后执行内或者外部脚本。这些脚本就可以用document.write()来把文本插入到输入流中。解析器恢复时这些文本会成为文档中的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但她们可以遍历和操作文档树，</li>
<li>当解析器遇见设置async属性的<code>&lt;script&gt;</code>元素时，开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但解析器没有停下来等他下载，异步脚本禁止使用document.write()方法。他们可以看到自己的<code>&lt;script&gt;</code>元素和之前所有的文档元素，并且可能或干脆不可能访问其他的内容</li>
<li>当文档完成解析，document.readystate = interactive;</li>
<li>所有有defer属性的脚本，会按它们在文档出现的顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用document.write()方法</li>
<li>浏览器在Document对象上触发DOMContentLoaded事件。这标志着程序执行从同步脚本执行阶段转换到异步事件驱动阶段。</li>
<li>文档解析完成，但是浏览器可能还在等待其他内容载入，当所有这些内容完成载入，并且所有异步脚本完成载入和执行，document.readystate = complete，Web浏览器触发Window对象上的load对象</li>
<li>调用异步事件</li>
</ul>
</blockquote>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>文档的来源包含协议、主机以及载入文档的URL端口。从不同Web服务器载入的文档具有不同的来源，通过同一个主机的不同端口载入的文档具有不同的来源。</p>
<h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p><code>setTimeout()</code>实现一个函数在指定的毫秒数之后再行<br><code>setInterval()</code>会在指定毫秒数的间隔里重复调用</p>
<h3 id="浏览器定位和导航"><a href="#浏览器定位和导航" class="headerlink" title="浏览器定位和导航"></a>浏览器定位和导航</h3><p><code>window.location === document.location&#39;总是返回true</code>location.assign()<code>使得窗口载入并显示你指定的URL中的文档</code>location.replace()<code>在载入新文档之前会从浏览历史中把当前文档删除</code>location.reload()`让浏览器重新载入当前文档</p>
<h3 id="浏览历史"><a href="#浏览历史" class="headerlink" title="浏览历史"></a>浏览历史</h3><p>History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示的，History对象的<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">history.go<span class="comment">(-2)</span><span class="comment">//后退两个历史记录，相当于单击‘后退’按钮两次</span></div></pre></td></tr></table></figure></p>
<h3 id="浏览器和屏幕信息"><a href="#浏览器和屏幕信息" class="headerlink" title="浏览器和屏幕信息"></a>浏览器和屏幕信息</h3><p>Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象<br>Window对象的screen属性提供有关窗口显示的大小和可用的颜色数量的信息。</p>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p><code>alert()</code>向用户显示一条消息并等待用户关闭对话框<br><code>confirm()</code>显示一条消息，要求用户单击“确定”或“取消”按钮，并返回一个布尔值<br><code>prompt()</code>显示一条消息，等待用户输入字符串，并返回那个字符串<br><code>showModalDialog()</code>显示一个包含HTML格式的“模式对话框”，可以给它传入参数，以及从对话框里返回值</p>
<h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><p>一个Web浏览器窗口可能在桌面上包含多个标签页，每一个标签页都是独立的“浏览器上下文”，每一个上下文都有独立的Window对象，而且相互之间不干扰。每一个上下文都有一个独立的Window对象。例如<iframe></iframe></p>
<p><code>window.open()</code>载入指定的URL到新的或者已存在的窗口中，并返回代表那个窗口的Window对象<br>window.open(网址，窗口的名字，大小和各种属性，boolean);<br>boolean:<code>true</code>声明了由第一个参数指定的URL是应用替换掉窗口浏览实例的当前条目<br><code>false</code>在窗口浏览历史中创建一个新的条目，后者是默认的啊</p>
<p><strong>Window.open()</strong>:只有当用户手动单击按钮或者链接的时候才会调用。JavaScript代码尝试在浏览器初次载入时开启一个弹出窗口，通常会被禁止。</p>
<p>只有在嵌套的窗口才能够相互引用，parent和top属性允许脚本引用它的窗体的祖先。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(<span class="string">"f1"</span>);</div><div class="line"><span class="keyword">var</span> win = elt.contentWindow;</div><div class="line">win.frameElement === elt;<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>每个Window对象都有一个frames属性，它引用自身包含的窗口或者窗体的子窗体。frames属性引用的是类数组对象</p>
<p>JavaScript保证交互窗口的信息交流：</p>
<blockquote>
<ul>
<li>可以通过parent,top来引用窗口的全局变量</li>
<li>内置类都会在所有的窗口中自行预定义，每个Window都有自己的原型对象，意味着instanceof操作符不能够跨窗口工作</li>
</ul>
</blockquote>
<h2 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h2><h3 id="选取文档元素"><a href="#选取文档元素" class="headerlink" title="选取文档元素"></a>选取文档元素</h3><p><code>document.getElementById(&#39;section1&#39;);</code>选取一个基于唯一ID的元素<br><code>document.getElementsByName(&#39;section1&#39;)</code>查找命名的元素<br><code>document.getElementsByTagName(&quot;span&quot;);</code>从文档中获取所有<span>元素的只读的类数组对象，不区分大小写<br><code>document.getElementsByClassName()</code>基于其class属性值中的标识符来选取成组成的文档元素<br><code>document.all[]</code>表示所有文档中的元素</span></p>
<h3 id="文档结构和遍历"><a href="#文档结构和遍历" class="headerlink" title="文档结构和遍历"></a>文档结构和遍历</h3><p><strong>parentNode</strong>:父节点<br><strong>childNodes</strong>：只读的类数组对象<br><strong>nextSubling</strong>,<strong>previousSubling</strong>:兄弟节点的前后一个啊<br><strong>nodeType</strong>:该节点的类型<br><strong>nodeValue</strong>:Text节点或者Comment节点的文本内容<br><strong>nodeName</strong>:元素的标签名</p>
<p><strong>firstElementChild</strong>,<strong>lastElementChild*:代表子Element
</strong>nextElementSibling<strong>,</strong>previousElementSubling<strong>：兄弟Element
</strong>childElementCount**:子元素的数量</p>
<p><strong>HTMLElement</strong>：定义了通用的HTTP属性（如id，标题lang和dir）的属性，以及事件处理程序属性<br><strong>element.getAttribute(“WIDTH”)</strong>:查询和设置非标准的HTML属性<br><strong>hasAttribute()</strong>,<strong>removeAttribute()</strong>:检测命名属性是否存在和完全删除属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span> = <span class="string">"sparkline"</span> <span class="attr">data-ymin</span> = <span class="string">"0"</span> <span class="attr">data-ymax</span> = <span class="string">"10"</span>&gt;</span></div><div class="line">1 2 4 4 5    3 3  2 </div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sparklines = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"sparkline"</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt; sparklines.length; i++)&#123;</div><div class="line">    <span class="keyword">var</span> dataset = sparklines[i].dataset;</div><div class="line">    <span class="keyword">var</span> ymin = <span class="built_in">parseFloat</span>(dataset.ymin);</div><div class="line">    <span class="keyword">var</span> ymax = <span class="built_in">parseFloat</span>(dataset.ymax);</div><div class="line">    <span class="keyword">var</span> data = sparklines[i].textContent.split(<span class="string">""</span>).map(<span class="built_in">parseFloat</span>);</div><div class="line">    drawSparkline(sparklines[i],ymin,ymax,data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>element.attributes</strong>:代表元素的所有属性</p>
<h3 id="元素的内容"><a href="#元素的内容" class="headerlink" title="元素的内容"></a>元素的内容</h3><p><strong>element.innerHTML</strong>:作为字符串标记返回那些元素的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> text = para.textContent;</div><div class="line">para.textContent = <span class="string">"HEllOWORLD"</span>;</div></pre></td></tr></table></figure></p>
<p><strong>textContent</strong>:需要查询纯文本形式的元素内容，或者在文档中插入纯文本<br><strong>HTML文档来说改名字不区分大小写，对于XML文档则区分大小写</strong></p>
<p><strong>创建节点</strong>:<code>var newNode = document.createTextNode(&quot;text node content&quot;);</code></p>
<p><strong>插入节点</strong>:<code>parent.insertBefore(待插入的节点，插入的位置的节点)</code></p>
<p><strong>删除和替换节点</strong>：<code>parentNode.removeChild(childNode)</code>,<code>parentNode.replaceChild(独立的节点，要替换的节点)</code></p>
<p><strong>DocumentFragment</strong>:将一组节点当做一个节点来看待，如果使用appendChild(),insertBefore()是将一组节点进行操作</p>
<h3 id="文档和元素的几何状态和滚动"><a href="#文档和元素的几何状态和滚动" class="headerlink" title="文档和元素的几何状态和滚动"></a>文档和元素的几何状态和滚动</h3><p>在用浏览器打开一个网页的这个情况下，视口坐标就是指浏览器窗口的坐标，而文档坐标就是我们网页的坐标。在页面没有滚动的情况下，这两个坐标的原点是重合的，也就是二者的左上角（0， 0）重合，然后这两个坐标系的X轴和Y轴分别朝右和朝下延伸。</p>
<blockquote>
<p>文档坐标系坐标 ＝ 视口坐标系坐标 ＋ 滚动条的偏移量</p>
</blockquote>
<p><strong>document.documentElement.scrollLeft</strong>:视口的左上角的x坐标<br><strong>document.documentElement.scrollTop</strong>:视口的左上角的y坐标<br><strong>document.documentElement.clientWidth</strong>:窗口的位置<br><strong>document.documentElement.clientHeight</strong>:窗口的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> box = e.getBoundingClientRect();</div><div class="line"><span class="keyword">var</span> offsets = getScrollOffsets();</div><div class="line"><span class="keyword">var</span> x = box.left + offsets.x;</div><div class="line"><span class="keyword">var</span> y = box.top + offsets.y;</div></pre></td></tr></table></figure>
<p><code>e.getBoundingClientRect()</code>中，left和top属性表示元素的左上角的X和Y坐标，right和bottom属性表示元素的右下角的X和Y坐标<br><code>document.elementFromPoint()</code>传递X和Y坐标，返回在指定位置的一个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得文档和视口的高度，offsetHeight会在下面解释</span></div><div class="line"><span class="keyword">var</span> documentHeight = <span class="built_in">document</span>.documentElement.offsetHeight;</div><div class="line"><span class="keyword">var</span> viewportHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line"><span class="comment">//滚动让最后一页在视口可见</span></div><div class="line"><span class="built_in">window</span>.scroll(<span class="number">0</span>,documentHeight - viewportHeight)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每200毫秒向下滚动10像素，注意，无法关闭</span></div><div class="line">javascript:<span class="keyword">void</span> setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;scrollBy(<span class="number">0</span>,<span class="number">10</span>)&#125;,<span class="number">200</span>);</div></pre></td></tr></table></figure>
<p><code>getBoundingClientRect()</code>计算元素的位置，并转换为文档坐标，通过<code>scrollTo()</code>方法达到目的<br><code>scrollIntoView()</code>保证了元素能在视口中可见，默认情况下，它试图将元素的上边缘放在或者尽量接近视口的上边缘，如果只传递false作为参数，它将试图将元素的下边缘放在接近视口的下边缘</p>
<h3 id="其他文档特性"><a href="#其他文档特性" class="headerlink" title="其他文档特性"></a>其他文档特性</h3><p><code>document.referrer</code>如果有，它表示浏览器导航到当前链接的上一个文档</p>
<p><strong>判定用户在文档中选取了哪些文本</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.getSelection)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.getSelection().toString();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.selection)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.selection.createRange().text;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>可编辑的内容</strong>:嵌入一个富文本编辑器，包含了一个有一系列按钮的工具栏来设置排版样式<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"editor"</span> <span class="attr">contenteditable</span>&gt;</span></div><div class="line">    Click to edit</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h2><h3 id="CSS概览"><a href="#CSS概览" class="headerlink" title="CSS概览"></a>CSS概览</h3><p>border、margin和padding属性是为元素的每个边都设置边框、外边框和内边框的复合属性<br>border-left,border-right,border-top,border-bottom属性用来设置边框的每条边</p>
<blockquote>
<p>根据浏览器的类型选择不同的style<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.radius10</span>&#123;</div><div class="line">    <span class="attribute">border-radius </span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">-moz-border-radius </span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">-webkit-border-radius </span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="重要CSS元素"><a href="#重要CSS元素" class="headerlink" title="重要CSS元素"></a>重要CSS元素</h3><blockquote>
<ul>
<li>z-index属性定义了第三个维度，它允许指定元素的堆叠次序，并指示两个或者多个重叠中的哪一个应该绘制到其他的上面</li>
<li>test-shadow属性在沈本下产生阴影效果，可以将z-index 属性设置为负数以确保阴影在其文本的下面</li>
<li>CSS允许指定元素周围的边框、外边框和内边框。border:solid black 1px;</li>
<li>margin指定边框外面——边框和相邻元素之间的空间，padding指定边框之内——边框和元素内容之间的空间</li>
<li>CSS盒模型，box-sizing<div style="box-sizing:border-box;width:50%;padding:10px,border:solid black 2px;"></div></li>
<li>visibility，display设置元素可不可见</li>
<li>background-color指定任何元素的背景颜色</li>
<li>opacity:该属性是0~1之间的数字，1代表100%不透明，0代表0%不透明</li>
<li>overflow属性允许指定当内容超出元素边框时该如何显示</li>
<li>clip:指定了应该显示元素的哪个部分<code>style=&quot;clip: rect(0px 100px 100px 0px)</code></li>
<li>.fadeable{transition:opacity .5s ease-in}指定在任何时刻”fadeable”元素的opacity属性会变化，该变化会在半秒内用非线性缓动函数的动画来过渡</li>
<li>getComputedStyle()方法来获得一个元素的计算样式<br><strong>visibility</strong>,<strong>display</strong>:<br>visibility属性设置为visible时，元素显示；设置为hidden时，元素不显示。<br>display属性设置为none，受影响的元素将不显示<br>区别：使用visibility设置为hidden时，在文档布局中仍保留了它的空间，而display设置为none，在文档布局中不再分配空间</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两者都可以设置e的样式属性为字符串s</span></div><div class="line">e.setAttribute(<span class="string">"style"</span>,s);</div><div class="line">e.style.cssText = s;</div><div class="line"></div><div class="line"><span class="comment">//两者都可以查询元素的内联样式</span></div><div class="line">s = e.getAttribute(<span class="string">"style"</span>);</div><div class="line">s = e.style.cssText;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得一个元素的计算样式</span></div><div class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.getElementById(<span class="string">"section1title"</span>);</div><div class="line"><span class="keyword">var</span> titlestyle = <span class="built_in">window</span>.getComputedStyle(element,<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="注册事件处理程序"><a href="#注册事件处理程序" class="headerlink" title="注册事件处理程序"></a>注册事件处理程序</h3><blockquote>
<ul>
<li>注册事件处理程序最简单的方式就是通过设置事件目标的属性为所需事件处理程序函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> elt = <span class="built_in">document</span>.getElementById(<span class="string">"shipping_address"</span>);</div><div class="line">    elt.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> validate(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>缺点：其设计都是围绕着假设每个事件目标对于每种事件类型最多只有一个处理程序</p>
<blockquote>
<ul>
<li>设置HTML标签属性为事件处理程序<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span> = <span class="string">"alert("</span><span class="attr">Thank</span> <span class="attr">you</span>");"&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>缺点：属性直接混合了JavaScript和HTML</p>
<blockquote>
<ul>
<li>addEventListener()<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span> = <span class="string">"My button"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"My button"</span>);</div><div class="line">    b.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Thanks for clicking me!"</span>);</div><div class="line">    &#125;;</div><div class="line">    b.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">"Thanks again!"</span>);&#125;,<span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>重复给该元素注册事件时，会根据注册事件的顺序触发事件的执行</p>
<h3 id="事件处理程序的调用"><a href="#事件处理程序的调用" class="headerlink" title="事件处理程序的调用"></a>事件处理程序的调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">target,type,handler</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(target.addEventListener)</div><div class="line">        target.addEventListener(type,handle,<span class="literal">false</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        target.attachEvent(<span class="string">"on"</span>+type,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> handler.call(target,event);</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用顺序：</p>
<blockquote>
<ul>
<li>通过设置对象属性或者HTML属性注册的处理程序一直优先调用</li>
<li>使用addEventListener()注册的处理程序按照他们的注册顺序调用</li>
<li>使用attachEvent()注册的处理程序可能按照任何顺序调用</li>
</ul>
</blockquote>
<h3 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h3><p><strong>事件对象以数字Unicode编码的形式指定字符，所以必须用String.fromCharCode()把它转换为字符串</strong></p>
<h2 id="脚本化HTTP"><a href="#脚本化HTTP" class="headerlink" title="脚本化HTTP"></a>脚本化HTTP</h2><p>在Ajax中，客户端从服务端“拉“数据，而在Comet中，服务端从客户端”推“数据</p>
<h3 id="使用XMLHttpRequest"><a href="#使用XMLHttpRequest" class="headerlink" title="使用XMLHttpRequest"></a>使用XMLHttpRequest</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">request.open(<span class="string">"GET"</span>,<span class="string">'data.csv'</span>);<span class="comment">//开始一个请求，请求的内容</span></div><div class="line">request.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain"</span>);<span class="comment">//设置请求的头部</span></div><div class="line">request.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用POST方法发送纯文本给服务器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">postMessage</span>(<span class="params">msg</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.open(<span class="string">"POST"</span>,<span class="string">"/log.php"</span>);</div><div class="line">    request.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain;charset=UTF-8"</span>);</div><div class="line">    request.send(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getText</span>(<span class="params">url,callback</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.open(<span class="string">"GET"</span>,url);</div><div class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(request.readyState === <span class="number">4</span> &amp;&amp; request.status === <span class="number">200</span>)&#123;</div><div class="line">            <span class="keyword">var</span> type = request.getResponseHeader(<span class="string">"Content-Type"</span>);</div><div class="line">            <span class="keyword">if</span>(type.match(<span class="regexp">/^text/</span>))</div><div class="line">            callback(request.responseText);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    request.send(<span class="literal">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>JSON编码的请求</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">postJSON</span>(<span class="params">url,data,callback</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.open(<span class="string">"POST"</span>,url);</div><div class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(request.readyStatus === <span class="number">4</span> &amp;&amp; callback)</div><div class="line">            callback(request);</div><div class="line">    &#125;;</div><div class="line">    request.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/json"</span>);</div><div class="line">    request.send(<span class="built_in">JSON</span>.stringify(data));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>上传文件</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">postFormData</span>(<span class="params">url,data,callback</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> FormData === <span class="string">'undefined'</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"FormData is not implemented"</span>);</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(request.readyStatus === <span class="number">4</span> &amp;&amp; callback)</div><div class="line">            callback(request);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name is data)&#123;</div><div class="line">        <span class="keyword">if</span>(!data.hasOwnProperty(name))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">var</span> value = data[name];</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">'function'</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        formdata.append(name,value);</div><div class="line">    &#125;</div><div class="line">    request.send(formdata);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基于服务器端推送事件的Comet技术"><a href="#基于服务器端推送事件的Comet技术" class="headerlink" title="基于服务器端推送事件的Comet技术"></a>基于服务器端推送事件的Comet技术</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> nick = prompt(<span class="string">"Enter your name"</span>);</div><div class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</div><div class="line">    input.focus();</div><div class="line"></div><div class="line">    <span class="comment">//通过EventSource注册新消息的通知</span></div><div class="line">    <span class="keyword">var</span> char = <span class="keyword">new</span> EventSource(<span class="string">"/chat"</span>);</div><div class="line">    <span class="comment">//onmessage事件处理程序接受从一个特定的服务器事件源发出的所有事件</span></div><div class="line">    chat.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> msg = event.data;</div><div class="line">        <span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(msg);</div><div class="line">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">        div.appendChild(node);</div><div class="line">        <span class="built_in">document</span>.body.insertBefore(div,input);</div><div class="line">        input.scrollIntoView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//使用XMLHttpRequest把用户的消息发送给服务器</span></div><div class="line">    input.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> msg = nick + <span class="string">": "</span> + input.value;</div><div class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        xhr.open(<span class="string">"POST"</span>,<span class="string">"/chat"</span>);</div><div class="line">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/plain;charset = UTF-8"</span>);</div><div class="line">        xhr.send(msg);</div><div class="line">        input.value =<span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="JQuery类库"><a href="#JQuery类库" class="headerlink" title="JQuery类库"></a>JQuery类库</h2><h3 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h3><p>JQuery()是工厂函数，不是构造函数，它返回一个新创建的对象，但并没有和new关键字一起使用</p>
<p><strong>JQuery函数</strong>和<strong>JQuery方法</strong></p>
<blockquote>
<ul>
<li>$.each(a,f);使用JQuery函数（静态方法），对数组a中的每一个元素都调用一次函数f</li>
<li>$(“a”).each(f);使用JQuery方法（实例方法）</li>
</ul>
</blockquote>
<h3 id="JQuery的getter和setter"><a href="#JQuery的getter和setter" class="headerlink" title="JQuery的getter和setter"></a>JQuery的getter和setter</h3><p>JQuery使用同一个方法既当getter用又可以做setter用</p>
<blockquote>
<ul>
<li><code>attr()</code>方法是JQuery用于HTML属性的getter/setter</li>
<li><code>css()</code>方法返是元素的当前样式的getter/setter</li>
<li><code>addClass()</code> <code>removeClass()</code> <code>toggleClass()</code> 当元素还没有某些类时，给用户添加这些类 <code>hasClass()</code> </li>
<li><code>val()</code>用来设置和获取HTML表单元素的value属性，复选框、单选框以及<select>元素的选中状态</select></li>
<li><code>text()</code> 和 <code>html()</code> 用来获取和设置元素的纯文本或HTML内容</li>
<li><code>offset()</code>获取或设置元素的绝对位置，用相对于文档的坐标来表示，而 <code>position()</code>则返回相对于元素的<code>offsetParent()</code>的偏移量</li>
<li><code>data()</code> 和 <code>removeData()</code>可以设置和删除data </li>
<li>clone()复制文档的一部分，不会复制事件处理程序和与元素关联的其他数据，如果想要复制这些额外的数据的话，请传入true参数</li>
<li><code>wrap()</code>包装每一个选中的元素， ‘wrapInner()<code>包装每一个选中元素的内容</code>wrapAll()`将选中元素作为一组来包装</li>
<li><code>remove()</code> 会移除所有事件处理程序以及可能绑定到被移除元素上的其他数据</li>
<li><code>detach()</code>不会移除事件处理程序和数据</li>
<li><code>unwrap()</code>对于每一个选中元素，它替换该元素的父节点为父节点的子节点</li>
</ul>
</blockquote>
<p><strong>区别</strong></p>
<blockquote>
<ul>
<li>width() 和 height() 方法返回基本的宽度和高度，不包含内边距、边框和外边距</li>
<li>innerWidth() 和 innerHeight() 返回元素的宽度和高度，但是包含内边距的宽度和高度</li>
<li>outerWidth() 和 outerHeight() 通常返回的是包含元素内边距和边框的尺寸</li>
</ul>
</blockquote>
<h3 id="JQuery处理事件"><a href="#JQuery处理事件" class="headerlink" title="JQuery处理事件"></a>JQuery处理事件</h3><blockquote>
<p>jQuery的事件触发方法会触发所有使用jQuery事件注册方法注册的处理程序，也会触发通过onsubmit等HTML属性或者Element属性定义的处理程序<br>JQuery的事件触发机制是同步的</p>
</blockquote>
<p><strong>手动触发事件</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#my_form"</span>).submit();<span class="comment">//跟用户单击提交按钮一样</span></div><div class="line">$(<span class="string">"my_form"</span>).trigger(<span class="string">"submit"</span>);<span class="comment">//跟用户单击提交按钮一样</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//button1的单击处理程序触发button2上的相同事件</span></div><div class="line">$(<span class="string">"#button1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    $(<span class="string">"button2"</span>).trigger(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>自定义事件</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#logoff"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $.event.trigger(<span class="string">"logoff"</span>);<span class="comment">//广播一个事件</span></div><div class="line">    <span class="built_in">window</span>.location = <span class="string">"logoff.php"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>实时事件</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).delegate(<span class="string">"a"</span>,<span class="string">"mouseover"</span>,linkHandler);</div></pre></td></tr></table></figure></p>
<p>在要使用实时事件的时候使用，可以动态的对所有的链接添加上实时事件</p>
<h3 id="JQuery动画"><a href="#JQuery动画" class="headerlink" title="JQuery动画"></a>JQuery动画</h3><blockquote>
<ul>
<li>fadeIn()显示，fadeOut()隐藏，fadeTo()将元素的当前的opacity值变成目标值</li>
<li>show() == toggle(true), hide() == toggle(false)</li>
<li>slideDown()使得隐藏的元素再次可见，slideUp()隐藏JQuery对象的元素，将高度变为0</li>
</ul>
</blockquote>
<p><strong>自定义动画</strong></p>
<hr>
<p><code>animate()</code>方法的第一个参数必须是对象，该对象的属性必须是CSS属性名<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"img"</span>).animate(&#123;</div><div class="line">    <span class="attr">width</span>:<span class="string">"hide"</span>,</div><div class="line">    <span class="attr">borderLeft</span>:<span class="string">"hide"</span>,</div><div class="line">    <span class="attr">borderRight</span>:<span class="string">"hide"</span>,</div><div class="line">    <span class="attr">paddingLeft</span>:<span class="string">"hide"</span>,</div><div class="line">    <span class="attr">paddingRight</span>:<span class="string">"hide"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>第二个参数是可选的，该选项对象用来指定动画如何执行。在回调函数中，this指向正在连续变化的元素，第一个参数则是正在变化的属性的当前值</p>
<blockquote>
<ul>
<li>duration属性指定动画持续的毫秒时间</li>
<li>complete:指明在动画完成时的回调函数</li>
<li>step:指定在动画每一步或每一帧调用的回调函数</li>
<li>queue：指定动画是否需要队列化，是否需要等到所有尚未发生的动画都完成后再执行该动画</li>
<li>easing:指定缓动函数名</li>
</ul>
</blockquote>
<hr>
<p><strong>动画的取消、延迟和队列</strong></p>
<blockquote>
<ul>
<li>top()用来停止选中元素中的当前正在执行的任何动画</li>
<li>top()接受两个可选的布尔值参数，第一个参数为true，会清除该选中元素中的动画队列：除了停止当前动画，还会取消任何等待执行的动画<br>第二个参数用来指定正在连续变化的CSS属性是否保留当前值，还是应该变化到最终目标值（true)</li>
<li>delay()延迟</li>
</ul>
</blockquote>
<h3 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setInternal(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)<span class="title">$</span>(<span class="params"><span class="string">'#status'</span></span>).<span class="title">load</span>(<span class="params"><span class="string">'status_report.html'</span></span>);&#125;,60000);</span></div><div class="line"><span class="title">$</span>(<span class="params"><span class="string">"temp"</span></span>).<span class="title">load</span>(<span class="params"><span class="string">"whether_report.html #temperature"</span></span>);</div><div class="line"><span class="title">$</span>(<span class="params"><span class="string">'temp'</span></span>).<span class="title">load</span>(<span class="params"><span class="string">'us_whether_report.html'</span>,<span class="string">"zipcode=02134"</span></span>);</div></pre></td></tr></table></figure>
<p><strong>Ajax工具函数</strong><br><strong>jQuery.getScript</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery.getScript(<span class="string">"https://example.com/js/widget.js"</span>);<span class="comment">//异步加载文件，加载完成后在全局作用域执行该代码</span></div><div class="line">jQuery.getScript(<span class="string">"js/jquery.my_plugin.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="string">"div"</span>).my_plugin();<span class="comment">//加载一个类库，并在加载完成时立即使用它</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>jQuery.getJSON()</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#submit_button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>))</span>&#123;</div><div class="line">    $(<span class="keyword">this</span>.form).load(<span class="comment">//通过加载新内容来替换表单</span></div><div class="line">        <span class="keyword">this</span>.form.action,<span class="comment">//表单url</span></div><div class="line">        $(<span class="keyword">this</span>.form).serialize());<span class="comment">//将表单数据附加到表单URL后面</span></div><div class="line">    event.preventDefault();</div><div class="line">    <span class="keyword">this</span>.disabled = <span class="string">'disabled'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">jQuery.getJSON(<span class="string">"data.json"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line"><span class="comment">//data也就是data.json里面的数据</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>jQuery.get()</strong>和<strong>jQuery.post()</strong><br>jQuery.get(必须的URL,可选的数据字符串或者对象,一个技术上可选但实际上总会使用的回调函数)<br>回调函数传入三个参数，第一个是返回的数据，第二个是“success”字符串，第三个是XMLHTTPRequest对象</p>
<p><strong>jQuery.ajax()</strong><br>只接受一个参数：一个选项对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax(&#123;</div><div class="line">    <span class="attr">type</span>:<span class="string">"GET"</span>,</div><div class="line">    <span class="attr">url</span>:url,</div><div class="line">    <span class="attr">data</span>:<span class="literal">null</span>,</div><div class="line">    <span class="attr">dataType</span>:<span class="string">"script"</span>,</div><div class="line">    <span class="attr">success</span>:callback</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来显示和隐藏，某些"加载中"动画或网络活动的图标</span></div><div class="line">$(<span class="string">"#loading_animation"</span>).bind(&#123;</div><div class="line">    <span class="attr">ajaxStart</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;$(<span class="keyword">this</span>).show();&#125;,</div><div class="line">    <span class="attr">ajaxStop</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;$(<span class="keyword">this</span>).hide();&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;web浏览器中的JavaScript&quot;&gt;&lt;a href=&quot;#web浏览器中的JavaScript&quot; class=&quot;headerlink&quot; title=&quot;web浏览器中的JavaScript&quot;&gt;&lt;/a&gt;web浏览器中的JavaScript&lt;/h2&gt;&lt;h3 id=&quot;在
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三）</title>
    <link href="https://caixueyuan.github.io/2018/03/26/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://caixueyuan.github.io/2018/03/26/JavaScript学习笔记（三）/</id>
    <published>2018-03-26T06:51:12.000Z</published>
    <updated>2018-03-29T06:31:31.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和模块"><a href="#类和模块" class="headerlink" title="类和模块"></a>类和模块</h2><p><code>r instanceof Range</code>:当使用instanceof运算符来检测对象是否属于某个类的时候，并不是检查r是否由Range()构造函数初始化来的，而会检查r是否继承自Range.prototype.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Complex</span>(<span class="params">real, imaginary</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(real) || <span class="built_in">isNaN</span>(imaginary)) </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();           </div><div class="line">    <span class="keyword">this</span>.r = real;                       </div><div class="line">    <span class="keyword">this</span>.i = imaginary;      <span class="comment">//实例变量            </span></div><div class="line">&#125;</div><div class="line"><span class="comment">//实例方法</span></div><div class="line">Complex.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">that</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="keyword">this</span>.r + that.r, <span class="keyword">this</span>.i + that.i);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//不可变类字段</span></div><div class="line">Complex.I = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">1</span>);</div><div class="line"><span class="comment">//类方法</span></div><div class="line">Complex.parse = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;         </div><div class="line">        <span class="keyword">var</span> m = Complex._format.exec(s); </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(<span class="built_in">parseFloat</span>(m[<span class="number">1</span>]), <span class="built_in">parseFloat</span>(m[<span class="number">2</span>]));</div><div class="line">    &#125; <span class="keyword">catch</span> (x) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Can't parse '"</span> + s + <span class="string">"' as a complex number."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//不可见类字段</span></div><div class="line">Complex._format = <span class="regexp">/^\&#123;([^,]+),([^&#125;]+)\&#125;$/</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>JavaScript 中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生变化，继承这个原型的所有实例对象也会发生变化</p>
</blockquote>
<p><strong>构造函数是类的公共标识，但原型是唯一的标识</strong></p>
<p><strong>内置类的方法都是不可枚举的，for/in循环无法遍历到他们，可以使用Object.getOwnPropertyNames()</strong></p>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B.prototype = inherit(A.prototype);</div><div class="line">B.prototype.constructor = B;</div></pre></td></tr></table></figure>
<p>如果不这样做，原型对象仅仅是一个普通对象，它只继承自Object.prototype，这意味着你的类和所有的类一样是Object的子类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filteredSetSubclass</span>(<span class="params">superclass,filter</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = function()&#123;</div><div class="line">        superclass.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;;</div><div class="line">    <span class="keyword">var</span> proto = <span class="keyword">constructor</span>.prototype = inherit(superclass.prototype);</div><div class="line">    proto.<span class="keyword">constructor</span> = <span class="keyword">constructor</span>;</div><div class="line">    proto.add = function()&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt; <span class="built_in">arguments</span>.length; i++)&#123;</div><div class="line">            <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</div><div class="line">            <span class="keyword">if</span>(!filter(v))</div><div class="line">                <span class="keyword">throw</span> (<span class="string">"value"</span>+v+<span class="string">" rejected by filter"</span>);</div><div class="line">            &#125;</div><div class="line">            superclass.prototype.add.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">        );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">constructor</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="定义不可变的类"><a href="#定义不可变的类" class="headerlink" title="定义不可变的类"></a>定义不可变的类</h3><p><strong>创建一个不可变的类，他的属性和方法都是只读的</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from,to</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> props = &#123;</div><div class="line">        <span class="attr">from</span> : &#123;<span class="attr">value</span>:<span class="keyword">from</span>,<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">writable</span>:<span class="literal">false</span>,<span class="attr">configurable</span>:<span class="literal">false</span>),</div><div class="line">        to ： &#123;<span class="attr">value</span>:to,<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">writable</span>:<span class="literal">false</span>,<span class="attr">configurable</span>:<span class="literal">false</span>)</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Range)</div><div class="line">        <span class="built_in">Object</span>.defineProperties(<span class="keyword">this</span>,props);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(Range.prototype,props);</div><div class="line">        <span class="comment">//参数有两个，一个为类的原型，一个为类的实例方法或者实例变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>将o的指定名字（或所有）的属性设置为不可写的和不可配置的</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">freezeProps</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)</div><div class="line">        ?<span class="built_in">Object</span>.getOwnPropertyNames(o)</div><div class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,n).configurable)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(o,n,&#123;<span class="attr">writable</span>:<span class="literal">false</span>,<span class="attr">configureable</span>:<span class="literal">false</span>&#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将o的指定名字（或所有）的属性设置为不可枚举的和可配置的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideProps</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> props = (<span class="built_in">arguments</span>.length == <span class="number">1</span>)</div><div class="line">        ? <span class="built_in">Object</span>.getOwnPropertyNames(o)</div><div class="line">        : <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</div><div class="line">    props.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,n).configurable)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(o,n,&#123;<span class="attr">enumerable</span>:<span class="literal">false</span>&#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//**使用工具函数设置一个简单的不可变的类**</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from,to</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</div><div class="line">    <span class="keyword">this</span>.to = to;</div><div class="line">    fresszeProps(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">Range.propotype = hideProps(&#123;</div><div class="line">    <span class="attr">constructor</span>: Range,</div><div class="line">    <span class="attr">includes</span> : <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x&lt;= <span class="keyword">this</span>.to;&#125;,</div><div class="line">    <span class="attr">foreach</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from);x&lt;= <span class="keyword">this</span>.to;x++)f(x);&#125;,</div><div class="line">    <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> <span class="string">"("</span>+ <span class="keyword">this</span>.from +<span class="string">"..."</span>+<span class="keyword">this</span>.to+<span class="string">")"</span>;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="防止类的扩展"><a href="#防止类的扩展" class="headerlink" title="防止类的扩展"></a>防止类的扩展</h3><blockquote>
<ul>
<li><code>Object.preventExtensions()</code>可以将对象设置为不可扩展的</li>
<li><code>Object.seal()</code>阻止了用户给对象添加新属性，还能够将当前已有的属性设置为不可配置的</li>
</ul>
</blockquote>
<h2 id="正则表达式的模式匹配"><a href="#正则表达式的模式匹配" class="headerlink" title="正则表达式的模式匹配"></a>正则表达式的模式匹配</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"s$"</span>);</div></pre></td></tr></table></figure>
<h3 id="用于模式匹配的String方法"><a href="#用于模式匹配的String方法" class="headerlink" title="用于模式匹配的String方法"></a>用于模式匹配的String方法</h3><p><code>&quot;JavaScript&quot;.search(/script/i);</code>不支持全局搜索，返回第一个与之匹配的子串的起始位置<br><code>text.replace(/javascritt/gi,&quot;JavaScript&quot;);</code>将所有不区分大小写的javascript都替换成大小写正确的JavaScript<br><code>&quot;1 plus 2 equals 3&quot;.match(/\d+/g)</code>返回由匹配结果产生的数组</p>
<h2 id="JavaScript子集和扩展"><a href="#JavaScript子集和扩展" class="headerlink" title="JavaScript子集和扩展"></a>JavaScript子集和扩展</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;<span class="attr">one</span>:<span class="number">1</span>, <span class="attr">two</span>:<span class="number">2</span>, <span class="attr">three</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">in</span> o) <span class="built_in">console</span>.log(p);<span class="comment">//输出'one','two','three'</span></div><div class="line"><span class="keyword">for</span> each (<span class="keyword">let</span> v <span class="keyword">in</span> o) <span class="built_in">console</span>.log(v);<span class="comment">//输出1-3</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">       <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="keyword">return</span> nextIndex &lt; array.length ?</div><div class="line">               &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</div><div class="line">               &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</div><div class="line">       &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</div><div class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'yo'</span></div><div class="line"><span class="built_in">console</span>.log(it.next().value); <span class="comment">// 'ya'</span></div><div class="line"><span class="built_in">console</span>.log(it.next().done);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    <span class="keyword">yield</span> index++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = idMaker();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><strong>yield</strong></p>
<blockquote>
<p>yield关键字使得生成器执行暂停，yield关键字后面的表达式的值返回生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。<br>yield关键字实际返回一个IteratorResult对象，它有两个属性，value和done。value属性是对yield表达式求值的结果，而done是false，表示生成器函数尚未完全完成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appleStore = countAppleSales(); <span class="comment">// Generator &#123; &#125;</span></div><div class="line"><span class="built_in">console</span>.log(appleStore.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(appleStore.next()); <span class="comment">// &#123; value: 7, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(appleStore.next()); <span class="comment">// &#123; value: 5, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(appleStore.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类和模块&quot;&gt;&lt;a href=&quot;#类和模块&quot; class=&quot;headerlink&quot; title=&quot;类和模块&quot;&gt;&lt;/a&gt;类和模块&lt;/h2&gt;&lt;p&gt;&lt;code&gt;r instanceof Range&lt;/code&gt;:当使用instanceof运算符来检测对象是否属于某个类的时
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
