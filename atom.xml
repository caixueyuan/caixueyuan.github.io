<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2017-07-30T15:55:46.222Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSwing进阶</title>
    <link href="https://caixueyuan.github.io/2017/07/30/JavaSwing%E8%BF%9B%E9%98%B6/"/>
    <id>https://caixueyuan.github.io/2017/07/30/JavaSwing进阶/</id>
    <published>2017-07-30T03:31:52.000Z</published>
    <updated>2017-07-30T15:55:46.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA的Look-And-Feel"><a href="#JAVA的Look-And-Feel" class="headerlink" title="JAVA的Look And Feel"></a>JAVA的Look And Feel</h2><h3 id="JAVA-Swing的设计架构"><a href="#JAVA-Swing的设计架构" class="headerlink" title="JAVA Swing的设计架构"></a>JAVA Swing的设计架构</h3><blockquote>
<ul>
<li>Look 就是GUI widgets（通常来说都是组件JComponent）的显示界面。</li>
<li>feel 就是widget的行为方式</li>
</ul>
</blockquote>
<p>JAVA Swing允许将每个组件都分成两个独立的部分，JComponent和ComponentUI，例如JList，每个JList实例都有一个具体的实现ListUI（ListUI extends ComponentUI）。同样的，我们创建一个实例MetalTabbedPaneUI来实现LAF给JTabbedPane，然后对于组件的绘制就委托为MetalTabbedPaneUI。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class LookAndFeelDemo implements ActionListener &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> labelPrefix = <span class="string">"Number of button clicks: "</span>;</div><div class="line">    <span class="keyword">private</span> <span class="built_in">int</span> numClicks = <span class="number">0</span>;</div><div class="line">    <span class="keyword">final</span> JLabel label = <span class="keyword">new</span> JLabel(labelPrefix + <span class="string">"0    "</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Specify the look and feel to use by defining the LOOKANDFEEL constant</span></div><div class="line">    <span class="comment">// Valid values are: null (use the default), "Metal", "System", "Motif",</span></div><div class="line">    <span class="comment">// and "GTK"</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> LOOKANDFEEL = <span class="string">"System"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// If you choose the Metal L&amp;F, you can also choose a theme.</span></div><div class="line">    <span class="comment">// Specify the theme to use by defining the THEME constant</span></div><div class="line">    <span class="comment">// Valid values are: "DefaultMetal", "Ocean",  and "Test"</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> THEME = <span class="string">"Test"</span>;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">public</span> Component createComponents() &#123;</div><div class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">"I'm a Swing button!"</span>);</div><div class="line">        button.setMnemonic(KeyEvent.VK_I);</div><div class="line">        button.addActionListener(<span class="keyword">this</span>);</div><div class="line">        label.setLabelFor(button);</div><div class="line"></div><div class="line">        <span class="comment">//使用面板来插入这两个组件</span></div><div class="line">        JPanel pane = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line">        pane.<span class="built_in">add</span>(button);</div><div class="line">        pane.<span class="built_in">add</span>(label);</div><div class="line">        pane.setBorder(BorderFactory.createEmptyBorder(</div><div class="line">                                        <span class="number">30</span>, <span class="comment">//top</span></div><div class="line">                                        <span class="number">30</span>, <span class="comment">//left</span></div><div class="line">                                        <span class="number">10</span>, <span class="comment">//bottom</span></div><div class="line">                                        <span class="number">30</span>) <span class="comment">//right</span></div><div class="line">                                        );</div><div class="line"></div><div class="line">        <span class="keyword">return</span> pane;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> actionPerformed(ActionEvent e) &#123;</div><div class="line">        numClicks++;</div><div class="line">        label.setText(labelPrefix + numClicks);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> initLookAndFeel() &#123;</div><div class="line">        <span class="keyword">String</span> lookAndFeel = <span class="keyword">null</span>;</div><div class="line">       </div><div class="line">        <span class="keyword">if</span> (LOOKANDFEEL != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (LOOKANDFEEL.equals(<span class="string">"Metal"</span>)) &#123;</div><div class="line">                lookAndFeel = UIManager.getCrossPlatformLookAndFeelClassName();</div><div class="line">                <span class="comment">//显示的是跨系统的组件的形式</span></div><div class="line">              <span class="comment">//  an alternative way to set the Metal L&amp;F is to replace the </span></div><div class="line">              <span class="comment">// previous line with:</span></div><div class="line">              <span class="comment">// lookAndFeel = "javax.swing.plaf.metal.MetalLookAndFeel";</span></div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (LOOKANDFEEL.equals(<span class="string">"System"</span>)) &#123;</div><div class="line">                lookAndFeel = UIManager.getSystemLookAndFeelClassName();</div><div class="line">                <span class="comment">//显示的是对应的系统的形式</span></div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (LOOKANDFEEL.equals(<span class="string">"Motif"</span>)) &#123;</div><div class="line">                lookAndFeel = <span class="string">"com.sun.java.swing.plaf.motif.MotifLookAndFeel"</span>;</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (LOOKANDFEEL.equals(<span class="string">"GTK"</span>)) &#123; </div><div class="line">                lookAndFeel = <span class="string">"com.sun.java.swing.plaf.gtk.GTKLookAndFeel"</span>;</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Unexpected value of LOOKANDFEEL specified: "</span></div><div class="line">                                   + LOOKANDFEEL);</div><div class="line">                lookAndFeel = UIManager.getCrossPlatformLookAndFeelClassName();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                </div><div class="line">                </div><div class="line">                UIManager.setLookAndFeel(lookAndFeel);</div><div class="line">                </div><div class="line">                <span class="comment">// If L&amp;F = "Metal", set the theme</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (LOOKANDFEEL.equals(<span class="string">"Metal"</span>)) &#123;</div><div class="line">                  <span class="keyword">if</span> (THEME.equals(<span class="string">"DefaultMetal"</span>))</div><div class="line">                     MetalLookAndFeel.setCurrentTheme(<span class="keyword">new</span> DefaultMetalTheme());</div><div class="line">                     <span class="comment">//当然，我们除了设置look and feel 的话，我们也可以设置主题</span></div><div class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (THEME.equals(<span class="string">"Ocean"</span>))</div><div class="line">                     MetalLookAndFeel.setCurrentTheme(<span class="keyword">new</span> OceanTheme());</div><div class="line">                  <span class="keyword">else</span> MetalLookAndFeel.setCurrentTheme(<span class="keyword">new</span> TestTheme());</div><div class="line">                  UIManager.setLookAndFeel(<span class="keyword">new</span> MetalLookAndFeel()); </div><div class="line">                &#125;</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Couldn't find class for specified look and feel:"</span></div><div class="line">                                   + lookAndFeel);</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Did you include the L&amp;F library in the class path?"</span>);</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Using the default look and feel."</span>);</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">catch</span> (UnsupportedLookAndFeelException e) &#123;</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Can't use the specified look and feel ("</span></div><div class="line">                                   + lookAndFeel</div><div class="line">                                   + <span class="string">") on this platform."</span>);</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Using the default look and feel."</span>);</div><div class="line">            &#125; </div><div class="line">            </div><div class="line">            <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Couldn't get specified look and feel ("</span></div><div class="line">                                   + lookAndFeel</div><div class="line">                                   + <span class="string">"), for some reason."</span>);</div><div class="line">                System.err.<span class="built_in">println</span>(<span class="string">"Using the default look and feel."</span>);</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Create the GUI and show it.  For thread safety,</div><div class="line">     * this method should be invoked from the</div><div class="line">     * event dispatch thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> createAndShowGUI() &#123;</div><div class="line">        <span class="comment">//Set the look and feel.</span></div><div class="line">        initLookAndFeel();</div><div class="line"></div><div class="line">        <span class="comment">//Make sure we have nice window decorations.</span></div><div class="line">        JFrame.setDefaultLookAndFeelDecorated(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">//Create and set up the window.</span></div><div class="line">        JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">"SwingApplication"</span>);</div><div class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</div><div class="line"></div><div class="line">        LookAndFeelDemo app = <span class="keyword">new</span> LookAndFeelDemo();</div><div class="line">        Component contents = app.createComponents();</div><div class="line">        frame.getContentPane().<span class="built_in">add</span>(contents, BorderLayout.CENTER);</div><div class="line"></div><div class="line">        <span class="comment">//Display the window.</span></div><div class="line">        frame.pack();</div><div class="line">        frame.setVisible(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="comment">//Schedule a job for the event dispatch thread:</span></div><div class="line">        <span class="comment">//creating and showing this application's GUI.</span></div><div class="line">        javax.swing.SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">                createAndShowGUI();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的话就是这里<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//获取系统中安装的Look And Feel</div><div class="line">UIManager.getInstalledLookAndFeels()</div><div class="line"></div><div class="line">//得到要实现的LookAndFeel</div><div class="line"><span class="attribute">lookAndFeel</span> = UIManager.getSystemLookAndFeelClassName()<span class="comment">;</span></div><div class="line"><span class="attribute">lookAndFeel</span> = UIManager.getCrossPlatformLookAndFeelClassName()<span class="comment">;</span></div><div class="line"><span class="attribute">lookAndFeel</span> = <span class="string">"com.sun.java.swing.plaf.motif.MotifLookAndFeel"</span><span class="comment">;</span></div><div class="line">//设置要使用的LookAndFeel</div><div class="line">UIManager.setLookAndFeel(lookAndFeel)<span class="comment">;</span></div><div class="line">//当然，启动程序之后还是可以修改的</div><div class="line">SwingUtilities.updateComponentTreeUI(frame)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h2 id="AWT多线程"><a href="#AWT多线程" class="headerlink" title="AWT多线程"></a>AWT多线程</h2><h3 id="AWT时间派发线程在什么时候会执行我们的代码"><a href="#AWT时间派发线程在什么时候会执行我们的代码" class="headerlink" title="AWT时间派发线程在什么时候会执行我们的代码"></a>AWT时间派发线程在什么时候会执行我们的代码</h3><p>在界面后台中事件分发线程一直在跑，当有需要操作界面的行为时，就将行为添加到事件派发队列中，事件派发线程会依法执行这个队列中的请求，每个请求都是采用FIFO，没有优先级。</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/swing/%E4%BA%8B%E4%BB%B6%E5%88%86%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="事件分发机制"><br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">javax.swing.<span class="type">SwingUtilities</span>.invokeLater(<span class="function"><span class="keyword">new</span> <span class="title">Runnable</span>() &#123;</span></div><div class="line">    <span class="title">public</span> <span class="title">void</span> <span class="title">run</span>() &#123;</div><div class="line">        <span class="title">createAndShowGUI</span>();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//判断当前的线程是否为事件分发线程</span></div><div class="line"><span class="title">SwingUtilities</span>.<span class="title">isEventDispatchThread</span>()</div></pre></td></tr></table></figure></p>
<p>SwingUtilities.invokeLater可以在任何线程中请求事件分发线程来运行某段代码，你必须将这段代码放入一个Runnable对象的run方法中，并将该指定Runnable对象作为参数传递给invokeLater，invokeLater函数会立即返回，不会等到事件分发线程执行完代码。<br>SwingUtilities.invokeAndWait是直到事件分发线程已经执行了指定代码才返回</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>1，将一个比较消耗时间的初始化任务移出主线程，可以使GUI出现得更快<br>2，将耗时任务移出事件分发线程，从而使GUI同时继续响应用户操作。<br>3，如果某一个GUI请求非常耗时，就不要把这个请求发送给事件派发线程。直到这个请求通过其他线程处理之后，最后的少部分界面请求再发送给事件派发线程</p>
<h2 id="JTable"><a href="#JTable" class="headerlink" title="JTable"></a>JTable</h2><h3 id="获取用于显示的数据"><a href="#获取用于显示的数据" class="headerlink" title="获取用于显示的数据"></a>获取用于显示的数据</h3><p> 有三个方法<br> <strong>方法一</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String</span>[] columnNames=&#123;<span class="string">"FirstName"</span>,<span class="string">"LastName"</span>,<span class="string">"Sport"</span>,<span class="string">"Year"</span>,<span class="string">"Vegetarian"</span>&#125;;</div><div class="line">Object[][] data = &#123;</div><div class="line">        &#123;<span class="string">"Kathy"</span>, <span class="string">"Smith"</span>,</div><div class="line">         <span class="string">"Snowboarding"</span>, <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">5</span>), <span class="keyword">new</span> <span class="type">Boolean</span>(<span class="literal">false</span>)&#125;,</div><div class="line">        &#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>,</div><div class="line">         <span class="string">"Rowing"</span>, <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">3</span>), <span class="keyword">new</span> <span class="type">Boolean</span>(<span class="literal">true</span>)&#125;,</div><div class="line">        &#123;<span class="string">"Sue"</span>, <span class="string">"Black"</span>,</div><div class="line">         <span class="string">"Knitting"</span>, <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="type">Boolean</span>(<span class="literal">false</span>)&#125;,</div><div class="line">        &#123;<span class="string">"Jane"</span>, <span class="string">"White"</span>,</div><div class="line">         <span class="string">"Speed reading"</span>, <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">20</span>), <span class="keyword">new</span> <span class="type">Boolean</span>(<span class="literal">true</span>)&#125;,</div><div class="line">        &#123;<span class="string">"Joe"</span>, <span class="string">"Brown"</span>,</div><div class="line">         <span class="string">"Pool"</span>, <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">10</span>), <span class="keyword">new</span> <span class="type">Boolean</span>(<span class="literal">false</span>)&#125;</div><div class="line">        &#125;;</div><div class="line">final JTable table = <span class="keyword">new</span> <span class="type">JTable</span>(data, columnNames);</div></pre></td></tr></table></figure></p>
<p><strong>方法二</strong><br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JTable <span class="keyword">table</span>=new <span class="comment">JTable(Vector rowData,Vector columnNames)</span></div></pre></td></tr></table></figure></p>
<p><strong>Table Model</strong><br>可以使用自定义的TableModel</p>
<h3 id="将JTable放在容器中"><a href="#将JTable放在容器中" class="headerlink" title="将JTable放在容器中"></a>将JTable放在容器中</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JTable</span> <span class="keyword">extends</span> <span class="title">JComponent</span> <span class="title">implements</span> <span class="title">TableModelListener</span>, <span class="title">Scrollable</span>,</span></div><div class="line">    <span class="type">TableColumnModelListener</span>, <span class="type">ListSelectionListener</span>, <span class="type">CellEditorListener</span>,</div><div class="line">    <span class="type">Accessible</span>, <span class="type">RowSorterListener</span></div></pre></td></tr></table></figure>
<p>JTable是一个JComponent，将其放在容器中<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将其放在一个有滑条的面板中，然后让其充满这个面板</span></div><div class="line">JScrollPane scrollPane = new JScrollPane(<span class="keyword">table</span>);</div><div class="line"><span class="keyword">table</span>.setFillsViewportHeight(true);</div></pre></td></tr></table></figure></p>
<h3 id="选择多行或者多列"><a href="#选择多行或者多列" class="headerlink" title="选择多行或者多列"></a>选择多行或者多列</h3><p><strong>多行选择</strong><br>setRowSelectionAllowed()和getRowSelectionAllowed()<br><strong>多列选择</strong><br>setColumnSelectionAllowed()和getColumnSelectionAllowed()<br><strong>多单元框选择</strong><br>setCellSelectionAllowed()和getCellSelectionAllowed()<br><strong>获取选择的行下标或者列下标</strong><br>getSelectedRows()或者getSelectedColumns()</p>
<h3 id="监控数据的更新"><a href="#监控数据的更新" class="headerlink" title="监控数据的更新**"></a>监控数据的更新**</h3><p>是对整个TableModel进行监控<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTableDemo</span> ... <span class="keyword">implements</span> <span class="title">TableModelListener</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTableDemo</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        table.getModel().addTableModelListener(<span class="keyword">this</span>);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tableChanged</span><span class="params">(TableModelEvent e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = e.getFirstRow();</div><div class="line">        <span class="keyword">int</span> column = e.getColumn();</div><div class="line">        TableModel model = (TableModel)e.getSource();</div><div class="line">        String columnName = model.getColumnName(column);</div><div class="line">        Object data = model.getValueAt(row, column);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过对整个TableModel进行监控，</p>
<h3 id="编辑器和渲染器"><a href="#编辑器和渲染器" class="headerlink" title="编辑器和渲染器"></a>编辑器和渲染器</h3><p>渲染器决定了单元格内容的展现形式，而编辑器决定单元格内容被编辑的方式。比如，默认情况下，数字使用右对齐的JLabel来展示，布尔型变量使用单选控件来展示；而你在编辑某些列时，可能希望从下拉菜单中选择内容，这就是编辑器的作用了。出于性能上的考虑，JTable并没有为每一个单元格提供独立的渲染器，而是根据数据类型来渲染的。JTable首先会检查该列是否指定了渲染器，没有的话就检查该列的数据类型，并查看对应的渲染器。而基础类型以外的对象基本都是调用其toString方法，并通过JLable来渲染的。编辑器也是一样。</p>
<p><strong>渲染器</strong>：通常可以用来画出所有的包括相同数据类型的单元格，当用户开始编辑单元格中的数据时，一个单元格渲染器接手单元格，控制单元格的编辑行为。</p>
<p><strong>编辑器</strong>：</p>
<p><a href="https://my.oschina.net/bairrfhoinn/blog/166850" target="_blank" rel="external">参考资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JAVA的Look-And-Feel&quot;&gt;&lt;a href=&quot;#JAVA的Look-And-Feel&quot; class=&quot;headerlink&quot; title=&quot;JAVA的Look And Feel&quot;&gt;&lt;/a&gt;JAVA的Look And Feel&lt;/h2&gt;&lt;h3 id=&quot;J
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JAVA Swing" scheme="https://caixueyuan.github.io/tags/JAVA-Swing/"/>
    
  </entry>
  
  <entry>
    <title>JavaSwing</title>
    <link href="https://caixueyuan.github.io/2017/07/28/JavaSwing/"/>
    <id>https://caixueyuan.github.io/2017/07/28/JavaSwing/</id>
    <published>2017-07-28T13:50:15.000Z</published>
    <updated>2017-07-30T15:53:25.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-Swing"><a href="#Java-Swing" class="headerlink" title="Java Swing"></a>Java Swing</h2><h3 id="Java-Swing-1"><a href="#Java-Swing-1" class="headerlink" title="Java  Swing"></a>Java  Swing</h3><p>用纯Java编写，支持可更换的面板和主题，然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用Java支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。Swing调用本地图形子系统中的底层例程，而不是依赖操作系统的高层用户界面模块。Swing 无法充分利用硬件 GUI 加速器和专用主机 GUI 操作的优点。结果是 Swing 应用程序可能比本地 GUI 的程序运行速度都慢</p>
<p>Java Swing**:<br>主要：JComponent,Panel,Window<br>布局管理器：LayoutManager</p>
<h3 id="Java-AWT-Abstract-Window-Tookit"><a href="#Java-AWT-Abstract-Window-Tookit" class="headerlink" title="Java AWT(Abstract Window Tookit)"></a>Java AWT(Abstract Window Tookit)</h3><p>是Java的平台独立的视窗系统， 图形和使用者界面器件工具包，最根本的缺点是AWT在原生的用户界面之上仅提供了一个非常薄的抽象层，例如生成一个AWT的复选框会导致AWT直接调用下层原生例程来生成一个复选框，但是呢，由于底层的表现不一样可能会导致不同平台的表现不一样。</p>
<blockquote>
<p>AWT的一个很好的特性是可以对GUI组件自动进行销毁，是“线程安全”，不过会导致AWTGUI运行的速度更慢。</p>
<h3 id="Java-SWT"><a href="#Java-SWT" class="headerlink" title="Java SWT:"></a>Java SWT:</h3><p>对于大部分现代主机来说，几乎所有的控件都是基于本地对等体的。这意味着基于 SWT 的 GUI 既具有主机外观，又具有主机的性能。<br>优缺点：不支持 GUI 控件的自动销毁，只能够自顶向下的构建GUI，不是线程安全的，</p>
</blockquote>
<h2 id="Java-Swing的四个重量级顶层界面组件：JFrame，JApplet，JDialog和JWindow"><a href="#Java-Swing的四个重量级顶层界面组件：JFrame，JApplet，JDialog和JWindow" class="headerlink" title="Java Swing的四个重量级顶层界面组件：JFrame，JApplet，JDialog和JWindow"></a>Java Swing的四个重量级顶层界面组件：JFrame，JApplet，JDialog和JWindow</h2><h3 id="JFrame："><a href="#JFrame：" class="headerlink" title="JFrame："></a>JFrame：</h3><h2 id="顶层类和非顶层类的区别："><a href="#顶层类和非顶层类的区别：" class="headerlink" title="顶层类和非顶层类的区别："></a>顶层类和非顶层类的区别：</h2><p>顶层容器和其他组件区别在于顶层容器没有自身的paint逻辑，所有的顶层容器都是通过底层系统API来绘制对等体的方式来进行paint，自身没有JAVA 2D的paint逻辑实现，对等体化成什么样子顶层容器就是什么样子，他只是可以控制对等体的一些可配置显示的属性。Swing的 4个顶层容器都是在addNotify时才会getToolkit().createPeer(this)（Frame/Dialog/Window）, 而addNotify并不是在构造时被调用，而是在pack/show或setvisible（这3个所谓的realized具现化方法）时被调用。创建了对等体peer后还要通过peer.pShow（show/setVisible(true)调用）调用才会要求底层系统进行显示（所以只有pack是不会显示窗口的）。在显示窗口后底层消息队列得到通知，此后随着窗口被最小化后恢复或被遮盖后恢复等系统操作后同样能从底层消息得到通知</p>
<p>轻量级Swing组件将绘制有关的职责都委托给了ui成员对象，ui对象使用JAVA2D API 进行绘制，paint成什么样那就是这个组件的样子。具体就是在构造的时候即要 updateUI{setUI(UIManger.getUI(this))}。UIManger会根据当前L&amp;F的选择，根据 this.uiClassID来得到ui成员类并建立实例，以后的paint回调等都推托给ui成员类paint，这也算是一种策略模式。Setui的过程中除了保存这个ui实例外，将repaint来通知RepaintManager进行paint回调完成组件绘制。轻量级Swing组件在addNotify时也会去创建对等体getToolkit().createPeer(this)( LightWeightPeer)，但这个peer的实现（NullComponentPeer）是个空壳子，只是作为一个轻量级组件的标记，以后的很多事件处理等都要判断peer是否instance of LightWeightPeer从而能够进行不同处理。</p>
<p>同样的Addnotify也不是在构造时被调用，而是在被加入container时被调用</p>
<p>![<a href="http://developer.51cto.com/art/200907/137337.htm" target="_blank" rel="external">http://developer.51cto.com/art/200907/137337.htm</a>]</p>
<h2 id="Swing-MVC"><a href="#Swing-MVC" class="headerlink" title="Swing MVC"></a>Swing MVC</h2><p>严格的说，Swing中的MVC实际上是MVC的一个变体：M-VC。 Swing中只显示的定义了Model接口，而在一个UI对象中集成了视图和控制器的部分机制。View和Control比较松散的交叉组合在一起，而更多的控制逻辑是在事件监听者部分引入的。</p>
<p>在Swing中基本上每一个组件都会有对应的Model对象。但其并不是一一对应的，一个Model接口可以为多个Swing对向服务，例如：JProgressBar，JScrollBar，JSlider这三个组件使用的都是BoundedRangeModel接口。除了Model接口外，为了实现多个视感间的自由切换，每个Swing组件还包含一个UI接口，也就是View-Controller，负责对组件的绘制和接受用户输入。<br>　　Model-View是Subject和Obverser的关系，因而，模型的改变必须要在UI对象中体现出来。Swing使用了JavaBeans的事件模型来实现这种通知机制。具体而言，有两种实现办法，一是仅仅通知事件监听者状态改变了，然后由事件监听者向模型提取必要的状态信息。这种机制对于事件频繁的组件很有效。另外的一种办法是模型向监听者发送包含了已改变的状态信息的通知给UI。这两种方法根据其优劣被分别是现在不同的组件中。比如在JScollBar中使用的是第一种方法，在JTable中使用的是第二种方法。而对Model而言，为了能够支持多个View，它并不知道具体的每一个View。它维护一个对其数据感兴趣的Obverser的列表，使得当数据改变的时候，能够通知到每一个Swing组件对象。</p>
<h2 id="使用JFrame，JButton，JLabel写一个例子"><a href="#使用JFrame，JButton，JLabel写一个例子" class="headerlink" title="使用JFrame，JButton，JLabel写一个例子"></a>使用JFrame，JButton，JLabel写一个例子</h2><h3 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h3><p>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-Swing&quot;&gt;&lt;a href=&quot;#Java-Swing&quot; class=&quot;headerlink&quot; title=&quot;Java Swing&quot;&gt;&lt;/a&gt;Java Swing&lt;/h2&gt;&lt;h3 id=&quot;Java-Swing-1&quot;&gt;&lt;a href=&quot;#Java-Swin
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swing" scheme="https://caixueyuan.github.io/tags/Swing/"/>
    
  </entry>
  
  <entry>
    <title>Java嵌套类</title>
    <link href="https://caixueyuan.github.io/2017/07/27/Java%E5%B5%8C%E5%A5%97%E7%B1%BB/"/>
    <id>https://caixueyuan.github.io/2017/07/27/Java嵌套类/</id>
    <published>2017-07-27T12:55:16.000Z</published>
    <updated>2017-07-27T16:07:18.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><h3 id="Java内部类的可见性"><a href="#Java内部类的可见性" class="headerlink" title="Java内部类的可见性"></a>Java内部类的可见性</h3><p>Java类也可以在任何范围内定义，包括public,private或者protected。</p>
<p><strong>使用内部类的最大的好处</strong></p>
<blockquote>
<ul>
<li>1，就是能够解决多重继承的问题。每个内部类可以使用不同的方式来实现一个接口，或者继承一个类</li>
<li>2，内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立</li>
<li>3，创建内部类对象的时刻并不依赖于外围类对象的创建（对于静态内部类来说）</li>
<li>4，内部类并没有”is-a”,可以说是外部类拥有了很多独立的实体</li>
<li>5，内部类提供了更好的封装，除了外围类，其他类不能够访问。</li>
</ul>
</blockquote>
<h3 id="动态内部类"><a href="#动态内部类" class="headerlink" title="动态内部类"></a>动态内部类</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  public <span class="type">Manager</span>() &#123;</div><div class="line">  &#125;</div><div class="line">  . . .</div><div class="line">  public <span class="class"><span class="keyword">class</span> <span class="title">DirectReports</span> </span>&#123;</div><div class="line">  . . .</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// Meanwhile, in another method somewhere...</span></div><div class="line">public static void main(<span class="type">String</span>[] args) &#123;</div><div class="line">  <span class="type">Manager</span> manager = <span class="keyword">new</span> <span class="type">Manager</span>();</div><div class="line">  <span class="type">Manager</span>.<span class="type">DirectReports</span> dr = manager.<span class="keyword">new</span> <span class="type">DirectReports</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Employee</span></span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerComparator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Comparator</span></span>&lt;<span class="title">Manager</span>&gt; </span>&#123;</div><div class="line">  . . .</div><div class="line">  &#125;</div><div class="line"><span class="comment">// Meanwhile, in another method somewhere...</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">  Manager.ManagerComparator mc = <span class="keyword">new</span> <span class="type">Manager</span>.ManagerComparator();</div><div class="line">  . . .</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><strong> 成员内部类中不能存在任何static的变量和方法</strong><br><strong>成员变量是依附于外部类的</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span> &#123;</div><div class="line">    <span class="keyword">private</span> String str;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerDisplay</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"outerClass..."</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InnerClass</span>&#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerDisplay</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">//使用外围内的属性</span></div><div class="line">            str = <span class="string">"chenssy..."</span>;</div><div class="line">            System.<span class="keyword">out</span>.println(str);</div><div class="line">            <span class="comment">//使用外围内的方法</span></div><div class="line">            outerDisplay();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</div><div class="line">        OuterClass.InnerClass inner = outer.getInnerClass();</div><div class="line">        inner.innerDisplay();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Destionation destionation(<span class="keyword">String</span> str)&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Destionation</span></span></span>&#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">String</span> label;</div><div class="line">            <span class="keyword">private</span> PDestionation(<span class="keyword">String</span> whereTo)&#123;</div><div class="line">                label = whereTo;</div><div class="line">            &#125;</div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">String</span> readLabel() &#123;</div><div class="line">                <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">                System.out.println(label);</div><div class="line">                <span class="keyword">return</span> label;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">PDestionation</span>(str);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        Parcel5 parcel5 = <span class="keyword">new</span> <span class="type">Parcel5</span>();</div><div class="line">        Destionation d = parcel5.destionation(<span class="string">"chenssy"</span>);</div><div class="line">        d.readLabel();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span> Destionation &#123;</div><div class="line">    public String readLabel();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译之后产生了Parcel5$1PDestionation.class和Parcel5.class。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span>(<span class="params">final <span class="keyword">int</span> num,String str2</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;</div><div class="line">            <span class="keyword">int</span> number = num + <span class="number">3</span>;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">return</span> number;</div><div class="line">            &#125;</div><div class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        OuterClass <span class="keyword">out</span> = <span class="keyword">new</span> OuterClass();</div><div class="line">        InnerClass inner = <span class="keyword">out</span>.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(inner.getNumber());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">interface</span> <span class="title">InnerClass</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1，匿名内部类没有访问修饰符,<br>2，匿名函数可以得到外部给的形参<br>3，对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用<br>4，使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，只能继承一个类或者实现一个接口</p>
<p>5，匿名内部类中不能存在任何的静态成员变量和静态方法，匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法<br>6，匿名内部类中是不能定义构造函数的，匿名内部类中不能存在任何的静态成员变量和静态方法</p>
<p><strong>我们可以知道，无论是什么内部类，通过编译都会出现独立的class文件。</strong></p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><blockquote>
<ul>
<li>字段表集合中不会列出从超类或者父接口中继承来的字段，但有可能列出原本Java代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li>
<li>InnerClasses属性用于记录内部类与宿主类之间的关系，如果一个类中定义了内部类，那么编译器将会为它以及所包含的内部类生成InnerClass属性。包括atrribute_name_index,attribute_length,number_of_classes,inner_classes，数据项number_of_classes代表需要多少个内部类信息</li>
<li>每一个内部类的信息都由一个inner_classes_info表进行描述，inner_class_info_index,outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表的是内部类和宿主类的符号引用。inner_name_index是指向常量池中CONSTANT_UTF8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0;inner_class_access_flags是内部类的访问标志，类似与类的access_flags。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;嵌套类&quot;&gt;&lt;a href=&quot;#嵌套类&quot; class=&quot;headerlink&quot; title=&quot;嵌套类&quot;&gt;&lt;/a&gt;嵌套类&lt;/h2&gt;&lt;h3 id=&quot;Java内部类的可见性&quot;&gt;&lt;a href=&quot;#Java内部类的可见性&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java基础知识" scheme="https://caixueyuan.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://caixueyuan.github.io/2017/07/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://caixueyuan.github.io/2017/07/26/Java线程池/</id>
    <published>2017-07-26T13:10:29.000Z</published>
    <updated>2017-07-26T16:00:20.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><blockquote>
<ul>
<li>避免线程的创建和销毁带来的性能开销。</li>
<li>避免大量的线程间因互相抢占系统资源导致的阻塞现象。</li>
<li>能够对线程进行简单的管理并提供定时执行、间隔执行等功能。</li>
</ul>
</blockquote>
<h3 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">    Future&lt;?&gt; submit(Runnable task);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建线程池的方法</span></div><div class="line">ExecutorService pool=Executors.newCachedThreadPool();</div></pre></td></tr></table></figure>
<p><strong>运行线程</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>使用submit</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Future&lt;<span class="built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     <span class="built_in">Object</span> s = future.<span class="keyword">get</span>();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    <span class="comment">// 处理中断异常</span></div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">    <span class="comment">// 处理无法执行任务异常</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭线程池</span></div><div class="line">    executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1、如果线程池中的线程数量少于corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务；</p>
<p>2、如果线程池中的线程数量大于等于corePoolSize，但缓冲队列workQueue未满，则将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）；</p>
<p>3、如果线程池中的线程数量大于等于corePoolSize，且缓冲队列workQueue已满，但线程池中的线程数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务；</p>
<p><strong>线程池的关闭</strong>：<br>shutdownNow:线程池的状态设置为STOP，然后停止所有的正在执行或者暂停任务的线程，并返回等待执行任务的列表</p>
<p>shutdow:将线程池的状态设置为SHUTDOWN状态，然后中断所有正在执行任务的线程</p>
<h3 id="Java线程池的种类"><a href="#Java线程池的种类" class="headerlink" title="Java线程池的种类"></a>Java线程池的种类</h3><p><strong>newCachedThreadPool</strong><br>一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<p><strong>newSingleThreadExecutor</strong><br>该线程池只有一个线程，如果线程因为异常结束的话，新建一个线程来代替</p>
<p><strong>newFixedThreadPool</strong><br>指定线程数目的线程池</p>
<p><strong>newScheduleThreadPool</strong><br>创建一个大小无限的线程池</p>
<h2 id="线程的名字"><a href="#线程的名字" class="headerlink" title="线程的名字"></a>线程的名字</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ThreadGroup group</span>=Thread.currentThread().getThreadGroup();</div></pre></td></tr></table></figure>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Thread</span>[] threads=<span class="keyword">new</span> <span class="keyword">Thread</span>[group.activeCount()]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>创建线程</strong><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span>=<span class="keyword">new</span> <span class="keyword">Thread</span>(<span class="string">"thread"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p><strong>改名字</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread.setName()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p><strong>-Xss-</strong>:设置每个线程的堆栈大小，JDK5.0以后每个线程堆栈大小为1M，以前每个线程的堆栈大小为256K。但是在操作系统对一个进程中的线程数还是有限制的，不能够无线生成，经验在3000-5000左右。</p>
<h2 id="线程组-1"><a href="#线程组-1" class="headerlink" title="线程组"></a>线程组</h2><blockquote>
<ul>
<li>Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理。对线程组的控管理，即同时控制线程组里面的这一批线程</li>
<li>用户创建的所有线程都属于指定线程组，如果没有显示指定属于哪个线程组，那么该线程就属于默认线程组（即main线程组）。默认情况下，子线程和父线程处于同一个线程组</li>
<li>只有在创建线程时才能指定其所在的线程组，线程运行中途不能改变它所属的线程组，也就是说线程一旦指定所在的线程组，就直到该线程结束</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;h3 id=&quot;Java线程池&quot;&gt;&lt;a href=&quot;#Java线程池&quot; class=&quot;headerlink&quot; title=&quot;Java线程池
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="线程池" scheme="https://caixueyuan.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="https://caixueyuan.github.io/2017/07/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2017/07/25/Java多线程基础/</id>
    <published>2017-07-25T14:26:28.000Z</published>
    <updated>2017-07-25T16:13:34.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><blockquote>
<p>1,Volatile变量具有synchronized的可见性特性，但是不具备原子特性。</p>
</blockquote>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h3><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>
<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>
<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>
<p>多个变量之间或者某个变量的当前值与修改后值之间没有约束。<br>对于x++等递增操作，要保证是原子操作，然后不能够只是使用volatile<br>但是呢，volatile的性能比较好。</p>
<h3 id="2-保证有序性"><a href="#2-保证有序性" class="headerlink" title="2,保证有序性"></a>2,保证有序性</h3><p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<h3 id="正确使用的方法："><a href="#正确使用的方法：" class="headerlink" title="正确使用的方法："></a>正确使用的方法：</h3><blockquote>
<ul>
<li>状态标志<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</div><div class="line">    shutdownRequested=<span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(!shutdownRequested)&#123;</div><div class="line">        <span class="comment">//do stuff</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一次性安全发布</p>
</blockquote>
<p>被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>
<blockquote>
<p>独立观察：</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class UserManager &#123;</div><div class="line">    public volatile String lastUser;</div><div class="line"> </div><div class="line">    public boolean authenticate(String user, String password) &#123;</div><div class="line">        boolean valid = passwordIsValid(user, password);</div><div class="line">        <span class="keyword">if</span> (valid) &#123;</div><div class="line">           <span class="built_in"> User </span>u = new User();</div><div class="line">            activeUsers.<span class="builtin-name">add</span>(u);</div><div class="line">            lastUser =<span class="built_in"> user;</span></div><div class="line">        &#125;</div><div class="line">        return valid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改</p>
<blockquote>
<p>开销很低的读-写策略<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@ThreadSafe</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesyCounter</span> &#123;</div><div class="line">    <span class="comment">// Employs the cheap read-write lock trick</span></div><div class="line">    <span class="comment">// All mutative operations MUST be done with the 'this' lock held</span></div><div class="line">    @GuardedBy(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">value</span>; &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">int</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">value</span>++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="ThreadLocal（线程局部变量（thread-local-variable"><a href="#ThreadLocal（线程局部变量（thread-local-variable" class="headerlink" title="ThreadLocal（线程局部变量（thread-local  variable)"></a>ThreadLocal（线程局部变量（thread-local  variable)</h2><h3 id="作用：用来存储线程中的局部变量"><a href="#作用：用来存储线程中的局部变量" class="headerlink" title="作用：用来存储线程中的局部变量"></a><strong>作用</strong>：用来存储线程中的局部变量</h3><p>因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且是在线程内部任何地方都可以使用，线程之间互不影响，这样就不会存在线程安全问题，也不会严重影响程序执行性能，考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
<h3 id="深入解析ThreadLocal类"><a href="#深入解析ThreadLocal类" class="headerlink" title="深入解析ThreadLocal类"></a>深入解析ThreadLocal类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//获取在当前线程中保存的变量副本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>) </span>&#123; &#125;<span class="comment">//设置当前线程中变量的副本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//移除当前线程中的变量的副本</span></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>) </span>&#123; &#125;<span class="comment">//延迟加载</span></div></pre></td></tr></table></figure>
<p>首先的话，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的变量的threadLocals,这个threadLocals就是用来存储实际的变量的副本的，键值为当前的ThreadLocal变量，value为变量的副本。</p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。</p>
<p>在进行get之前，必须先set，否则会报空指针异常；</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</div><div class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</div><div class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</div><div class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>
<p>线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Volatile&quot;&gt;&lt;a href=&quot;#Volatile&quot; class=&quot;headerlink&quot; title=&quot;Volatile&quot;&gt;&lt;/a&gt;Volatile&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1,Volatile变量具有synchronized的可见性特性，
    
    </summary>
    
      <category term="Java学习笔记" scheme="https://caixueyuan.github.io/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java多线程基础" scheme="https://caixueyuan.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程-线程-Java</title>
    <link href="https://caixueyuan.github.io/2017/07/25/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-Java/"/>
    <id>https://caixueyuan.github.io/2017/07/25/进程-线程-Java/</id>
    <published>2017-07-24T16:02:51.000Z</published>
    <updated>2017-07-24T16:08:39.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>进程</p>
<ul>
<li>进程是具有一定独立功能的程序关于某个数据集合中的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源</li>
<li>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行</li>
<li>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列</li>
</ul>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<blockquote>
<p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</blockquote>
<h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><blockquote>
<ul>
<li>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。进程是操作系统分配资源的单位</li>
<li>线程(Thread)是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
</blockquote>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>在Windows中，进行CPU分配是以线程为单位的，一个进程可能由多个线程组成：<br>总线程数&lt;= CPU数量：并行运行<br>总线程数&gt; CPU数量：并发运行</p>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><blockquote>
<p>通过集成Thread来创建线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</div><div class="line">        thread1.start();</div><div class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</div><div class="line">        thread2.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"name:"</span>+name+<span class="string">" 子线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://incdn1.b0.upaiyun.com/2016/08/28c8edde3d61a0411511d3b1866f0636.jpg" alt="运行结果"></p>
<blockquote>
<p>Thread.start()我们可以知道新线程的建立不会阻塞主线程的后续执行<br>Thread.run()并没有建立新的线程，而是在原来的线程上直接运行run方法，跟普通的函数调用没有区别</p>
</blockquote>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID："</span>+Thread.currentThread().getId());</div><div class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程ID："</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以把Runnable接口看成一个子任务，然后把子任务分配给Thread来运行就可以了。</p>
<p>但是不能够直接调用<code>MyRunnable</code>，因为这样实际上没有新建线程，而是在原来的主线程来调用Runnable</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>虽然可以是使用start(),stop(),stop(Throwable),suspend(),destroy(),resume(),但是这些方法只有start()保留下来。<br>SUN公司推荐的代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread blinker; </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; </div><div class="line">        blinker = <span class="keyword">null</span>; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        Thread thisThread = Thread.currentThread(); </div><div class="line">        <span class="keyword">while</span> (blinker == thisThread) &#123; </div><div class="line">            <span class="keyword">try</span> &#123; </div><div class="line">                thisThread.sleep(interval); </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123; </div><div class="line">            &#125; </div><div class="line">            repaint(); </div><div class="line">        &#125; </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当线程处于下面的状况时，属于非运行状态（当sleep方法被调用，当wait方法被调用，当被I/O阻塞，可能是文件或者网络）：<br>可以使用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread tmpBlinker = blinker;</div><div class="line">        blinker = <span class="keyword">null</span>; <span class="keyword">if</span> (tmpBlinker != <span class="keyword">null</span>) &#123;</div><div class="line">           tmpBlinker.interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当interrupt()被调用的时候，InterruptedException将被抛出，所以你可以再run方法中捕获这个异常，让线程安全退出</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   ....</div><div class="line">   wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException iex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Interrupted"</span>,iex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>要点</strong></p>
<blockquote>
<p>如果该线程正阻塞于Object类的wait()、wait(long)、wait(long, int)方法，或者Thread类的join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)方法，则该线程的中断状态将被清除，并收到一个java.lang.InterruptedException<br>interrupted()与isInterrupted()的唯一区别是，前者会读取并清除中断状态，后者仅读取状态。<br>任何时候捕获到InterruptedException，要么继续上抛，要么重置中断状态，这是最安全的做法</p>
</blockquote>
<p><strong>最佳实践：Shared Variable</strong></p>
<p>通过使用violate boolean 变量来标识线程是否停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestPractice</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;   <span class="comment">// ① volatile条件变量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span> </span>&#123;</div><div class="line">        finished = <span class="keyword">true</span>;    <span class="comment">// ② 发出停止信号</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!finished) &#123;    <span class="comment">// ③ 检测条件变量</span></div><div class="line">            <span class="comment">// do dirty work   // ④业务代码</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
    
    </summary>
    
      <category term="操作系统" scheme="https://caixueyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="多线程编程" scheme="https://caixueyuan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Thinking In Java</title>
    <link href="https://caixueyuan.github.io/2017/07/23/Thinking-In-Java/"/>
    <id>https://caixueyuan.github.io/2017/07/23/Thinking-In-Java/</id>
    <published>2017-07-23T15:11:41.000Z</published>
    <updated>2017-07-24T16:08:11.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p><strong>访问控制</strong></p>
<blockquote>
<ul>
<li>第一个存在的原因：让客户端无法触及到程序员他们不能够触及到的部分</li>
<li>第二个存在的原因：允许客户端可以改变内部的工作方式而不是担心会影响到客户端程序员</li>
</ul>
</blockquote>
<p><strong>继承</strong>：使得基类与导出类产生差异</p>
<blockquote>
<ul>
<li>直接在导出类中添加新方法</li>
<li>覆盖Override，改变现有的基类的方法</li>
</ul>
<p>如果只是简单的Override，那么导出类<code>is-a</code>基类<br>如果还添加新方法，那么导出类<code>is-like-a</code>基类</p>
<p>Java中具体类或者抽象类是单根继承结构，但是Java接口确是多根继承结构</p>
</blockquote>
<h3 id="一起都是对象"><a href="#一起都是对象" class="headerlink" title="一起都是对象"></a>一起都是对象</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象导论&quot;&gt;&lt;a href=&quot;#对象导论&quot; class=&quot;headerlink&quot; title=&quot;对象导论&quot;&gt;&lt;/a&gt;对象导论&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;访问控制&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一个存在的原因：让客户端无
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java学习笔记" scheme="https://caixueyuan.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="https://caixueyuan.github.io/2017/07/23/Java%E9%9B%86%E5%90%88/"/>
    <id>https://caixueyuan.github.io/2017/07/23/Java集合/</id>
    <published>2017-07-23T08:10:23.000Z</published>
    <updated>2017-07-23T14:53:18.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="Java中集合的接口的继承关系图"><a href="#Java中集合的接口的继承关系图" class="headerlink" title="Java中集合的接口的继承关系图"></a>Java中集合的接口的继承关系图</h3><p><img src="http://images.cnitblog.com/blog/490648/201308/18174126-653273ab5abe491bb9724353360ed252.png" alt="Java集合"></p>
<p>1,<strong><code>Set</code></strong>:</p>
<p><strong>TreeSet</strong>：在这里是要进行排序的，</p>
<blockquote>
<ul>
<li>自然排序（Comparable）：<br>TreeSet类的add会对对象实例的compareTo()方法和集合中的对象进行比较，根据比较的结果来进行排序</li>
<li>比较器顺序（Comparator）：<br>在外部创建一个比较器来进行比较对象的大小</li>
</ul>
</blockquote>
<p><strong>HashSet</strong>：这是一个实现类</p>
<blockquote>
<ul>
<li>不能够保证元素的排列顺序</li>
</ul>
</blockquote>
<p><strong>LinkedHashSet</strong>：集成于HashSet</p>
<blockquote>
<ul>
<li>能够进行排序（根据hashcode来决定元素的存储位置，同时使用链表维护元素的次序</li>
</ul>
</blockquote>
<p><strong>EnumSet</strong>:专门为枚举类设计，能够枚举各个属性</p>
<p><strong>List接口</strong></p>
<blockquote>
<ul>
<li><strong>ArrayList</strong>:数组（适合随机的set和get）</li>
<li><strong>Vector</strong>：数组，线程安全，但是效率较低</li>
<li><strong>LinkedList</strong>：链表（适合更多的新增或者删除）（是一个双向链表）</li>
</ul>
</blockquote>
<p><strong>Queue</strong>:队列，先进先出</p>
<blockquote>
<ul>
<li>Deque:双端队列，能够在双端中增加或者删除，使用Stack</li>
<li>PriorityQueue:能够进行排序，也是先进先出的。</li>
</ul>
</blockquote>
<p><strong>HashMap</strong>：<br><strong>Hashtable</strong>：</p>
<blockquote>
<ul>
<li>Hashtable在遇到null时，会抛出NullPointException异常</li>
<li>线程安全</li>
<li>通过Initial Capacity和Load Factor两个参数来调整性能，通常来说Load Factor为0.75，较好地实现时间和空间的均衡，增大Load Factor可以节省空间但相应的查找时间会增加<br><strong>HashMap</strong>：</li>
<li>HashMap是支持null键和null值的</li>
<li>线程不安全</li>
<li>将Key做Hash算法，然后将Hash值映射到内存地址，直接取得Key对应的数据</li>
</ul>
</blockquote>
<p><strong>TreeMap</strong>:</p>
<blockquote>
<ul>
<li>按照顺序进行排列（红黑树）</li>
<li>插入和删除比HashMap的效率低一些，但是呢，有序</li>
</ul>
</blockquote>
<p><strong>WeakhashMap</strong>:是一种弄改进的HashMap，对Key实现“弱引用”,如果一个Key不再被外部引用，那么该Key可能被GC回收。如果Key没有其他的引用，那么Map会自动丢弃该值。</p>
<blockquote>
<ul>
<li>特别之处在于WeakHashMap里的Entry可能会被GC自动删除，即使程序员没有调用remove或者clear方法</li>
</ul>
<ul>
<li>可能会出现以下的现象：</li>
</ul>
<p>调用两次size()方法返回不同的值；<br>两次调用isEmpty()方法，第一次返回false，第二次返回true；<br>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；<br>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</p>
</blockquote>
<p>弱引用（WeakReference）：通过GC自动管理，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</p>
<p><strong>LinkedHashMap</strong>:根据元素增加或者访问的先后顺序进行排序，而TreeMap根据元素的Key的大小来进行排序</p>
<h3 id="Java的四种引用："><a href="#Java的四种引用：" class="headerlink" title="Java的四种引用："></a>Java的四种引用：</h3><blockquote>
<ul>
<li>强引用：垃圾收集机制绝不会回收它，当内存空间出现不足，Java虚拟机抛出OutOfMemoryError错误，使得程序异常终止</li>
<li>软引用：内存空间足够，不会回收；内存空间不足，回收</li>
<li>弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
<li>虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</li>
</ul>
</blockquote>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><blockquote>
<ul>
<li><code>expungeStaleEntries</code>:会在大部分共有方法中被调用，将ReferenceQueue中所有的失效的引用从Map中去除</li>
<li>WeakHashMap的Key是弱引用，Value不是。WeakHashMap不会自动释放失效的弱引用，仅当包含了expungeStaleEntries（）的公有方法被调用的时候才会释放</li>
</ul>
</blockquote>
<h3 id="用弱引用堵住内存泄露"><a href="#用弱引用堵住内存泄露" class="headerlink" title="用弱引用堵住内存泄露"></a>用弱引用堵住内存泄露</h3><p>要让垃圾收集（GC）回收程序不再使用的对象，对象的逻辑 生命周期（应用程序使用它的时间）和对该对象拥有的引用的实际 生命周期必须是相同的</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new HashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">    public void removeUser(Socket s) &#123;</div><div class="line">        m.<span class="builtin-name">remove</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">SocketManager socketManager;</div><div class="line">socketManager.setUser(socket, user);</div></pre></td></tr></table></figure>
<p>如果没有显性的删除和增加，那么Socket和User对象都会一直存在于内存中，可能会出现OutOfMemoryError</p>
<p>对于大多数程序来说，可以将内存使用分为两部分：baseline 使用和 current load 使用。对于服务器应用程序，baseline 使用就是应用程序在没有任何负荷、但是已经准备好接受请求时的内存使用，current load 使用是在处理请求过程中使用的、但是在请求处理完成后会释放的内存。只要负荷大体上是恒定的，应用程序通常会很快达到一个稳定的内存使用水平。如果在应用程序已经完成了其初始化并且负荷没有增加的情况下，内存使用持续增加，那么程序就可能在处理前面的请求时保留了生成的对象。</p>
<p>SocketManager 的问题是 Socket-User 映射的生命周期应当与 Socket 的生命周期相匹配。弱引用是对一个对象（称为 referent）的引用的持有者。使用弱引用后，可以维持对 referent 的引用，而不会阻止它被垃圾收集。当垃圾收集器跟踪堆的时候，如果对一个对象的引用只有弱引用，那么这个 referent 就会成为垃圾收集的候选对象，就像没有任何剩余的引用一样，而且所有剩余的弱引用都被清除。（只有弱引用的对象称为弱可及（weakly reachable）。）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new WeakHashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakReference.get() 是否返回 null 来区分死的映射和活的映射.可以通过周期性地扫描 Map，对每一个弱引用调用 get()，并在 get() 返回 null 时删除那个映射而消除死映射</p>
<p>WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射.用引用队列代替定期扫描内容的方法来清理 Map 更有效，因为清理过程不会触及活的项，只有在有实际加入队列的引用时它才工作<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> expungeStaleEntries() &#123;</div><div class="line">Entry&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">while</span> ( (e = (Entry&lt;K,V&gt;) queue.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> hash = e.hash;</div><div class="line">        Entry&lt;K,V&gt; prev = getChain(hash);</div><div class="line">        Entry&lt;K,V&gt; cur = prev;</div><div class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; <span class="keyword">next</span> = cur.<span class="keyword">next</span>;</div><div class="line">            <span class="keyword">if</span> (cur == e) &#123;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    setChain(hash, <span class="keyword">next</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            prev = cur;</div><div class="line">            cur = <span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/index.html" target="_blank" rel="external">具体的链接如下：</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java集合&quot;&gt;&lt;a href=&quot;#Java集合&quot; class=&quot;headerlink&quot; title=&quot;Java集合&quot;&gt;&lt;/a&gt;Java集合&lt;/h2&gt;&lt;h3 id=&quot;Java中集合的接口的继承关系图&quot;&gt;&lt;a href=&quot;#Java中集合的接口的继承关系图&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java基础" scheme="https://caixueyuan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程间通讯</title>
    <link href="https://caixueyuan.github.io/2017/07/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2017/07/19/进程间通讯/</id>
    <published>2017-07-19T15:46:57.000Z</published>
    <updated>2017-07-19T15:48:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><h3 id="1-管道-匿名管道（pipe）"><a href="#1-管道-匿名管道（pipe）" class="headerlink" title="1,管道/匿名管道（pipe）"></a>1,管道/匿名管道（pipe）</h3><blockquote>
<ul>
<li>管道都是半双工，数据只能向一个方向流动</li>
<li>只能用于父子进程或者兄弟进程之间</li>
<li>单独构成一种独立的文件系统（就是有输入输出)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程间通讯&quot;&gt;&lt;a href=&quot;#进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;进程间通讯&quot;&gt;&lt;/a&gt;进程间通讯&lt;/h2&gt;&lt;h3 id=&quot;1-管道-匿名管道（pipe）&quot;&gt;&lt;a href=&quot;#1-管道-匿名管道（pipe）&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/JavaScript学习笔记/</id>
    <published>2017-07-04T15:10:15.000Z</published>
    <updated>2017-07-04T15:10:15.692Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/Spring学习笔记/</id>
    <published>2017-07-04T12:16:49.000Z</published>
    <updated>2017-07-04T12:27:28.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="1，Spring-Security功能性要求："><a href="#1，Spring-Security功能性要求：" class="headerlink" title="1，Spring Security功能性要求："></a>1，Spring Security功能性要求：</h3><blockquote>
<ul>
<li>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问</li>
<li>还能够使用Spring AOP保护方法调用————借助于对象代理和使用通知，能够保护只有具备适当权限的用户才能访问安全保护的方法。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Security&quot;&gt;&lt;a href=&quot;#Spring-Security&quot; class=&quot;headerlink&quot; title=&quot;Spring Security&quot;&gt;&lt;/a&gt;Spring Security&lt;/h2&gt;&lt;h3 id=&quot;1，Spring-Secu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java框架，笔记" scheme="https://caixueyuan.github.io/tags/Java%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP/</id>
    <published>2017-07-03T13:11:49.000Z</published>
    <updated>2017-07-03T13:32:05.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="1，对于告知服务器意图的HTTP方法："><a href="#1，对于告知服务器意图的HTTP方法：" class="headerlink" title="1，对于告知服务器意图的HTTP方法："></a>1，对于告知服务器意图的HTTP方法：</h3><blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<h3 id="2，持久连接节省通信量"><a href="#2，持久连接节省通信量" class="headerlink" title="2，持久连接节省通信量"></a>2，持久连接节省通信量</h3><blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<h3 id="3，使用Cookie的状态管理"><a href="#3，使用Cookie的状态管理" class="headerlink" title="3，使用Cookie的状态管理"></a>3，使用Cookie的状态管理</h3><p>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<h2 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h2></blockquote>
<h3 id="3，编码提升传输速率"><a href="#3，编码提升传输速率" class="headerlink" title="3，编码提升传输速率"></a>3，编码提升传输速率</h3><blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<h3 id="4，发送多种数据的多部分对象集合"><a href="#4，发送多种数据的多部分对象集合" class="headerlink" title="4，发送多种数据的多部分对象集合"></a>4，发送多种数据的多部分对象集合</h3><blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<h3 id="5，获取部分内容的范围请求（Range-Request）"><a href="#5，获取部分内容的范围请求（Range-Request）" class="headerlink" title="5，获取部分内容的范围请求（Range Request）"></a>5，获取部分内容的范围请求（Range Request）</h3><h3 id="6，内容协调Content-Negotiation返回最合适的内容"><a href="#6，内容协调Content-Negotiation返回最合适的内容" class="headerlink" title="6，内容协调Content Negotiation返回最合适的内容"></a>6，内容协调<code>Content Negotiation</code>返回最合适的内容</h3><blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<h2 id="返回结果的HTTP状态"><a href="#返回结果的HTTP状态" class="headerlink" title="返回结果的HTTP状态"></a>返回结果的HTTP状态</h2><h3 id="1，1XX接收的请求正在处理"><a href="#1，1XX接收的请求正在处理" class="headerlink" title="1，1XX接收的请求正在处理"></a>1，1XX接收的请求正在处理</h3><h3 id="2，2XX成功"><a href="#2，2XX成功" class="headerlink" title="2，2XX成功"></a>2，2XX成功</h3><blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<h3 id="3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"><a href="#3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求" class="headerlink" title="3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"></a>3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</h3><blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<h3 id="4-4XX客户端是发生错误的原因"><a href="#4-4XX客户端是发生错误的原因" class="headerlink" title="4,4XX客户端是发生错误的原因"></a>4,4XX客户端是发生错误的原因</h3><blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<h3 id="5，5XX：服务器本身错误"><a href="#5，5XX：服务器本身错误" class="headerlink" title="5，5XX：服务器本身错误"></a>5，5XX：服务器本身错误</h3><blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<h2 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h2><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1,用单台虚拟主机实现多个域名"></a>1,用单台虚拟主机实现多个域名</h3><blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<h3 id="2-通信数据转发程序"><a href="#2-通信数据转发程序" class="headerlink" title="2,通信数据转发程序"></a>2,通信数据转发程序</h3><blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<h3 id="3，保存资源缓存"><a href="#3，保存资源缓存" class="headerlink" title="3，保存资源缓存"></a>3，保存资源缓存</h3><blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="1，HTTP首部字段传递重要信息"><a href="#1，HTTP首部字段传递重要信息" class="headerlink" title="1，HTTP首部字段传递重要信息"></a>1，HTTP首部字段传递重要信息</h3><blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<h2 id="2，HTTP首部字段类型："><a href="#2，HTTP首部字段类型：" class="headerlink" title="2，HTTP首部字段类型："></a>2，HTTP首部字段类型：</h2><blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<h3 id="3，HTTP-1-1通用首部字段"><a href="#3，HTTP-1-1通用首部字段" class="headerlink" title="3，HTTP/1.1通用首部字段"></a>3，HTTP/1.1通用首部字段</h3><blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<h3 id="4，Cookie："><a href="#4，Cookie：" class="headerlink" title="4，Cookie："></a>4，Cookie：</h3><blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<h2 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h2><h3 id="1，HTTP的缺点"><a href="#1，HTTP的缺点" class="headerlink" title="1，HTTP的缺点"></a>1，HTTP的缺点</h3><blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<h3 id="2，HTTPS（加密，认证，完整性保护）"><a href="#2，HTTPS（加密，认证，完整性保护）" class="headerlink" title="2，HTTPS（加密，认证，完整性保护）"></a>2，HTTPS（加密，认证，完整性保护）</h3><blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<h2 id="确保访问用户身份的认证"><a href="#确保访问用户身份的认证" class="headerlink" title="确保访问用户身份的认证"></a>确保访问用户身份的认证</h2><h3 id="1，BASIC认证"><a href="#1，BASIC认证" class="headerlink" title="1，BASIC认证"></a>1，BASIC认证</h3><blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<h3 id="2-DIGEST认证"><a href="#2-DIGEST认证" class="headerlink" title="2,DIGEST认证"></a>2,DIGEST认证</h3><blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<h3 id="3，SSL客户端认证"><a href="#3，SSL客户端认证" class="headerlink" title="3，SSL客户端认证"></a>3，SSL客户端认证</h3><blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<h3 id="4-基于表单认证"><a href="#4-基于表单认证" class="headerlink" title="4,基于表单认证"></a>4,基于表单认证</h3><blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h3><blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<h3 id="WekSocket"><a href="#WekSocket" class="headerlink" title="WekSocket"></a>WekSocket</h3><blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的HTTP协议&quot;&gt;&lt;a href=&quot;#简单的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;简单的HTTP协议&quot;&gt;&lt;/a&gt;简单的HTTP协议&lt;/h2&gt;&lt;h3 id=&quot;1，对于告知服务器意图的HTTP方法：&quot;&gt;&lt;a href=&quot;#1，对于告知
    
    </summary>
    
    
      <category term="网络协议" scheme="https://caixueyuan.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/hello-world/"/>
    <id>https://caixueyuan.github.io/2017/07/03/hello-world/</id>
    <published>2017-07-03T12:45:33.878Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP%20(2)/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP (2)/</id>
    <published>2017-07-02T16:00:00.000Z</published>
    <updated>2017-07-03T13:27:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p>##简单的HTTP协议</p>
<p>###1，对于告知服务器意图的HTTP方法：</p>
<blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<p>###2，持久连接节省通信量</p>
<blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<p>###3，使用Cookie的状态管理<br>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<p>##HTTP报文内的HTTP信息</p>
</blockquote>
<p>###3，编码提升传输速率</p>
<blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<p>###4，发送多种数据的多部分对象集合</p>
<blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<p>###5，获取部分内容的范围请求（Range Request）</p>
<p>###6，内容协调<code>Content Negotiation</code>返回最合适的内容</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<p>##返回结果的HTTP状态</p>
<p>###1，1XX接收的请求正在处理</p>
<p>###2，2XX成功</p>
<blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<p>###3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</p>
<blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<p>###4,4XX客户端是发生错误的原因</p>
<blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<p>###5，5XX：服务器本身错误</p>
<blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<p>##与HTTP协作的Web服务器</p>
<p>###1,用单台虚拟主机实现多个域名</p>
<blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<p>###2,通信数据转发程序</p>
<blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<p>###3，保存资源缓存</p>
<blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<p>##HTTP首部</p>
<p>###1，HTTP首部字段传递重要信息</p>
<blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<p>##2，HTTP首部字段类型：</p>
<blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<p>###3，HTTP/1.1通用首部字段</p>
<blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<p>###4，Cookie：</p>
<blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<p>##确保Web安全的HTTPS</p>
<p>###1，HTTP的缺点</p>
<blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<p>###2，HTTPS（加密，认证，完整性保护）</p>
<blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<p>##确保访问用户身份的认证</p>
<p>###1，BASIC认证</p>
<blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<p>###2,DIGEST认证</p>
<blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<p>###3，SSL客户端认证</p>
<blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<p>###4,基于表单认证</p>
<blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<p>##基于HTTP的功能追加协议</p>
<p>###HTTP的瓶颈：</p>
<blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<p>###WekSocket</p>
<blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
