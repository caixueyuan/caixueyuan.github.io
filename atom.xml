<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2019-08-11T16:57:58.598Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++类的使用</title>
    <link href="https://caixueyuan.github.io/2019/08/08/C-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2019/08/08/C-类的使用/</id>
    <published>2019-08-08T15:22:58.000Z</published>
    <updated>2019-08-11T16:57:58.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h2><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p><img src="调用复制构造函数.png" alt="1565278116357"></p>
<p>复制构造函数是要通过复制类来实现新建类。</p>
<p><strong>默认的复制构造函数是浅复制，也就是只复制字面性变量，不复制指针类型，所以这里一定要注意一种错误，就是容易导致多个变量析构同一块内存导致报错误。</strong></p>
<p><img src="复制构造函数.png" alt="1565277907579"></p>
<p>上图为深复制，也就是对于指针类型所指定的对象也能够实现复制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> StringBad temp)</span></span>;<span class="comment">//这样的传值函数也是使用传值，也就是要变成</span></div><div class="line">StringBad input;</div><div class="line">show(input);<span class="comment">//void show()&#123; StringBad temp = input;&#125;调用了复制构造函数</span></div></pre></td></tr></table></figure>
<h3 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">"message"</span>)</span></span>;</div><div class="line">StringBad knot;</div><div class="line">knot = headline1;<span class="comment">//这里使用的是赋值构造函数，因为对于knot已经进行初始化，已经有一块内存啦，只是将headline1的内容赋值给knot内存而已</span></div><div class="line">StringBad metto = knot;<span class="comment">//对于这里，metto本身是没有内存的，所以这个时候需要初始化一块内存出来，所以这里使用的是复制构造函数，复制一块内存来构造对象</span></div><div class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个引用，赋值构造函数</span></div><div class="line">StringBad::StringBad(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个对象，是复制构造函数</span></div></pre></td></tr></table></figure>
<p><strong>复制构造函数</strong>：返回一个对象，也就是一块内存</p>
<p><strong>赋值构造函数</strong>：返回一个引用，并没有多出一块内存，只是将旧内存赋值给新内存而已</p>
<h3 id="使用复制构造函数和赋值析构函数的时机"><a href="#使用复制构造函数和赋值析构函数的时机" class="headerlink" title="使用复制构造函数和赋值析构函数的时机"></a>使用复制构造函数和赋值析构函数的时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Star sirius;</div><div class="line">Star copy = sirius;<span class="comment">//复制构造函数</span></div><div class="line">Star assignment;</div><div class="line">assignment = sirius;<span class="comment">//赋值构造函数</span></div></pre></td></tr></table></figure>
<p><code>Star copy = sirius;</code>这里是由于类没有被初始化，所以需要new出来一个对象，这个时候需要调用复制构造函数</p>
<p><code>assignment = sirius;</code>这里是因为类已经被初始化，内存空间已经存在，只是将其他对象的值复制到当前对象中，所以这个时候调用的是赋值构造函数</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>如果要把临时对象返回，要返回对象而不是引用或者指针。因为临时对象会被析构</li>
<li>new和delete对应，new[] 和 delete[]，一定要注意，delete[] 是delete多对象，包含了char * temp = “abc”这种情况</li>
</ol>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><h3 id="派生类的调用"><a href="#派生类的调用" class="headerlink" title="派生类的调用"></a>派生类的调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tabtenn1.h -- a table-tennis base class</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="comment">// simple base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> firstname;</div><div class="line">    <span class="built_in">string</span> lastname;</div><div class="line">    <span class="keyword">bool</span> hasTable;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// simple derived class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                 <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123;rating = r;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">TableTennisPlayer parent;</div><div class="line">parent.Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer son;</div><div class="line">son.Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//对于引用和指针都是一样的情况，只会根据静态类型来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer *son1 = <span class="keyword">new</span> RatedPlayer();</div><div class="line">son1-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//如果对于父类的Name函数的定义为virtual void Name() const;会根据类的动态类型（实际类型）来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div></pre></td></tr></table></figure>
<ol>
<li><strong>如果是对象的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果是引用或者指针的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果使用virtual的话，将根据指针或者引用所对应的实际类型来调用函数</strong></li>
</ol>
<h3 id="继承中基类和派生类："><a href="#继承中基类和派生类：" class="headerlink" title="继承中基类和派生类："></a>继承中基类和派生类：</h3><p>构造函数不能够为虚函数，而析构函数应是虚函数，除非类不能够做基类。基类要保证基类中的成员变量能够被正常析构，派生类也要保证派生类中的成员变量能够被正常析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * base1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Base()&#123;<span class="keyword">delete</span>[] base1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * derived1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Derived()&#123;<span class="keyword">delete</span>[] derived1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//基类要保证基类的成员变量被析构，派生类要保证派生类中的成员变量被析构</span></div></pre></td></tr></table></figure>
<p>在派生类中定义类的话，要确定是使用父类还是子类的函数，通过作用域来进行获取。</p>
<p>最好要对类数据成员采用私有访问控制private，不要使用保护控制控制protected，同时通过基类方法使得派生类能够访问到基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//最好使用这一种</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBase1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> base1;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>友元函数并非是类的成员函数，不能够被继承</strong></p>
<h3 id="什么样的成员变量要被析构掉"><a href="#什么样的成员变量要被析构掉" class="headerlink" title="什么样的成员变量要被析构掉"></a>什么样的成员变量要被析构掉</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * label;</div><div class="line">    <span class="keyword">char</span> message[<span class="number">100</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>成员变量label是指针，其对象是被new出来的，指针所指的对象是在堆中，需要被析构掉</p>
<p>成员变量message是数组，其对象不是被new出来的，对象所存在的内存空间是在栈中，不需要被析构，可以被C++自动析构掉。</p>
<h3 id="派生类的使用"><a href="#派生类的使用" class="headerlink" title="派生类的使用"></a>派生类的使用</h3><p><strong>当初始化列表包含多个项目时，这些项目的初始化顺序时跟类的声明顺序保持一致，而不是在初始化列表中的顺序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> m_a;</div><div class="line">    <span class="keyword">int</span> m_b;</div><div class="line">    <span class="keyword">int</span> m_c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base(<span class="keyword">int</span> a,<span class="keyword">int</span> c,<span class="keyword">int</span> b):m_c(c),m_b(b),m_a(a)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用using来重新定义访问权限</strong></p>
<p>在访问基类的成员函数时，我们需要使用<code>std::valarray&lt;double&gt;::min()</code>来调用基类的成员函数的，但是如果我们使用了using来将基类的成员函数引入到派生类中，这样我们可以像使用派生类的成员函数一样使用基类的成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用using的方式将基类的成员函数引入到当前类中，这样就能够像使用当前类的成语函数一样去使用基类的成员函数</p>
<h3 id="类的静态成员变量或者静态成语函数"><a href="#类的静态成员变量或者静态成语函数" class="headerlink" title="类的静态成员变量或者静态成语函数"></a>类的静态成员变量或者静态成语函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> Base::a = <span class="number">1</span>;<span class="comment">//正确，初始化类的静态成员变量的时候不需要考虑访问权限</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; Base::a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//错误，访问静态成员变量的时候还是要考虑访问权限的</span></div></pre></td></tr></table></figure>
<ol>
<li>不能通过类名来调用类的非静态成员函数</li>
<li>类的对象能够使用静态成员函数和非静态成员函数</li>
<li>静态成员函数不能够引用非静态成员函数</li>
<li>类的非静态成员函数可以调用静态成员函数</li>
</ol>
<p><strong>原因：</strong></p>
<p>首先，类的静态函数是属于类的，类在没有初始化的时候就应该有的，所以类的静态函数不能够引用类的非静态成员函数，因为在类未初始化之前还没有非静态成员函数，如果调用非静态成员就会报错</p>
<p>类的非静态成员函数在调用时，这时类的静态成员函数早已经可用啦，所以能够调用</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&#123;</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;<span class="comment">//会报错误</span></div><div class="line"></div><div class="line"><span class="comment">//使用虚继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;</div><div class="line"><span class="comment">//构造函数</span></div><div class="line">SingerWaiter::SingerWaiter(<span class="keyword">const</span> Worker &amp;wt):Worker(wt),Singer(wt),Waiter(wt)&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>报错误的原因</strong>：</p>
<p>如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例，也就是说从Singer和Waiter两个基类中继承了两个Worker，多个基类实例都是问题</p>
<p><strong>采用虚继承</strong>：</p>
<p>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数</p>
<p>通过优先规则来解决二义性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类和动态内存分配&quot;&gt;&lt;a href=&quot;#类和动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;类和动态内存分配&quot;&gt;&lt;/a&gt;类和动态内存分配&lt;/h2&gt;&lt;h3 id=&quot;复制构造函数&quot;&gt;&lt;a href=&quot;#复制构造函数&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础命令</title>
    <link href="https://caixueyuan.github.io/2019/08/06/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://caixueyuan.github.io/2019/08/06/Linux基础命令/</id>
    <published>2019-08-05T16:23:23.000Z</published>
    <updated>2019-08-18T16:43:17.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux用户管理"><a href="#linux用户管理" class="headerlink" title="linux用户管理"></a>linux用户管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>新增用户</div><div class="line">useradd -m cxy -d /home/cxy -g group -u uid</div><div class="line"><span class="meta">#</span>修改用户的根目录</div><div class="line">usermod -d /home/cxy_new -m cxy</div><div class="line"><span class="meta">#</span>锁住用户</div><div class="line">usermod -L cxy</div><div class="line"><span class="meta">#</span>解锁用户</div><div class="line">usermod -U cxy</div><div class="line"><span class="meta">#</span>删除用户</div><div class="line">userdel cxy</div><div class="line"><span class="meta">#</span>添加用户组</div><div class="line">groupadd group1</div><div class="line"><span class="meta">#</span>删除用户组</div><div class="line">groupdel group1</div><div class="line"><span class="meta">#</span>查看用户的详细信息</div><div class="line">w</div><div class="line"><span class="meta"></span></div><div class="line">#查看定时任务后台程序是否启动</div><div class="line">systemctl | grep cron</div><div class="line">systemctl | grep crond</div><div class="line"><span class="meta">#</span>将定时任务加入到前台程序中</div><div class="line">crontab job1.cron</div><div class="line"><span class="meta">#</span>查看程序中的定时任务</div><div class="line">crontab -l</div><div class="line"><span class="meta">#</span>查看程序中的定时任务</div><div class="line">crontab -r</div><div class="line"><span class="meta">#</span>只能够有一个定时任务</div></pre></td></tr></table></figure>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>查看目录下所有问题，包括隐藏文件</div><div class="line">ls -la</div><div class="line"><span class="meta">#</span>加上-n参数可以显示每行的行数</div><div class="line">cat -n file.log</div><div class="line"><span class="meta">#</span>查看文件的头20行</div><div class="line">head -n 20 file.log</div><div class="line"><span class="meta">#</span>查看文件的尾20行</div><div class="line">tail -n 20 file.log</div><div class="line"><span class="meta">#</span>动态查看文件的尾部10行</div><div class="line">tail -f file.log</div><div class="line"><span class="meta">#</span>将window文件转换为linux文件</div><div class="line">dos2unix file.log</div><div class="line"><span class="meta">#</span>创建目录</div><div class="line">mkdir -p /opt/oss/caixueyuan</div></pre></td></tr></table></figure>
<h3 id="文件和目录的权限"><a href="#文件和目录的权限" class="headerlink" title="文件和目录的权限"></a>文件和目录的权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>设置文件为隐藏文件</div><div class="line">chattr +a a.log</div><div class="line"><span class="meta">#</span>设置文件为非隐藏文件</div><div class="line">chattr -a a.log</div><div class="line"><span class="meta">#</span>设置SUID权限，这样普通用户可以使用root的身份来执行这个命令</div><div class="line">chmod u+s filename</div><div class="line"><span class="meta">#</span>which用于从系统的PATH变量所定义的目录中查找可执行文件的绝对路径</div><div class="line">which filename</div><div class="line"><span class="meta">#</span>whereis用于从系统的PATH变量所定义的目录中查找二进制文件和man文件</div><div class="line">whereis filename</div><div class="line"><span class="meta">#</span>指定解压后的位置</div><div class="line">tar -zxvf boot.tgz -C /tmp</div></pre></td></tr></table></figure>
<p><strong>find命令</strong></p>
<p><img src="find.png" alt="1565195424826"></p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包括</p>
<ol>
<li>超级块：文件系统的总体信息，是文件系统的核心，有多个超级块，以防止由于磁盘出现坏块导致全部文件系统无法使用</li>
<li>inode：存储所有与文件有关的元数据，也就是文件所有者，权限等属性数据以及指向的数据块</li>
<li>数据块：真实存放文件数据的部分</li>
<li>目录块：包括文件名和文件在目录中的位置，并包括文件的inode信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>进行磁盘划分</div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span>格式化磁盘,</div><div class="line">mkfs -t ext3 /dev/sdb1</div><div class="line"><span class="meta">#</span>将DEVICE挂载到DEVICE_POINT上</div><div class="line">mount DEVICE DEVICE_POINT</div><div class="line">mount /dev/sdb1 newDirectory</div><div class="line"><span class="meta">#</span>查看可用空间</div><div class="line">df -h | grep sdb1</div><div class="line"><span class="meta">#</span>设置启动自动挂载/etc/fstab</div><div class="line">echo "/dev/sdb1 /root/newDisk ext3 default 0 0" &gt;&gt; /etc/fstab</div><div class="line"><span class="meta">#</span>检查修复磁盘出现逻辑错误，要保证磁盘为未挂载的状态</div><div class="line">fsck -t ext4 /dev/sda8</div><div class="line"><span class="meta">#</span>卸载磁盘</div><div class="line">unmount /dev/sdb1</div><div class="line"><span class="meta">#</span>检查磁盘的物理坏道</div><div class="line">badblocks -v /dev/sdb1</div></pre></td></tr></table></figure>
<p>将一块磁盘挂载到操作系统的步骤：先对磁盘进行划分，将磁盘格式化，刷进去文件系统，然后将磁盘挂载到操作系统中，然后将挂载操作设置为开机自启动</p>
<h3 id="逻辑卷（Logic-Volume-Manager）"><a href="#逻辑卷（Logic-Volume-Manager）" class="headerlink" title="逻辑卷（Logic Volume Manager）"></a>逻辑卷（Logic Volume Manager）</h3><p><strong>LVM</strong>是介于硬盘裸设备和文件系统的中间层</p>
<ol>
<li><strong>物理卷（Physical Volumn,PV)</strong>：物理磁盘分区，比如/dev/sdb1</li>
<li><strong>卷组（Volumn Group,VG)</strong>:PV的集合</li>
<li><strong>逻辑卷（Logic Volume,LV)</strong>:PV中划出来的一块逻辑磁盘</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>创建物理卷pvcreate,pvdisplay</div><div class="line">fdisk -l</div><div class="line">fdisk /dev/sdb  n</div><div class="line"><span class="meta">#</span>设置物理卷的Id为8e</div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span>现在已经有磁盘，从磁盘创建出物理卷</div><div class="line">pvcreate /dev/sdb1</div><div class="line"><span class="meta">#</span>将逻辑卷组成一个物理卷组</div><div class="line">vgcreate First_LV /dev/sdb1 /dev/sdb2</div><div class="line"><span class="meta">#</span>扩展物理卷组，加入一个新的物理卷</div><div class="line">pvextend First_LV /dev/sdb3</div><div class="line"><span class="meta">#</span>创建逻辑卷lvcreate</div><div class="line">lvcreate -L 100M -n sdb First_VG</div><div class="line"><span class="meta">#</span>创建文件系统</div><div class="line">mkfs -t ext4 /dev/First_LV/First_VG</div><div class="line"><span class="meta">#</span>进行挂载</div><div class="line">mount /dev/First_LV/First_VG /root/cxy</div></pre></td></tr></table></figure>
<p><img src="修改分区代码.png" alt="1565714641249"></p>
<h3 id="硬链接和软连接"><a href="#硬链接和软连接" class="headerlink" title="硬链接和软连接"></a>硬链接和软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>查看文件的说明</div><div class="line">ls -li</div><div class="line"><span class="meta">#</span>创建硬链接</div><div class="line">ln file.txt file.hard_txt</div><div class="line"><span class="meta">#</span>创建软连接</div><div class="line">ln -s file.txt file.soft_txt</div></pre></td></tr></table></figure>
<p><img src="硬链接.png" alt="1565885043739"></p>
<p>该详细信息中的第三列中的<strong>2</strong>的意思为源文件的关联个数，也就是该文件所包含的硬链接的个数</p>
<p><strong>硬链接</strong>:通过索引节点来链接，一个文件可以有多个文件名，多个文件名指向同一个inode是可以的</p>
<p><strong>软连接</strong>：是一个包含了另外一个文件路径名的文件，可以指向任意文件或者目录，可以跨不同的文件系统</p>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><p>固定大小的缓存，缓存的大小为4KByte。符号为”|”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/init.d | more</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>grep [-ivnc] '需要匹配的字符' 文件名</div><div class="line"><span class="meta">#</span>-i不区分大小写</div><div class="line"><span class="meta">#</span>-v反向查找</div><div class="line"><span class="meta">#</span>-n查找并获取行号</div><div class="line"><span class="meta">#</span>-c统计需要匹配的字符的个数</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>sort [-ntkr] 文件名</div><div class="line"><span class="meta">#</span>-n按照数字来排列，而不是按照字符，默认是按照字符</div><div class="line"><span class="meta">#</span>-t指定分隔符grep -t ":" -k 2 file.txt</div><div class="line"><span class="meta">#</span>-k指定是按照第几列来排序</div><div class="line"><span class="meta">#</span>-r反向排序</div><div class="line">grep -t ":" -k 2 file.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>uniq [-ic]</div><div class="line"><span class="meta">#</span>-i忽略大小写</div><div class="line"><span class="meta">#</span>-c统计不同字符的个数</div><div class="line">cat file.txt | sort | uniq -c</div></pre></td></tr></table></figure>
<p>使用uniq一般情况下都是跟sort进行使用，因为uniq只会比较跟相邻位置的字符是否相同</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>cut -f指定的列 -d '分隔符'</div><div class="line"><span class="meta">#</span>查看file.txt文件，以:为分隔符，获取第1，6和7列</div><div class="line">cat file.txt | cut -f1,6-7 -d ':'</div><div class="line"><span class="meta">#</span>查看file.txt文件，获取第1-5个字符和第7-10个字符</div><div class="line">cat file.txt | cut -c1-5,7-10</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>tr命令使用</div><div class="line"><span class="meta">#</span>小写转为大小</div><div class="line">cat file.txt | tr '[a-z]' '[A-Z]'</div><div class="line"><span class="meta">#</span>删除字符:</div><div class="line">cat file.txt | tr -d ':'</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>paste合并文件</div><div class="line"><span class="meta">#</span>将1.txt和2.txt文件按照行进行合并，中间用tab分割</div><div class="line">paste 1.txt 2.txt</div><div class="line">paste 1.txt 2.txt -d :</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>split分割文件</div><div class="line"><span class="meta">#</span>以500行为一个文件进行分割</div><div class="line">split -l 500 big.txt small_file_</div><div class="line"><span class="meta">#</span>以大小进行划分</div><div class="line">split -b 64M big.bin small_file_</div></pre></td></tr></table></figure>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>查看和设置网络网卡</div><div class="line">ifconfig</div><div class="line"><span class="meta">#</span>启停网卡</div><div class="line">ifup eth0</div><div class="line">ifdown eth0</div><div class="line">ifconfig eth0 down</div><div class="line">ifconfig eth0 up</div><div class="line"><span class="meta">#</span>重启网络服务</div><div class="line">service network restart</div><div class="line"><span class="meta">#</span>查看系统当前的路由</div><div class="line">route -n</div><div class="line"><span class="meta">#</span>traceroute查看请求所经过的路由器的路径</div><div class="line">traceroute 14.215.177.38</div></pre></td></tr></table></figure>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>ps </div><div class="line"><span class="meta">#</span>-A 列出所有的进程</div><div class="line"><span class="meta">#</span>-a 列出不和本终端有关的所有进程</div><div class="line"><span class="meta">#</span>-aux显示所有其他包含其他使用者的进程</div><div class="line"><span class="meta">#</span>RSS 显示进程占用的内存的大小</div><div class="line"><span class="meta">#</span>VSZ 显示进程占用的虚拟内存的大小</div><div class="line"><span class="meta">#</span>查看进程号</div><div class="line">pidof Nemgr</div><div class="line"><span class="meta">#</span>kill</div><div class="line">kill -9 1001#强制停止进程，并没有释放内存</div><div class="line">kill -15 1001#使进程正常退出</div><div class="line"><span class="meta">#</span>lsof 查看进程打开的文件</div><div class="line">lsof -p pid</div><div class="line">lsof -i:22</div><div class="line"><span class="meta">#</span>nice，renice修改进程的优先级</div><div class="line">nice -n -10 ./run.sh</div><div class="line">renice -10 -p pid</div></pre></td></tr></table></figure>
<p><img src="top.png" alt="1566142036437"></p>
<p><img src="top1.png" alt="1566142284292"></p>
<h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><p><img src="/rpm.png" alt="1566144649678"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>rpm安装软件</div><div class="line">rpm -ivh packege.rpm</div><div class="line"><span class="meta">#</span>安装软件包，并重新定义安装路径</div><div class="line">rpm -ivh --relocate /=/usr/local/package_name package_name-version.rpm</div><div class="line"><span class="meta">#</span>升级软件包</div><div class="line">rpm -Uvh package_name-version.rpm</div><div class="line"><span class="meta">#</span>删除软件</div><div class="line">rpm -e package_name --nodeps</div><div class="line"><span class="meta">#</span>查看系统中所有已经安装的包</div><div class="line">rpm -qa</div><div class="line"><span class="meta">#</span>查看某个包的依赖关系</div><div class="line">rpm -qpR package_name-version.rpm</div><div class="line"><span class="meta">#</span>yum安装操作</div><div class="line">yum install package</div><div class="line"><span class="meta">#</span>更新系统中所有需要更新的包</div><div class="line">yum update</div><div class="line"><span class="meta">#</span>查找操作</div><div class="line">yum list</div><div class="line">yum list installed</div><div class="line">yum info package</div><div class="line"><span class="meta">#</span>删除操作</div><div class="line">yum remove package</div><div class="line"><span class="meta">#</span>清除操作</div><div class="line">yum clean</div><div class="line">yum clean all &amp;&amp; yum makecache</div></pre></td></tr></table></figure>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shift+$</td>
<td>到当前行的末尾</td>
</tr>
<tr>
<td>u</td>
<td>撤销操作</td>
</tr>
<tr>
<td>:n</td>
<td>跳转到第n行</td>
</tr>
<tr>
<td>p</td>
<td>黏贴</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做操作</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
</tbody>
</table>
<p><img src="替换用法.png" alt="1566146582848"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;linux用户管理&quot;&gt;&lt;a href=&quot;#linux用户管理&quot; class=&quot;headerlink&quot; title=&quot;linux用户管理&quot;&gt;&lt;/a&gt;linux用户管理&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++PrimePlus第9章</title>
    <link href="https://caixueyuan.github.io/2019/08/04/C-PrimePlus%E7%AC%AC10%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/08/04/C-PrimePlus第10章/</id>
    <published>2019-08-04T03:29:08.000Z</published>
    <updated>2019-08-08T15:22:27.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><h3 id="include的使用"><a href="#include的使用" class="headerlink" title="#include的使用"></a>#include的使用</h3><ol>
<li><p><code>#include&lt;iostream&gt;</code>如果文件包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找</p>
</li>
<li><p><code>#include&quot;stdio.h&quot;</code> 如果文件是包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录，如果没有的话，则在标准位置中查找</p>
</li>
<li><p>在编码的过程中，不要使用#include一个CPP代码，会导致多重定义</p>
</li>
<li><p>尽量使用这种方式来定义头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> CORRORDIN_H_</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h3><p><strong>概念</strong>：</p>
<ol>
<li>定义是有分配存储空间的，只能够定义一次<code>int a;</code></li>
<li>声明是引用声明，不用给变量分配存储空间，可以多次被引用<code>a=1;</code></li>
</ol>
<h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>主要分为两种：</p>
<ol>
<li>外部链接性：不只是当前文件可以使用，其他别的文件也可以引用声明到</li>
<li>内部链接性：一般都是静态变量，只能够在当前文件中使用，其他别的文件不能够引用声明到</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> external = <span class="number">10</span>;<span class="comment">//外部链接性，在当前文件中定义，其他文件如果要使用该变量，必须加上extern int external;进行引用声明</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> inside = <span class="number">11</span>;<span class="comment">//内部链接性，因为是内部链接性，只在当前的文件中起作用，不用担心跟其他文件的全局变量冲突</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count;<span class="comment">//局部变量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count1;<span class="comment">//作用域还是在该代码块中，但是呢，每次运行该代码块该变量都会一致存在，跟全局变量没啥子区别，就是声明作用域小了一些</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_number=<span class="number">0</span>;<span class="comment">//内部链接性，由const定义的变量都不是外部链接性</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_number1=<span class="number">10</span>;<span class="comment">//如果想使用外部链接性的const变量的话，就要加上extern进行定义。但是呢，一般情况下，如果想使用外部链接性的const变量，可以将变量定义在头文件中，然后使用#include"header.h"将变量加入到该文件中比较好</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//函数默认是外部链接性，其他文件默认就可以引用到</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//static修饰的函数为内部链接性，只能够在本文件中使用</span></div></pre></td></tr></table></figure>
<h3 id="语句链接性："><a href="#语句链接性：" class="headerlink" title="语句链接性："></a>语句链接性：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C语句获取函数描述符号去查找函数</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C++语句获取函数描述符号去查找函数</span></div></pre></td></tr></table></figure>
<h3 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//这种是using编译指令</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//使用using声明</span></div><div class="line"><span class="keyword">namespace</span> MEF= <span class="built_in">std</span>;<span class="comment">//有些时候可以使用名称空间别名的方式来缩短名称空间</span></div></pre></td></tr></table></figure>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p><strong>const和mutable</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></div><div class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;<span class="comment">//可以修改，不受const的限制</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">"abc"</span>,<span class="number">1</span>&#125;;</div><div class="line">veep.name = <span class="string">""</span>;<span class="comment">//错误，不能够修改</span></div><div class="line">veep.accesses = <span class="number">1</span>;<span class="comment">//可以修改</span></div></pre></td></tr></table></figure>
<p><strong>函数搜索顺序</strong>：</p>
<p>首先是本文件，然后才是程序员编写的其他的文件，然后再是库函数。所以有些时候可以使用覆盖的方式来覆盖库函数来实现比库函数更多的功能。</p>
<p><strong>const函数</strong>：</p>
<p>void stock::show() const一般在不修改类的成员变量的时候都要将函数声明为const，这样可以起到保护类的成员变量的作用</p>
<h2 id="类的声明和使用"><a href="#类的声明和使用" class="headerlink" title="类的声明和使用"></a>类的声明和使用</h2><h3 id="作用域为类的常量的方法"><a href="#作用域为类的常量的方法" class="headerlink" title="作用域为类的常量的方法"></a>作用域为类的常量的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是错误的，因为声明只是描述对象形式，并没有创建对象，所以在创建对象之前，并没有用于存储对象的空间，而const int Months = 12;在运行的时候就需要空间进行存储空间，所以这种的对象声明是错误</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span>&#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用这种方法声明枚举的时候并不会创建类数据成员，所有对象都不包含枚举，Months只是一个符号名称，在声明的时候不需要空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该变量将于其他静态静态变量一样，在运行的时候存放在文件中</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>A = B <em> 1.0;//可以使用成员函数来调用 `A = B.operator</em>(1.0)`</p>
<p>A = 1.0 * B;//由于1在前面，不能够使用成员函数的方式来实现，所以只能够使用非成员函数的方式来使用<code>A = operator&lt;&lt;(1.0,B)</code></p>
<p><strong>友元函数的好处</strong>：本身不是成员函数，而是一个普通函数，不属于类，而又能够跟成员函数一样访问类的内部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MyTime.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> hours;</div><div class="line">    <span class="keyword">int</span> minutes;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Time();</div><div class="line">    Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m = <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</div><div class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)</div><div class="line">        &#123; <span class="keyword">return</span> t * m; &#125;   <span class="comment">// inline definition</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//MyTime.cpp</span></div><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">" minutes"</span>;</div><div class="line">    <span class="keyword">return</span> os; </div><div class="line">&#125;<span class="comment">//返回一个引用，重载运算符，第一个参数不是该成员</span></div></pre></td></tr></table></figure>
<h3 id="隐形转换和显性转换"><a href="#隐形转换和显性转换" class="headerlink" title="隐形转换和显性转换"></a>隐形转换和显性转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONEWT_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STONEWT_H_</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stonewt</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span> &#123;Lbs_per_stn = <span class="number">14</span>&#125;;      <span class="comment">// pounds per stone</span></div><div class="line">    <span class="keyword">int</span> stone;                    <span class="comment">// whole stones</span></div><div class="line">    <span class="keyword">double</span> pds_left;              <span class="comment">// fractional pounds</span></div><div class="line">    <span class="keyword">double</span> pounds;                <span class="comment">// entire weight in pounds</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Stonewt(<span class="keyword">double</span> lbs);          <span class="comment">// constructor for double pounds</span></div><div class="line">    Stonewt(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs); <span class="comment">// constructor for stone, lbs</span></div><div class="line">    Stonewt();                    <span class="comment">// default constructor</span></div><div class="line">    ~Stonewt();</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in pounds format</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in stone format</span></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">Stonewt myCat;</div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//OK，类的隐形转换</span></div><div class="line"><span class="comment">//如果使用explicit来禁止隐形转换的话，也就是用explicit Stonewt(double lbs);的话</span></div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//错误，因为禁止了隐形转换</span></div><div class="line">myCat = (Stonewt) <span class="number">19.6</span>;<span class="comment">//OK,因为是显性转换</span></div></pre></td></tr></table></figure>
<p><strong>转换函数</strong>：就是将之前的Stonewt转换为double类型等。如<code>operator int() const</code>或者<code>operator double() const</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</div><div class="line"><span class="keyword">double</span> host = <span class="keyword">double</span>(wolfe);<span class="comment">//将wolfe转换为double类型</span></div><div class="line"><span class="keyword">double</span> host = wolfe;<span class="comment">//显性</span></div><div class="line"><span class="keyword">double</span> host = (<span class="keyword">double</span>) wolfe;<span class="comment">//显性</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：最好少用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存模型和名称空间&quot;&gt;&lt;a href=&quot;#内存模型和名称空间&quot; class=&quot;headerlink&quot; title=&quot;内存模型和名称空间&quot;&gt;&lt;/a&gt;内存模型和名称空间&lt;/h2&gt;&lt;h3 id=&quot;include的使用&quot;&gt;&lt;a href=&quot;#include的使用&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime Plus第9章</title>
    <link href="https://caixueyuan.github.io/2019/07/31/C-Prime-Plus%E7%AC%AC9%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/31/C-Prime-Plus第9章/</id>
    <published>2019-07-30T16:02:06.000Z</published>
    <updated>2019-07-30T16:25:28.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>重载</strong>：</p>
<ol>
<li>重载不区分const和非const变量</li>
<li>重载不区分引用和非引用</li>
<li>重载不区分返回值</li>
</ol>
<p><strong>模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>;<span class="comment">//常规模板</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job&amp; a,job&amp; b);<span class="comment">//具体化</span></div></pre></td></tr></table></figure>
<p>具体函数优于具体化，优于常规模板</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重载不区分const和非const变量&lt;/li&gt;
&lt;li&gt;重载不区分引用
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C语句编译与链接</title>
    <link href="https://caixueyuan.github.io/2019/07/25/C%E8%AF%AD%E5%8F%A5%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>https://caixueyuan.github.io/2019/07/25/C语句编译与链接/</id>
    <published>2019-07-25T15:17:34.000Z</published>
    <updated>2019-07-30T16:01:06.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="运行库.png" alt="1564068683784"></p>
<p><strong>操作系统应用程序编程接口</strong>：应用程序的接口的提供者是运行库（Runtime Library），运行库使用操作系统提供的系统调用接口。</p>
<p><strong>直接使用物理内存的坏处</strong>：</p>
<ol>
<li>地址空间不连续</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p><strong>使用虚拟地址</strong>：</p>
<p><img src="虚拟地址.png" alt="1564069609677"></p>
<p>程序只能够访问到虚拟地址，不感知物理地址，一个程序可以分为好多段，好多页，页分为虚拟页，物理页和磁盘页。程序访问的是虚拟地址，如果虚拟地址映射的物理页不在物理内存中，会出现缺页中断，由操作系统进行接管，来处理缺页中断，所以呢，程序并不感知物理地址。</p>
<p>用户线程和内核线程并不总是一对一，又可能是多对一或者是多对多。</p>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p><img src="编译链接过程.png" alt="1564071456112"></p>
<p>预处理（processing)，编译（Compilation），汇编（Assembled），链接（Linking）</p>
<p><strong>预编译</strong>：</p>
<ol>
<li>展开所有的宏定义”#define”</li>
<li>处理所有条件预编译指令,”#if”,”#ifdef”,”elif”,”#else”,”#endif”</li>
<li>处理”#include”预编译指令，递归地将包含的文件插入到该编译指令的位置</li>
<li>删除所有的注释</li>
<li>添加行号和文件名标识</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E main.c -o main.i</div></pre></td></tr></table></figure>
<p><strong>编译</strong>：</p>
<p>将预编译之后的代码进行编译，得到汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -s main.i -o main.s</div></pre></td></tr></table></figure>
<p><strong>汇编</strong>：</p>
<p>将汇编代码转换为机器指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c main.s -o main.o</div></pre></td></tr></table></figure>
<p><strong>链接</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o -L /usr/lib/gcc/i486-linux-gnu/4.1.3 -L /usr/lib/ -L /lib hello.o --start-group -lgcc -l gcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o /usr/lib/crtn/o</div></pre></td></tr></table></figure>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="编译过程.png" alt="1564147367310"></p>
<ol>
<li><strong>词法</strong>：lex程序，将源代码的字符序列分割成一系列的记号</li>
<li><strong>语法分析</strong>：根据记号进行分析，产生语法树</li>
<li><strong>语义分析</strong>：分为静态语义和动态语义，对语法树中进行标识</li>
<li><strong>中间代码生成</strong>：将语法树转为中间代码。中间代码使得编译器可以被分为前端和后端，前端可以负责产生机器无关的中间代码，后端将中间代码转换为目标机器代码。<strong>三地址码</strong>：就是对于中间代码，操作都是三个地址+一个操作</li>
<li><strong>目标代码生成与优化</strong>：通过代码生成器来生成目标机器代码</li>
</ol>
<h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p><strong>符号</strong>：用来表示一个地址，这个地址可以是一个子程序的起始地址，也可以是变量的起始地址。    </p>
<p>链接的主要内容是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正常链接好，“程序员人工调整地址”，包括地址和空间分配，符号决议和重定位。</p>
<p><strong>静态链接</strong>：每次函数调用都必须确切知道函数的地址，但是由于每个模块都是单独编译的，在编译器编译的时候并不知道函数的地址，所以等到链接的时候由链接器将这些指令的目标地址来修正，得到函数的地址。对于全局变量和定义在其他文件的变量也是一样的道理。</p>
<p><strong>重定位</strong>：给程序中每个引用到其他文件的地址打补丁，让他们引用到正确的绝对地址。、</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>可重定位文件</strong>（relocatable file)：包含代码和数据，可以被用来链接成可执行文件和共享目标文件。包括静态链接文件</li>
<li>可执行文件（executable file）：可执行文件</li>
<li>共享目标文件（Shared Object File）：包含代码和数据，有两个作用：跟可重定位文件生成新的可执行文件，或者可以与可执行文件结合来运行程序</li>
<li>核心转储文件（core dump file):core文件</li>
</ol>
<h3 id="目标文件格式-1"><a href="#目标文件格式-1" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>文件头</strong>:描述整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接以及入口地址，目标硬件和目标操作系统等信息，还包括一个段表，描述我呢见中各个段在文件中的偏移位置及段的属性</li>
<li><strong>text段</strong>：机器代码（在内存都是只读）</li>
<li><strong>data段</strong>：已初始化的全局变量和局部变量</li>
<li><strong>bss段</strong>：未初始化的全局变量和局部静态变量</li>
</ol>
<h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test.c</div><div class="line">objdump -h test.o</div><div class="line">size test.o</div></pre></td></tr></table></figure>
<p><img src="编译目标文件.png" alt="1564155339409"></p>
<p><img src="编译内存段.png" alt="1564155384053"></p>
<ol>
<li><p><strong>代码段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -s -d test.o</div></pre></td></tr></table></figure>
</li>
<li><p><strong>数据段和只读数据段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -x -s -d test.o</div></pre></td></tr></table></figure>
<p>.rodata为只读数据段，存储程序中的只读变量和字符串变量</p>
</li>
<li><p><strong>BSS段</strong></p>
<p>未初始化的变量</p>
</li>
</ol>
<p>其他小技巧：</p>
<p><strong>分析mp3等其他文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o</div><div class="line">objdump -ht image.o</div></pre></td></tr></table></figure>
<p><strong>自定义段</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(<span class="string">"FOO"</span>)))<span class="keyword">int</span> global = <span class="number">42</span>;<span class="comment">//变量将放在FOO段中</span></div></pre></td></tr></table></figure>
<h3 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">readelf -<span class="keyword">h</span> <span class="keyword">test</span>.o<span class="comment">//查看文件头</span></div><div class="line">readelf -S <span class="keyword">test</span>.o<span class="comment">//查看段表</span></div></pre></td></tr></table></figure>
<ol>
<li>.rel.text:重定位表</li>
<li>.shstrtab:字符串表</li>
</ol>
<h3 id="链接的接口：符号"><a href="#链接的接口：符号" class="headerlink" title="链接的接口：符号"></a>链接的接口：符号</h3><p>定义C++宏，只有在C++程序中才能够进行编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">size_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><p><strong>强符号</strong>：默认函数和初始化的全局变量</p>
<p><strong>弱符号</strong>：未初始化的全局变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;<span class="comment">//啥都不是</span></div><div class="line"><span class="keyword">int</span> weak;<span class="comment">//弱符号</span></div><div class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;<span class="comment">//强符号</span></div><div class="line">__attribute__((weak)) weak2=<span class="number">2</span><span class="comment">//弱符号</span></div></pre></td></tr></table></figure>
<p><strong>强引用</strong>：对外部目标文件的符号引用在目标文件被最终链接到可执行文件时，要被正确决议，如果没有找到错误，要报编译错误</p>
<p><strong>弱引用</strong>：如果符号没有被定义不报错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__attribute__((weakref)) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(foo)</div><div class="line">		foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gcc中生成调试段：加上-g</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;运行库.png&quot; alt=&quot;1564068683784&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统应用程
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux,C++" scheme="https://caixueyuan.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++程序概述</title>
    <link href="https://caixueyuan.github.io/2019/07/23/C-%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/23/C-程序概述/</id>
    <published>2019-07-22T16:21:59.000Z</published>
    <updated>2019-07-22T16:41:16.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h2><p><img src="冯诺依曼式" alt="img"></p>
<p>上面为冯诺依曼式计算机</p>
<p>指令执行的过程：</p>
<p>（1） 程序计数器PC将指令的地址发送给地址寄存器AR</p>
<p>（2）地址寄存器到响应的存储单元中将指令取出放入指令寄存器</p>
<p>（3） 指令寄存器将指令交给指令译码器ID进行译码，经过分析这条指令的操作数是一个地址</p>
<p>（4）控制器将指令中的地址传回地址寄存器AR</p>
<p>（6）在控制器的协调下，到相应的存储器中取出数据，将其送到运算器的缓冲寄存器DR</p>
<p>（7）缓冲寄存器将数据送到算数逻辑单元ALU</p>
<p>（8）操作控制器发送一个加一操作的信号给算数逻辑单元ALU</p>
<p>（9）ALU完成运算，并将运算结果放回到累加器中</p>
<p>详情请见：<a href="https://blog.csdn.net/chenkaibsw/article/details/78315931" target="_blank" rel="external">冯诺依曼式计算机</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可执行程序&quot;&gt;&lt;a href=&quot;#可执行程序&quot; class=&quot;headerlink&quot; title=&quot;可执行程序&quot;&gt;&lt;/a&gt;可执行程序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;冯诺依曼式&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面为冯诺依曼式计算机&lt;/p&gt;
&lt;p&gt;指令执行
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="LinuxC++" scheme="https://caixueyuan.github.io/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://caixueyuan.github.io/2019/07/21/C-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/07/21/C-基础/</id>
    <published>2019-07-21T15:17:43.000Z</published>
    <updated>2019-07-23T16:23:39.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p><strong>sizeof</strong>返回的是表达式结果类型的大小，而不是实际对象值的内存的大小</p>
<p><img src="1563722534600.png" alt="1563722534600"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>static_cast:任何具有明确定义的类型转换，主要不包含底层const，都可以使用static_cast.</li>
<li>const_cast:只能改变运算对象的底层const，将const对象转换为非const对象，没办法做类型转换</li>
<li>reinterpret_cast:为运算对象的位模式提供较低层次上的重新解析，不改变内容，只改变了表达的方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span>* pc1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div><div class="line"><span class="keyword">int</span> *ip;</div><div class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);<span class="comment">//实际上pc存储的还是int类型的指针</span></div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="局部静态成员"><a href="#局部静态成员" class="headerlink" title="局部静态成员"></a>局部静态成员</h3><p><strong>局部静态成员</strong>：在程序执行路径第一次经过此对象定义语句的时候初始化，直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对其有影响</p>
<p><img src="1563811767670.png" alt="1563811767670"></p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配</p>
<p><strong>initializer_list</strong>:可变参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//expect和actual是string对象</span></div><div class="line"><span class="keyword">if</span>(expected != actual)</div><div class="line">    error_msg(&#123;<span class="string">"function"</span>,expected,actual&#125;);</div><div class="line"><span class="keyword">else</span></div><div class="line">    error_msg(&#123;<span class="string">"functionX"</span>,<span class="string">"OKAY"</span>&#125;);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(ErrCode e,<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg() &lt;&lt; <span class="string">":"</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem:il)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值</strong>：</h3><ol>
<li>不要返回局部对象的引用和指针。因为如果返回局部对象的引用时，由于函数运行结束之后局部对象会被析构，导致返回值为未知对象。</li>
<li>引用返回左值，返回值可以作为左值，如果返回的是引用的话</li>
</ol>
<p><strong>重载函数</strong>：</p>
<p>C++重载的是不区分顶层，区分底层</p>
<p>C++中名字查找发生在类型检查之前</p>
<p><img src="重载.png" alt="1563897046529"></p>
<p><strong>内联函数</strong>：内联函数只是向编译器发出的一个请求，编译器可以忽略这个请求。通常就是在每个调用点内联展开。</p>
<p><strong>constexpr函数</strong>：函数的返回值以及所有形参的类型都是字面值类型，而且函数体内必须有且只有一条return语句。constexpr为内联函数，不一定返回常量表达式。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>assert预处理宏：是预处理器，而不是编译器检查的。用来检查不可能的情况</p>
<p><strong>NDEBUG预处理变量</strong>：assert的行为依赖于这个预处理变量的状态，如果定义了这个预处理变量，就什么都不做。</p>
<p><img src="预处理1.png" alt="1563898004510"></p>
<p><img src="预处理2.png" alt="1563898033745"></p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool lengthCompare(const string &amp;,const string &amp;);</div><div class="line">bool (*pf)(const string&amp;,const string &amp;);</div><div class="line">pf = lengthCompare;</div><div class="line">pf = &amp;lengthCompare;</div><div class="line">bool b1 = pf("a","b");</div><div class="line">bool b2 = (*pf)("a","b");</div><div class="line"></div><div class="line">//声明函数指针</div><div class="line">int (*f1(int))(int*,int);</div><div class="line">auto f1(int) -&gt; int(*)(int*,int);</div><div class="line"></div><div class="line">//使用decltype简化书写函数返回类型的过程，第三个函数接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。</div><div class="line">string:size_type sumLength(const string&amp; ,const string &amp;);</div><div class="line">string:size_type largeLength(const string&amp;,const string &amp;);</div><div class="line">decltype (sumLength) *getLength(const string &amp;);//*表示返回指针类型</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表达式&quot;&gt;&lt;a href=&quot;#表达式&quot; class=&quot;headerlink&quot; title=&quot;表达式&quot;&gt;&lt;/a&gt;表达式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;sizeof&lt;/strong&gt;返回的是表达式结果类型的大小，而不是实际对象值的内存的大小&lt;/p&gt;
&lt;p&gt;&lt;img s
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime第四章</title>
    <link href="https://caixueyuan.github.io/2019/07/18/C-Prime%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/18/C-Prime第四章/</id>
    <published>2019-07-17T16:08:00.000Z</published>
    <updated>2019-07-17T16:53:22.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><ol>
<li>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</li>
<li>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</li>
</ol>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><ol>
<li><strong>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</strong></li>
<li><strong>变量能且只能够定义一次，而可以被多次声明</strong></li>
</ol>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ol>
<li><strong>引用:</strong>引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</li>
<li><strong>引用必须被初始化</strong></li>
<li><strong>如果想要在多个文件之间共享</strong>const对象，必须在变量的定义之前添加extern关键字。</li>
</ol>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line"></div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>：auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line"></div><div class="line">​    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"></div><div class="line">​    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line"></div><div class="line">​    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr[<span class="number">10</span>];<span class="comment">//10个整形数组的指针</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>] = &amp;ptr;<span class="comment">//一个指针指向有10个元素的数组</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (&amp;ptr)[<span class="number">10</span>] = ptr;<span class="comment">//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<h2 id="C语句风格的数组"><a href="#C语句风格的数组" class="headerlink" title="C语句风格的数组:"></a>C语句风格的数组:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure>
<p>这样可以创建一个数组（将数组转换为vector）</p>
<p><img src="1563380478962.png" alt="1563380478962"></p>
<p>使用别名来代替类型</p>
<p><img src="使用别名来代替类型.png" alt="使用别名来代替类型"></p>
<p>第一行和第二行是等价的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/li&gt;
&lt;li&gt;初始化不是赋值，
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记(变量和基础类型)</title>
    <link href="https://caixueyuan.github.io/2019/07/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/08/C-学习笔记/</id>
    <published>2019-07-08T15:37:50.000Z</published>
    <updated>2019-07-17T15:52:13.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><blockquote>
<p>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</p>
<p>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</p>
</blockquote>
<h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</p>
<p><strong>变量能且只能够定义一次，而可以被多次声明</strong></p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>引用</strong>：引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</p>
<p><strong>引用必须被初始化</strong></p>
<p>如果想要在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>:auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> *<span class="built_in">ptr</span>[<span class="number">10</span>]<span class="comment">;//10个整形数组的指针</span></div><div class="line"><span class="built_in">int</span> (*<span class="built_in">ptr</span>)[<span class="number">10</span>] = &amp;<span class="built_in">ptr</span><span class="comment">;//一个指针指向有10个元素的数组</span></div><div class="line"><span class="built_in">int</span> (&amp;<span class="built_in">ptr</span>)[<span class="number">10</span>] = <span class="built_in">ptr</span><span class="comment">;//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<p><em>C语句风格的数组</em>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/p&gt;
&lt;p&gt;初始化
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++学习笔记" scheme="https://caixueyuan.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>linux设备驱动程序</title>
    <link href="https://caixueyuan.github.io/2019/05/29/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://caixueyuan.github.io/2019/05/29/linux设备驱动程序/</id>
    <published>2019-05-29T15:58:36.000Z</published>
    <updated>2019-06-09T16:11:16.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h2><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E6%80%BB%E7%BA%BF.gif" alt="总线"></p>
<p>两条高速总线用于在内存芯片上来回传送数据：前端总线将CPU连接到RAM控制器上，而后端总线将CPU连接到外部硬件的高速缓存上。</p>
<p>主机上的桥将系统总线和前端总线连接在一起。</p>
<p>任何设备只能够连接到一条总线上。</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/PC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.gif" alt="IO体系结构"></p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E4%B8%93%E7%94%A8IO%E7%AB%AF%E5%8F%A3.gif" alt="专用接口"></p>
<p>I/O端口有两种方式：既可以使用为独立的I/O地址空间，又可以被映射到物理地址空间，这样就可以通过内存来访问I/O端口啦。不过一般情况下，都是作为独立的I/O地址空间。</p>
<p>一般情况下，I/O有四个汇编指令，分别为in、out、ins、outs</p>
<p>对于I/O端口，有特殊的数据结构来对应（resource），主要的作用是唯一性地指定I/O地址空间，让地址不重复</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。在相反方向上，它检测设备状态的变化，并对起状态寄存器作用的I/O端口进行相应的更新。（也就是说将值转换为数据，并监控I/O状态)</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><blockquote>
<ul>
<li><p>对从I/O接口收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作。</p>
</li>
<li><p>对从设备接收到的电信号进行转换和适当的解释，并修改（通过I/O接口）状态寄存器的值。</p>
</li>
</ul>
</blockquote>
<h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs文件系统的目标是展现设备驱动程序模型组件间的层次关系，允许用户态应用程序访问内核内部数据结构的一种文件系统</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.PNG" alt="sysfs文件系统"></p>
<p><code>sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用；sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核的数据结构以及它们的属性</code></p>
<p><img src="https://blog.csdn.net/zqixiao_09/article/details/50864489" alt="详细信息"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O体系结构&quot;&gt;&lt;a href=&quot;#I-O体系结构&quot; class=&quot;headerlink&quot; title=&quot;I/O体系结构&quot;&gt;&lt;/a&gt;I/O体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caixue
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>锁和进程间通讯</title>
    <link href="https://caixueyuan.github.io/2019/05/26/%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2019/05/26/锁和进程间通讯/</id>
    <published>2019-05-26T04:20:46.000Z</published>
    <updated>2019-05-26T13:09:30.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<ul>
<li><p>临界区：访问和操作共享数据的代码段</p>
</li>
<li><p>竞态条件：当有多个线程同时进入临界区时，执行结果取决于线程的执行顺序。也就是说多个线程如果不受控制的话，那么产生的结果不一定是我们想要的</p>
</li>
</ul>
</blockquote>
<h2 id="内核锁"><a href="#内核锁" class="headerlink" title="内核锁"></a>内核锁</h2><p>锁是有开销的，内核锁的关键的开销在于CPU访问内存的时间，正常情况下CPU都是访问寄存器，寄存器的速度更快</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>概念：该操作在执行完成前不会允许被打断，是最小的执行单元。</p>
<p>原子类型定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter; &#125; <span class="keyword">atomic_t</span>;</div></pre></td></tr></table></figure>
<p>volatile修饰字段告诉gcc不要对该类型的数据做优化处理，对它的访问都是对内存的访问，而不是对寄存器的访问。 </p>
<p>用处：常用于引用计数</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源。一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。</p>
<p>用处：作为互斥量使用</p>
<h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><p>读写信号量的访问规则：</p>
<p>1，读写信号量同时拥有的读者数不受限制，也就说可以有任意多个读者同时拥有一个读写信号量。</p>
<p>2,如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则，读者必须被挂起直到写者释放该信号量。</p>
<p>3，如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者将被挂起，直到没有任何访问者。 </p>
<p>因此，写者是排他性的，独占性的。 </p>
<p>读写信号量有两种实现，一种是通用的，不依赖于硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现。</p>
<p>用处：适用于读多写少的环境下</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁和互斥锁的区别在于自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁</p>
<p>信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（_trylock的变种能够在中断上下文使用），而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共巷资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。 </p>
<h3 id="大内核锁-BKL–Big-Kernel-Lock"><a href="#大内核锁-BKL–Big-Kernel-Lock" class="headerlink" title="大内核锁(BKL–Big Kernel Lock)"></a>大内核锁(BKL–Big Kernel Lock)</h3><p>大内核锁本质上也是自旋锁，但是它又不同于自旋锁，自旋锁是不可以递归获得锁的，因为那样会导致死锁。但大内核锁可以递归获得锁。大内核锁用于保护整个内核，而自旋锁用于保护非常特定的某一共享资源。进程保持大内核锁时可以发生调度，具体实现是：在执行schedule时，schedule将检查进程是否拥有大内核锁，如果有，它将被释放，以致于其它的进程能够获得该锁，而当轮到该进程运行时，再让它重新获得大内核锁。注意在保持自旋锁期间是不允许发生调度的。 </p>
<p>需要特别指出，整个内核只有一个大内核锁，其实不难理解，内核只有一个，而大内核锁是保护整个内核的，当然有且只有一个就足够了。 </p>
<h3 id="读写锁（rwlock"><a href="#读写锁（rwlock" class="headerlink" title="读写锁（rwlock)"></a>读写锁（rwlock)</h3><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。<br>在读写锁保持期间也是抢占失效的。<br>读写锁访问规则:</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。<br>如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<h3 id="大读者锁-brlock-Big-Reader-Lock"><a href="#大读者锁-brlock-Big-Reader-Lock" class="headerlink" title="大读者锁(brlock-Big Reader Lock)"></a>大读者锁(brlock-Big Reader Lock)</h3><p>大读者锁的实现机制是：每一个大读者锁在所有CPU上都有一个本地读者写者锁，一个读者仅需要获得本地CPU的读者锁，而写者必须获得所有CPU上的锁。</p>
<h3 id="RCU-Read-Copy-Update"><a href="#RCU-Read-Copy-Update" class="headerlink" title="RCU(Read-Copy Update)"></a>RCU(Read-Copy Update)</h3><p>对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。 </p>
<p>参考链接：</p>
<h2 id="进程间通讯（IPC）"><a href="#进程间通讯（IPC）" class="headerlink" title="进程间通讯（IPC）"></a>进程间通讯（IPC）</h2><p>每个地址都有自己的虚拟空间，虚拟空间互不可见，进程间通讯需要通过内核，内核开辟出一块缓冲空间，进程A将数据从用户空间复制到内核空间，进程B将数据从内核缓冲区复制到用户空间来完成进程间通讯</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种特殊文件，满足先进先出的原则，不能够随机读取，在建立管道之前要保证发送方和接收方的进程存在</p>
<p>匿名管道和有名管道总结：<br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号生命周期和处理流程<br>（1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br>（2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br>（3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列特点总结：<br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。<br>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥</p>
<p>信号量与互斥量之间的区别：<br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p>
<p>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<h3 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h3><p>详细信息请见：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="external">进程间通讯</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;临界区：访问和操作共享数据的代码段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;竞态条件：当有多个线程同时
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="https://caixueyuan.github.io/2019/05/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://caixueyuan.github.io/2019/05/19/Linux进程管理/</id>
    <published>2019-05-19T14:31:59.000Z</published>
    <updated>2019-05-26T04:22:59.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h3 id="进程优先级-1"><a href="#进程优先级-1" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程可以分为实时线程和普通线程，一般情况下咱们运行的微服务的进程都是普通线程。<br>实时进程的优先级大于普通线程，在CPU调度中优先执行，采用先进先出的原则进行调度；<br>普通线程的优先级：影响进程的优先级有两个值：动态优先级（PRI）和静态优先级（NI），静态优先级可以影响进程的优先级。<br>使用ps -l的方式进行查询</p>
<p>NICE有40个优先级，以-20（最高优先级）到19（最低优先级），默认有限级为0,<br>使用renice能够改变进程的优先级，只有root用户才能够提高进程的优先级，而普通用户只能够减低进程的优先级<br>使用的命令如下：</p>
<blockquote>
<ul>
<li>nice -n 6 sh bash.sh</li>
<li>renice +3 1234(PID)</li>
</ul>
</blockquote>
<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><p>进程还分为前台进程和后台进程，前台进程负责跟用户进行交互，使用以下两个命令能够进行前后台切换</p>
<blockquote>
<ul>
<li>fg 将后台转变成前台</li>
<li><p>bg 将前台转变成后台</p>
</li>
<li><p>nohup 用户注销不影响进程运行</p>
</li>
<li>ps -j –forest 查询进程树的结构</li>
</ul>
</blockquote>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><p><img src="https://img-blog.csdn.net/20180227113851124" alt="进程生命周期"><br>进程有这几个状态：</p>
<blockquote>
<ul>
<li>运行状态：进程正在CPU上运行</li>
<li>等待状态：进程已经准备好啦，等待CPU进行调度，获取CPU片段时间</li>
<li>终止状态：进程已经运行完啦，通过return/_exit/exit进行返回</li>
<li>睡眠状态：进程因为某些原因（主要有两种：IO缺页问题导致需要进行IO退出CPU运行，或者是周期性的CPU调度）导致进程CPU片段时间被抢占，进入睡眠状态</li>
</ul>
</blockquote>
<h2 id="数据结构task-struct"><a href="#数据结构task-struct" class="headerlink" title="数据结构task_struct"></a>数据结构task_struct</h2><p>包含了进程运行的所有信息，其实比较重要的变量：</p>
<blockquote>
<ul>
<li><code>volatile long state</code>代表进程的状态</li>
<li><code>pid_t pid;  pid_t tgid;</code>进程的唯一标识PID</li>
<li><code>void *stack;</code>进程的内核栈</li>
</ul>
</blockquote>
<p>具体的参考链接：<br><a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="external">Linux进程描述符task_struct结构体详解</a></p>
<h2 id="进程关系："><a href="#进程关系：" class="headerlink" title="进程关系："></a>进程关系：</h2><h3 id="进程组的概念"><a href="#进程组的概念" class="headerlink" title="进程组的概念"></a>进程组的概念</h3><p>每个进程都属于一个进程组，进程组有一个进程组领导进程。<br>比如这个（这三个进程为一个进程组，进程组领导进程为第一个进程bash进程）<br><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="进程组"></p>
<h3 id="会话-session"><a href="#会话-session" class="headerlink" title="会话 (session)"></a>会话 (session)</h3><p>将进程分为前台进程和后台进程，通过fg和pg进行切换</p>
<p>参考链接：<a href="https://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="external">Linux进程关系</a></p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>进程都是通过父进程创建子进程的方式来创建进程的。主要有三种方式：fork，vfork和clone</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork是最常用的方式，一般情况下我们都是使用这种方式来创建进程</p>
<p><code>重要</code>:<br>开始的时候，父进程和子进程都是共用一份可执行文件，堆栈等，物理地址和逻辑地址都是一致的，父进程和子进程共享页帧而不是复制页帧，并且页帧是被保护的。</p>
<p>当父进程A或子进程B任何一方对这些已共享的物理页面执行写操作时,都会产生页面出错异常(page_fault int14)中断,此时CPU会执行系统提供的异常处理函数do_wp_page()来解决这个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。如果是父进程创建的页帧，只对父进程可见可读可写。如果是子进程创建的页，只对父进程可见可读可写。</p>
<p>do_wp_page()会对这块导致写入异常中断的物理页面进行取消共享操作,为写进程复制一新的物理页面,使父进程A和子进程B各自拥有一块内容相同的物理页面.最后,从异常处理函数中返回时,CPU就会重新执行刚才导致异常的写入操作指令,使进程继续执行下去.</p>
<p>这个过程结束之后，虚拟地址依然是不变的，只是虚拟地址映射到物理地址的映射变化，物理地址是变化的，但是虚拟地址不变</p>
<p>子进程和父进程的执行顺序不能够确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">    child = fork( );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(child &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is father, his count is: %d (%p), his pid is: %d\n"</span>, count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">caixueyuan@caixueyuan-PC:~/Desktop/process$ ./fork </div><div class="line">This <span class="keyword">is</span> father, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">1</span> (<span class="number">0</span>x7ffeff294758), <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11495</span></div><div class="line">This <span class="keyword">is</span> son, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">2</span> (<span class="number">0</span>x7ffeff294758). <span class="built_in">and</span> <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11496</span></div></pre></td></tr></table></figure></p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork跟fork最大的区别就是vfork没有采用写时复制这一块，子进程从开始到结束都是使用父进程的虚拟地址和物理空间，如果子进程要修改数据，修改的也是父进程的数据<br><code>重要</code>:这里要特别注意：子进程退出不能够使用return的方式，因为子进程退出和父进程退出是一样的，会导致重复退出而报错。最好也不要使用exit(0)这种方式，稍后会进行解释。</p>
<p>vfork的用处：一般是用来创建不修改父进程的数据的子进程（一般咱们是用来通过创建子进程来执行另外一个程序，不会修改到原程序的堆，数据等）</p>
<p>vfork创建的进程都是子进程先执行，等子进程使用execve或者_exit退出之后才会继续运行父进程</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">   <span class="comment">// child = vfork( );</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Before create son, the father's count is:%d\n"</span>, count);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>((child = vfork())&lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After son, This is father, his count is: %d (%p), his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Before create son, <span class="keyword">the</span> father's <span class="built_in">count</span> <span class="keyword">is</span>:<span class="number">1</span></div><div class="line">This <span class="keyword">is</span> son, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">2</span> (<span class="number">0x7ffe4b965058</span>). <span class="keyword">and</span> his pid <span class="keyword">is</span>: <span class="number">12998</span></div><div class="line">After son, This <span class="keyword">is</span> father, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">3</span> (<span class="number">0x7ffe4b965058</span>), his pid <span class="keyword">is</span>: <span class="number">12997</span></div></pre></td></tr></table></figure></p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone是libc中的函数，不是系统调用，一般是用来创建线程的，可以通过clone的方式来创建以上fork或者vfork的方式的创建进程</p>
<p>参考链接：<a href="https://blog.csdn.net/gatieme/article/details/51417488" target="_blank" rel="external">Linux中fork，vfork和clone详解（区别与联系）</a></p>
<h2 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h2><p>进程的退出有两种：</p>
<blockquote>
<ul>
<li>正常退出（return,exit(0),_exit(0))</li>
<li>非正常退出（调用abort(),通过信号的方式（kill -9))</li>
</ul>
</blockquote>
<p>正常退出的方式要注意exit和_exit的区别，有可能造成很隐蔽的错误</p>
<blockquote>
<p>_exit是系统调用，直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构<br>exit不是系统调用，是libc中的接口，包含了_exit的操作，按ATEXIT注册时相反的顺序调用所有由它注册的函数，同时还能够刷一下IO，这样可以保证写文件的缓冲等能够刷到文件或者控制台中。</p>
</blockquote>
<p>之所有不推荐在vfork的方式下使用exit(0)的方式，就是怕exit需要刷IO，需要调用终止处理程序，可能会对进程中的内容造成破坏，给父进程造成不确定性</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA.png" alt="进程退出"></p>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><h3 id="进程的分类（略）"><a href="#进程的分类（略）" class="headerlink" title="进程的分类（略）"></a>进程的分类（略）</h3><p>实时进程：对于实时进程，采用先进先出的方式进行，优先级高于普通进程，会快速响应<br>普通进程：CFS调度。实现尽可能公平的分配CPU资源。一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU，另一种是通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要</p>
<h3 id="进程的上下文切换（略）"><a href="#进程的上下文切换（略）" class="headerlink" title="进程的上下文切换（略）"></a>进程的上下文切换（略）</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程优先级&quot;&gt;&lt;a href=&quot;#进程优先级&quot; class=&quot;headerlink&quot; title=&quot;进程优先级&quot;&gt;&lt;/a&gt;进程优先级&lt;/h2&gt;&lt;h3 id=&quot;进程优先级-1&quot;&gt;&lt;a href=&quot;#进程优先级-1&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux和C++基础</title>
    <link href="https://caixueyuan.github.io/2019/05/04/linux%E5%92%8CC-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/05/04/linux和C-基础/</id>
    <published>2019-05-04T14:45:45.000Z</published>
    <updated>2019-05-04T15:22:38.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第7章-编译"><a href="#第7章-编译" class="headerlink" title="第7章 编译"></a>第7章 编译</h2><h3 id="编译的阶段"><a href="#编译的阶段" class="headerlink" title="编译的阶段"></a>编译的阶段</h3><blockquote>
<ul>
<li>源代码</li>
<li><p>预处理：字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名<figure class="highlight plain"><figcaption><span>-o main.i -E main.c gcc -o hello.i -E hello.c```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 编译：将预处理之后的完整的代码进行编译，变成汇编代码```gcc -S main.i hello.i</div></pre></td></tr></table></figure></p>
</li>
<li><p>汇编：将汇编代码翻译成机器代码，变成二进制文件。<figure class="highlight plain"><figcaption><span>-c main.s hello.s```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 链接：链接程序形成可执行目标文件```gcc -o hello main.o hello.o</div></pre></td></tr></table></figure></p>
</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第7章-编译&quot;&gt;&lt;a href=&quot;#第7章-编译&quot; class=&quot;headerlink&quot; title=&quot;第7章 编译&quot;&gt;&lt;/a&gt;第7章 编译&lt;/h2&gt;&lt;h3 id=&quot;编译的阶段&quot;&gt;&lt;a href=&quot;#编译的阶段&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/categories/linux-C/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2019/02/14/hello-world/"/>
    <id>https://caixueyuan.github.io/2019/02/14/hello-world/</id>
    <published>2019-02-13T16:10:35.276Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&#39;C++类&#39;</title>
    <link href="https://caixueyuan.github.io/2018/10/08/C-%E7%B1%BB/"/>
    <id>https://caixueyuan.github.io/2018/10/08/C-类/</id>
    <published>2018-10-08T15:36:33.000Z</published>
    <updated>2018-10-17T14:30:04.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类概念"><a href="#类概念" class="headerlink" title="类概念"></a>类概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> bookNo&#125;</div><div class="line">    Sales_data&amp; combine(<span class="keyword">const</span> Sales_data&amp;);</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>std::string isbn() const{return this-&gt;bookNo;}</code>this的目的总是指向这个对象，this是一个常量指针，不能够修改this中保存的地址。<br>const的作用是修改隐式this指针的类型，相当于const int i =1;中const的作用。<br>默认情况下，this的类型是指向类类型的非常量版本的常量指针。</p>
<p>C++编译顺序：首先编译成员的声明，然后才轮到成员函数体。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用class和struct定义唯一的区别是默认的访问权限，struct的默认权限是public，而class的默认权限是private</p>
<p>不管是在类内，还是在类外，都可以将函数转为内联函数。</p>
<p><strong>可变数据成员</strong>：mutable size_t access_cst;//任何成员函数，包括const函数在内都能够修改它的值。</p>
<p>返回*this的成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos,pos,<span class="keyword">char</span>)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(<span class="keyword">char</span> c)</div><div class="line">&#123;</div><div class="line">    contents[cursor] = c;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//将this对象作为左值返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回引用的函数是左值的，意味这些函数返回的是对象本身而非对象的副本。<br><code>myScreen.move(4,0).set(&#39;#&#39;);</code>//返回的是对象的引用，所以可以这样使用<br>如果返回的是对象的话，也就是<code>inline Screen Screen::set(char c)</code>的话，那么<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Screen temp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);<span class="comment">//对返回值进行拷贝</span></div><div class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);<span class="comment">//不会修改myScreen的contents</span></div></pre></td></tr></table></figure></p>
<p>因此调用set只能改变临时副本，而不能修改myScreen的值</p>
<p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></div><div class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有成员</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//如果一个类指定了友元类，则友元类的成员函数可以访问次类包括非公有成员在内的所有成员</span></div></pre></td></tr></table></figure>
<p>友元关系不存在传递性<br>每个类负责控制自己的友元类或友元函数</p>
<p><strong>让成员函数作为友元</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line"></div><div class="line">    <span class="comment">//Window_mgr:clear必须在Screen类之前被声明</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);<span class="comment">//这样的话只有Window_mgr中的函数clear能够访问Screen中的非公有成员</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;, Screen &amp;)</span></span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;,Screen &amp;)</span></span>;<span class="comment">//storeOn的中ostream版本能够访问Screen对象的私有部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类概念&quot;&gt;&lt;a href=&quot;#类概念&quot; class=&quot;headerlink&quot; title=&quot;类概念&quot;&gt;&lt;/a&gt;类概念&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++基础知识&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-基础知识/</id>
    <published>2018-09-23T13:10:59.000Z</published>
    <updated>2019-03-18T16:05:05.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>指针是“指向”另外一种类型的复合类型。和引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不相同点。</p>
<blockquote>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和靠背，而且在指针的生命周期内它可以先后指向几个不同的对象</li>
<li>指针无需在定义的时候赋初值</li>
<li>和其他内置对象类型一样，在块作用域中定义的指针如果没有被初始化，也将拥有一个不确定的值</li>
</ul>
</blockquote>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>case标签</strong>：switch…case中case标签必须是整形常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(deltype(s.size())index = <span class="number">0</span>;index!= s.size() &amp;&amp; !<span class="built_in">isspace</span>(s[index]);++index)&#123;</div><div class="line">    s[index]=<span class="built_in">toupper</span>(s[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误类型</p>
<blockquote>
<ul>
<li>exception最常见的问题</li>
<li>runtime_error只有在运行的时候才能够检测出来的问题</li>
<li>range_error运行时错误，生成的结果超过了有意义的值域范围</li>
<li>overflow_error:运行时错误：计算上溢</li>
<li>underflow_error:运行时错误：计算下溢</li>
<li>logic_error：程序逻辑错误</li>
<li>domain_error:逻辑错误：参数对应的结果不存在</li>
<li>invalid_argument:逻辑错误：无效参数</li>
<li>length_error：逻辑错误，试图创建一个超出该类型最大长度的对象</li>
<li>out_of_range：逻辑错误：使用一个超过有效范围的值</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> runtime_error(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(runtime_error err)&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;err.what()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数的返回值不能是数组类型或者函数类型，但可以是指向数组或函数的指针</strong></p>
<p><strong>局部静态对象</strong>：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;<span class="comment">//调用结束后，这个值仍然有效</span></div><div class="line">    <span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><p>分离式编译<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span></div><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span> -o main</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CC -c factMain<span class="selector-class">.cc</span></div><div class="line">CC -c fact<span class="selector-class">.cc</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span> -o main</div></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>传值参数</strong>：</p>
<blockquote>
<ul>
<li>传基本类型</li>
<li>指针形参：指针也是值，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span></div><div class="line">&#123;</div><div class="line">    *ip = <span class="number">0</span>;<span class="comment">//改变指针ip所指对象的值</span></div><div class="line">    ip = <span class="number">0</span>;<span class="comment">//只改变了ip的局部拷贝，实参没有改变</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>传引用参数</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></div><div class="line">&#123;</div><div class="line">    i = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用引用的好处是：</p>
<blockquote>
<ul>
<li>使用引用避免拷贝</li>
<li>使用引用形参返回额外信息。</li>
</ul>
</blockquote>
<p>顶层和底层const<br><strong>顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;<span class="comment">//不能够修改p1的值，这是一个顶层const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能修改ci的值，这是一个顶层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">//允许修改p2的值，这是一个底层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针和引用&quot;&gt;&lt;a href=&quot;#指针和引用&quot; class=&quot;headerlink&quot; title=&quot;指针和引用&quot;&gt;&lt;/a&gt;指针和引用&lt;/h2&gt;&lt;p&gt;指针是“指向”另外一种类型的复合类型。和引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不相同
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++算术运算符&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-算术运算符/</id>
    <published>2018-09-23T09:25:11.000Z</published>
    <updated>2018-09-23T11:15:34.079Z</updated>
    
    <content type="html"><![CDATA[<p>##赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">while</span>((i=get_value()) != <span class="number">42</span>)&#123;</div><div class="line">    <span class="comment">//其他处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<blockquote>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1</li>
<li>对引用类型执行sizeof运算得到被引用对象所占的空间的大小</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得到的结果求和</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz=<span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);<span class="comment">//得到ia元素的个数</span></div></pre></td></tr></table></figure>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p><strong>static_cast</strong>:作用域任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* p = &amp;d;<span class="comment">//正确：任何非常量对象的地址都能够存入void*</span></div><div class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);<span class="comment">//正确，将void*转换回初始的指针类型</span></div></pre></td></tr></table></figure></p>
<p><strong>const_cast</strong>:只能改变运算对象的底层const。能够将常量对象转换成非常量对象的行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##赋值运算符&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>指针与引用</title>
    <link href="https://caixueyuan.github.io/2018/09/11/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2018/09/11/指针与引用/</id>
    <published>2018-09-11T14:07:02.000Z</published>
    <updated>2018-09-23T07:57:16.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。<br><code>int &amp;refVal4 = 10</code>这种引用类型不是一个对象。</p>
<p>指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象。其二,指针无需在定义时赋初值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//&amp;是取地址符，存放变量ival的地址，或者说p是指向变量ival的指针。</span></div><div class="line"><span class="comment">//第二条语句把p定义为一个指向int的指针，随后初始化p让其指向名为ival的int对象。</span></div><div class="line"><span class="keyword">int</span> *p;</div><div class="line">p = &amp;ival;</div></pre></td></tr></table></figure></p>
<p>在constexpr声明中，如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是一个指向整形常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是一个指向整数的常量指针</span></div></pre></td></tr></table></figure></p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</div><div class="line"><span class="keyword">using</span> SI= Sales_Item;</div></pre></td></tr></table></figure>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;<span class="comment">//sum的类型就是函数f的返回类型</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci =<span class="number">0</span>,&amp;cj = ci;</div><div class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是const int</span></div><div class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></div><div class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误，引用不能够为空</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p = &amp;i;</div><div class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//解引用指针可以得到指针所指定的对象，而且给这个对象赋值，因为结果是int&amp;</span></div></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>)<span class="comment">//v1有10个元素，每个元素的值都是0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;<span class="comment">//v2有1个元素，元素的值为0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//v3有10个元素，每个元素的值都是1</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125;<span class="comment">//v4有2个元素，元素的值为10,1</span></div></pre></td></tr></table></figure>
<p>vector对象的下标对象运算符可用于访问已存在的元素,而不能够用于添加元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</div><div class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;</div><div class="line">    <span class="keyword">auto</span> it = s.begin();</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); it++)&#123;</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>迭代器类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读写类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">string</span>::iterator it2;</div><div class="line"><span class="comment">//只读类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</div><div class="line"><span class="built_in">string</span>::const_iterator it4;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</div><div class="line"><span class="keyword">auto</span> it1 = v.begin();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></div><div class="line"><span class="keyword">auto</span> it2 = cv.begin();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line"><span class="keyword">auto</span> it3 = v.cbegin();<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line">（*it).empty()等于it-&gt;empty()<span class="comment">//it为迭代器</span></div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义数组时一定要保证数组的个数为常量，定义数组时一定要定义数组的类型，不能够是使用auto<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> cnt = <span class="number">12</span>;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> cnt1 = <span class="number">12</span>;<span class="comment">//常量表达式</span></div><div class="line"><span class="built_in">string</span> bad[cnt];<span class="comment">//错误，cnt不是常量表达式</span></div></pre></td></tr></table></figure></p>
<p>字符数组的特殊性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span><span class="comment">//自动添加表示字符串结束的空字符</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Deniel"</span>;<span class="comment">//错误，没有空间可存放空字符</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：不能够将数组拷贝给其他数组作为初始值</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int (*Parray)[<span class="number">10</span>] = <span class="meta">&amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span></div><div class="line">int (<span class="meta">&amp;arrRef)[10] = arr;<span class="comment">//arrRef引用一个含有10个整数的数组</span></span></div></pre></td></tr></table></figure>
<p><strong>指针和数组</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>];</div><div class="line"><span class="built_in">string</span> *p2 = nums;<span class="comment">//等价于string *p = &amp;nums[0];</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(nums)</span></span>;<span class="comment">//ia2是一个整形指针，指向ia的第一个元素</span></div></pre></td></tr></table></figure></p>
<p>数组输出全部元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *e = &amp;arr[<span class="number">10</span>];<span class="comment">//arr有10个元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = &amp;arr;b!=e;b++)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数组的函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line">int *pbeg = begin(arr);</div><div class="line">int *pend = end(arr);</div><div class="line">while(pbeg != pend &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</div><div class="line">    ++pbeg;</div></pre></td></tr></table></figure></p>
<p>只有同一相关对象的指针才能够比较，不相关对象的指针不能够进行比较。</p>
<h3 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;</div><div class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</div><div class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];<span class="comment">//把row绑定到ia的第二个4元素数组上</span></div><div class="line"><span class="comment">//把row定义为一个含有4个整数的数组的引用，然后将其绑定到ia的第2行。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。&lt;br&gt;&lt;code&gt;int &amp;amp;refVal4 
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ string字符串</title>
    <link href="https://caixueyuan.github.io/2018/09/09/string%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://caixueyuan.github.io/2018/09/09/string字符串/</id>
    <published>2018-09-09T15:14:50.000Z</published>
    <updated>2018-09-23T07:57:20.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化有两种，直接初始化和拷贝初始化。<br>拷贝初始化<code>string a = &#39;abc&#39;</code><br>直接初始化<code>string a {&#39;abc&#39;}</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>C++语法中的字符串字面值并不是标准库中的string的对象。字符串字面量和string是不同的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> a = <span class="string">"abc"</span>;</div><div class="line"><span class="built_in">string</span> b = a+<span class="string">"def"</span>+<span class="string">"ghi"</span>;<span class="comment">//正确，(a+"def")+"ghi"</span></div><div class="line"><span class="built_in">string</span> c = <span class="string">"def"</span>+<span class="string">"ghi"</span>+a；<span class="comment">//错误，("def"+"ghi")+a</span></div></pre></td></tr></table></figure>
<p>C++能够改变字符串中的字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s &#123;<span class="string">"abc"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;temp : s)</div><div class="line">&#123;</div><div class="line">    temp = <span class="built_in">toupper</span>(temp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将第一个词变成大写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//isspace()使用这些函数时需要添加头文件#include&lt;cctype&gt;</span></div><div class="line"><span class="built_in">string</span> s1&#123;<span class="string">"Hello World!!!"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s1.size()) index = <span class="number">0</span>; index &lt; s1.size() &amp;&amp; !<span class="built_in">isspace</span>(s1[index]); index++)</div><div class="line">&#123;</div><div class="line">    s1[index] = <span class="built_in">toupper</span>(s1[index]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><code>string::size_type n</code>用于访问字符串的下标</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL表</title>
    <link href="https://caixueyuan.github.io/2018/08/12/MySQL%E8%A1%A8/"/>
    <id>https://caixueyuan.github.io/2018/08/12/MySQL表/</id>
    <published>2018-08-12T15:36:07.000Z</published>
    <updated>2018-09-23T07:57:23.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p><strong>索引组织表</strong>：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主键<br><code>_rowid</code>可以显示表的主键，只能够查看单个列为主键的情况，并且为非空唯一索引。</p>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>表空间（tablespace)–&gt;端（segment)—&gt;区（extent)—&gt;页（page)—&gt;块（block)</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。所有的数据都存放在这个表空间中。如果弃用了参数innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。</p>
<p>表空间只存放数据、索引和插入缓冲Bitmap页，其他的数据（如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）还是存放在原来的共享表空间中。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>常见的段有数据段、索引段、回滚段。数据段为B+树的叶子节点，而索引段为B+树的非索引节点</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>由连续页组成的空间，在任何情况下每个区的大小都是1MB，在默认情况下页的大小为16KB，即一个区中一共有64个连续的页。<br>可以通过参数innodb_page_size来设置默认页的大小</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB存储引擎是面向列的，数据都是按照行来进行存放的，最多允许存放16KB/2-200行的记录，也就是7992行</p>
<h2 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h2><p>使用<code>show table status like &#39;table_name&#39;</code>来查看当前表使用的行格式。</p>
<h3 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h3><p>MySQL5.0引入的，其设计的目的是高效地存储数据。<br>一个页中存放的行数据越多，其性能就越高。<br>在compact格式下，NULL值都不占用任何存储空间，不管是CHAR类型或者是VARCHAR类型</p>
<h3 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h3><p>MySQL5.0之前的。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>BLOB可以不将数据放在溢出页面中，而且即使是VARCHAR列数据类型，依然有可能被存放为行溢出数据。通过实际测试，VARCHAR的类型的最大长度为65532.VARCHAR类型最大支持65535字节。</p>
<p>MySQL官方手册中定义的65535长度是指所有的VARCHAR列的长度总和，如果列的长度总和超过了这个长度，依然无法创建。</p>
<p>InnoDB存储引擎的页为16KB，也就是16384字节，在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。</p>
<p>一个页存放数据，如果为两条数据的话，那么每条的最大的阈值为8098.</p>
<h3 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h3><p>InnoDB1.0.x引入新的文件格式，Compressed和Dynamic<br>新的两种记录格式对于存放在BLOB中的数据采用完全的行溢出的方式。同时，存储在其中的行数据会以zlib的算法进行压缩，</p>
<h3 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h3><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度</p>
<p>CHAR(2)保存的是2个字符，不管是GBK，还是UTF-8，还是latin，都是2个字符，而不是2个字节。所以存储的字节是变化的。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>包括7个部分：</p>
<blockquote>
<ul>
<li>File Header(文件头)</li>
<li>Page Header(页头)</li>
<li>infimum和Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer(文件结尾信息)</li>
</ul>
</blockquote>
<h2 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引组织表&quot;&gt;&lt;a href=&quot;#索引组织表&quot; class=&quot;headerlink&quot; title=&quot;索引组织表&quot;&gt;&lt;/a&gt;索引组织表&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引组织表&lt;/strong&gt;：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
