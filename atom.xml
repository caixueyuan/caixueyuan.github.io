<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2020-10-22T16:01:30.346Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tomcat应知应会</title>
    <link href="https://caixueyuan.github.io/2020/10/21/tomcat%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/"/>
    <id>https://caixueyuan.github.io/2020/10/21/tomcat应知应会/</id>
    <published>2020-10-20T16:07:30.000Z</published>
    <updated>2020-10-22T16:01:30.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tomcat介绍"><a href="#tomcat介绍" class="headerlink" title="tomcat介绍"></a>tomcat介绍</h2><h3 id="应用服务器和Web服务器的区别"><a href="#应用服务器和Web服务器的区别" class="headerlink" title="应用服务器和Web服务器的区别"></a>应用服务器和Web服务器的区别</h3><p>应用服务器（如Tomcat)，是作为复杂业务逻辑处理的服务器，侧重于构建业务系统的组件支撑，以简化复杂系统的构建工作</p>
<p>Web服务器（如Nginx），侧重于HTTP请求（静态资源）的处理。</p>
<p>原因：对于Tomcat，一般情况下都是阻塞式的，对于每个请求，Tomcat会创建一个新的线程来处理请求，在大并发场景下，请求量较大，远远超过了系统的线程容量，导致系统可能出现宕机。特别是对于静态资源，如果静态资源相对较大的话，阻塞式的请求处理，会大大拖低系统的处理能力，让系统无法处理到来的请求。所以需要Nginx web服务器来处理静态资源，将对于静态资源的请求（如css文件，js文件）等用Nginx来进行。由于Nginx服务器对于每个请求，都是用进程来进行处理，默认情况下每个核一个进程来进行，不会有线程创建和释放的消耗。所以线程相对较好。（Nginx为啥子好，还不太清楚）。而对于业务的请求，通过Nginx进行转发到Tomcat应用服务器来进行处理，通过tomcat来处理复杂的请求。</p>
<p>业界通用的请求处理模式如下：</p>
<p>请求  —–&gt;  Gateway（负载均衡，鉴权）      ——&gt;     Nginx(处理静态资源)    ——-&gt; tomcat（处理Rest请求等）</p>
<p>Gateway分为外部请求和内部请求，有些时候两次会合一。</p>
<h3 id="Tomcat总体架构"><a href="#Tomcat总体架构" class="headerlink" title="Tomcat总体架构"></a>Tomcat总体架构</h3><p>Tomcat总体架构如下</p>
<p><img src="tomcat总体架构.png" alt="image-20201022230717109"></p>
<ol>
<li>Bootstrap:通过Bootstrap来拉起tomcat实例</li>
<li>Catalina:通过Digester组件来解析server.xml文件，拉起Catalina实例</li>
<li>Server:通过Catalina来初始化Server。每个Server等实例都继承Lifecycle接口，实现对该实例进行周期管理</li>
<li>Service:与Server是多对一的关系，Server下管理多个应用程序</li>
<li>Connector:作为Service的组件之一，主要负责请求的接收，协议处理等，处理请求的URL和请求的信息</li>
<li>Engine：引擎，与Service也是多对一的关系，也是一个容器，相当于请求处理的集合，包含请求的各个部分</li>
<li>AbstractEndpoint:与端口进行对应，主要的作用是从指定的端口读取数据，包括启动端口监听等</li>
<li>Processor:协议处理类，主要是对读取的数据进行指定协议的处理，处理出请求的数据出来</li>
<li>MapperListener:连接监听器，不是ProtocolHandle处理的一部分，而是Service请求的一部分，主要是对抽取出来的请求进行处理，进行Mapper映射</li>
<li>Mapper:存储着对象的映射</li>
<li>Host：相当于域名服务器，对一个域名中的所有请求进行处理</li>
<li>Context：相当于一个webapp</li>
<li>Wrapper:相当于URL请求映射，包含Servlet请求。</li>
<li>对于每一个Engine，Host，Context和Wrapper，都有一个Pipeline，每个Pipeline都使用了责任链模式，可以对请求进行拦截处理</li>
<li>经过以上的Pipeline层次之后，才会经过Filter（Filter也是责任链模式），用来对请求进行处理，在Servlet请求的前面。</li>
</ol>
<h3 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h3><p><img src="tomcat类加载器.png" alt="image-20201022232855659"></p>
<ol>
<li>Bootstrap层次：主要加载jre核心类，可以通过-bootclasspath的方式来进行负载</li>
<li>Extension层次：主要是用来加载Java核心代码，对于核心代码进行修改，可以通过以上的方式</li>
<li>System层次：对于-classpath和-module-path的jar包，一概都是由System类加载进行加载。所以，对于应用程序来说，大部分的类都是由System Class Loader来加载的。只有类是由System层次加载的，才会使用CDS（Class Data Sharing)来进行加载的。对于bootstrap.jar和catalina-juli.jar都是由该类加载进行加载。</li>
<li>Common Class Loader:Common类加载器是Tomcat类加载器，主要用来加载Tomcat启动应用服务器内部和Web应用均可见的类。可以在catalina.properties进行配置。</li>
<li>Catalina Class Loader:用来加载只有Tomcat应用服务器内部可见的类，对于业务是不可见的。可以在catalina.properties进行配置。</li>
<li>Shared Class Loader:用来加载Web应用共享的类，这些类Tomcat服务器不会依赖。可以在catalina.properties进行配置。</li>
<li>Web App Class Loader:用来加载Web应用的类，该类只有该Context下才可见。</li>
</ol>
<p>Tomcat提供的Web应用类加载器与默认的委托模式有所不同。当进行类加载时，除JVM基础类库外，它会首先尝试通过当前类加载器加载，然后进行委托。Servlet规范相关API禁止通过。</p>
<ol>
<li>从缓存中加载</li>
<li>如果没有，则从JVM的Bootstrap类加载器加载</li>
<li>如果没有，则从当前类加载器加载，按照WEB-INF/classes，WEB-INF/lib的顺序</li>
<li>如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序为System，Common，Shared。</li>
</ol>
<p>Tomcat提供了delegate属性用于控制是否启动Java委派模式，默认为false（不启动），当配置为true的时候，Tomcat将使用Java默认的委派模式，即</p>
<ol>
<li>从缓存中加载</li>
<li>如果没有，从JVM的Bootstrap类加载器加载</li>
<li>如果没有，则从父类加载器加载（System,Common,Shared)</li>
<li>如果没有，则从当前类加载加载</li>
</ol>
<p>Tomcat还可以通过packageTriggersDeny属性只让某些包路径采用Java的委派模式，Web应用类加载器对于符合packageTriggersDeny指定包路径的类强制采用Java的委派模式。</p>
<p>Tomcat通过该机制实现为Web应用中的Jar包覆盖服务器提供包的目的。Java核心类库/Servlet规范相关类库是无法覆盖的，此外Java默认提供的诸如XML工具包，由于位于JVM的Bootstrap类加载也无法覆盖，只能通过endorsed的方式来实现。</p>
<h3 id="Web请求处理"><a href="#Web请求处理" class="headerlink" title="Web请求处理"></a>Web请求处理</h3><ol>
<li>根据Connector的请求和响应对象创建Servlet请求和响应</li>
<li>转换请求参数并完成请求映射</li>
<li>得到当前的Engine的第一个Valve并执行，完成客户端请求处理</li>
<li>对于Engine，Host，Context，Wrapper中Pipeline中Valve进行处理</li>
<li>对于ApplicationFilterChain和Filter进行处理</li>
<li>找到对应的Servlet，并进行处理</li>
</ol>
<h3 id="Tomcat配置文件"><a href="#Tomcat配置文件" class="headerlink" title="Tomcat配置文件"></a>Tomcat配置文件</h3><ol>
<li>catalina.properties:该列主要是对类加载器的配置</li>
<li>server.xml：用来配置启动过程的Service，Host，Context等配置</li>
<li>context.xml：用来配置寻找web.xml</li>
<li>web.xml：主要是类的应用逻辑的配置，包括Filter配置等</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tomcat介绍&quot;&gt;&lt;a href=&quot;#tomcat介绍&quot; class=&quot;headerlink&quot; title=&quot;tomcat介绍&quot;&gt;&lt;/a&gt;tomcat介绍&lt;/h2&gt;&lt;h3 id=&quot;应用服务器和Web服务器的区别&quot;&gt;&lt;a href=&quot;#应用服务器和Web服务器的区
    
    </summary>
    
      <category term="微服务" scheme="https://caixueyuan.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="服务器" scheme="https://caixueyuan.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba微服务原理与实战</title>
    <link href="https://caixueyuan.github.io/2020/09/28/Spring-Cloud-Alibaba%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>https://caixueyuan.github.io/2020/09/28/Spring-Cloud-Alibaba微服务原理与实战/</id>
    <published>2020-09-28T15:57:44.000Z</published>
    <updated>2020-10-12T15:51:51.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务的发展史"><a href="#微服务的发展史" class="headerlink" title="微服务的发展史"></a>微服务的发展史</h2><h3 id="网站发展历史"><a href="#网站发展历史" class="headerlink" title="网站发展历史"></a>网站发展历史</h3><ol>
<li>单体架构：所有功能都集中在一个war包，部署到一个tomcat web服务器中。（缺点：耦合，一个功能点异常会影响整个应用）</li>
<li>集群及垂直化：通过功能进行划分，将一个巨婴划分成多个不同的模块，不同的模块可以部署到不同的机器中（缺点：无法扩展，需要重复实现功能，比如鉴权等）</li>
<li>SOA：面向服务的架构，核心目的是把一些通用的，会被多个上层服务调用的共享业务提取出独立的基础服务，可以被重用，主要解决了信息孤岛和共享业务的重用问题</li>
<li>微服务架构：对于面向服务的进一步细化，微服务关注的是解耦，降低业务之间的耦合度，而重用性关注的是服务的复用。可以这样理解：微服务是对SOA的进一步细化，多个微服务的功能集合相当于一个SOA。同时，也实现了DevOps持续交付。（说白了，服务跟代码是一个道理，只要实现了高内聚，低耦合都能够更好地实现了DevOps，由于微服务的粒度比较小，如果抽取成微服务的粒度和功能得当，本身就能够实现高内聚，低耦合）</li>
</ol>
<h3 id="微服务架构："><a href="#微服务架构：" class="headerlink" title="微服务架构："></a>微服务架构：</h3><p>微服务的架构图如下：</p>
<p><img src="微服务架构简图.png" alt="image-20200929003609063"></p>
<h2 id="Spring-Cloud的核心之Spring-Boot"><a href="#Spring-Cloud的核心之Spring-Boot" class="headerlink" title="Spring Cloud的核心之Spring Boot"></a>Spring Cloud的核心之Spring Boot</h2><h3 id="重新认识Spring-Boot"><a href="#重新认识Spring-Boot" class="headerlink" title="重新认识Spring Boot"></a>重新认识Spring Boot</h3><p><strong>核心思想为约定胜于配置</strong></p>
<h4 id="Spring-IOC-DI"><a href="#Spring-IOC-DI" class="headerlink" title="Spring IOC/DI"></a>Spring IOC/DI</h4><p><strong>IoC(控制反转)</strong>：对象的创建不是由代码通过new来创建的，而是通过Spring容器来进行控制的，程序只是使用容器来控制程序的运行</p>
<p><strong>DI(依赖注入)</strong>：IoC容器在运行期间，动态地把某些依赖关系注入组件中，来创建一个容器出来。</p>
<p>以前所有的配置都是基于XML配置文件来运行的，Spring Boot的出现只是用来简化Spring应用开发</p>
<p>约定优于配置是一种软件设计模式，目的不是在于减少依赖，但是，而是在于减少配置数量或者降低理解难度，从而来提高开发效率。理由如下：运用Spring Boot容器的方式，实际上依赖的数量和复杂度并没有变化，因为外界的依赖就是有这么多，软件本身是根据实物来抽象出来的，所以软件抽象出来的依赖并没有发生变化，通过Spring 容器的方式只是将依赖集中化管理而已）。设计模式的本身也不能够减少抽象出来的实体的依赖，只是对这些依赖做抽象（比如，抽象成聚合，组合，实现等关系，给予不同的依赖不同的涵义，帮助软件的设计和管理）</p>
<h4 id="Spring-Boot自动装配的原理"><a href="#Spring-Boot自动装配的原理" class="headerlink" title="Spring Boot自动装配的原理"></a>Spring Boot自动装配的原理</h4><p>自动装配的核心是扫描约定目录下的文件进行解析，解析完成之后得到的Configuration配置类通过ImportSelector进行导入。从而完成Bean的自动装配过程。</p>
<p>扫描  -&gt;  Bean,Configuration  -&gt;  自动装配（解决相互依赖）   -&gt;  容器（获取Bean） -&gt;   功能运行</p>
<h2 id="微服务架构下的服务治理"><a href="#微服务架构下的服务治理" class="headerlink" title="微服务架构下的服务治理"></a>微服务架构下的服务治理</h2><p>服务与服务之间的远程通讯是分布式架构最基本的组成部分，传统意义上的远程通讯，更多的时候是解决信息孤岛及数据互联互通问题，它更多关注的是数据的共享。微服务架构思想的落地，更多注重的是服务与服务之间的解耦。</p>
<h4 id="Apache-Dubbo"><a href="#Apache-Dubbo" class="headerlink" title="Apache Dubbo"></a>Apache Dubbo</h4><p>Apache Dubbo是一个统一的服务治理框架，对服务进行统一/有效的管控，从而保证服务的高效/健康运行。提供了服务治理功能，比如服务注册，监控，路由和容错。核心功能就是监控和服务注册发现。</p>
<p><img src="Dubbo架构.png" alt="image-20200929232959375"></p>
<p>Dubbo主要实现点对点的形式来实现服务的通讯（可以把Dubbo看成一种通讯协议），Dubbo可以很好地集成注册中心来实现服务地址的统一管理。比如使用zookeeper来进行管理。</p>
<p>ZooKeeper</p>
<h4 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h4><p>ZooKeeper的数据是结构化存储的，并没有在物理上体现出文件和目录。ZooKeeper树中的每个节点被称为Znode，维护一个stat状态信息，其中包含数据变化的时间和版本，并且每个Znode可以设置一个value值。每个节点的数据都是允许读和写的.并且Znode的状态发生变化之后,会有事件进行通知.节点的类型如下:</p>
<ol>
<li>持久化节点:节点的数据会被持久化到磁盘中</li>
<li>临时节点:节点的声明周期和创建该节点的客户端的生命周期保持一致,一旦该客户端的会话结束,则该客户端所创建的临时节点会被自动创建(每个节点可以代表一个微服务的状态)</li>
<li>有序节点:在创建的节点后面会增加一个递增的序列,该序列在同一级父节点之下是唯一的.</li>
<li>容器节点:当容器节点下的最后一个子节点被删除时,容器节点就会被自动删除</li>
<li>TTL节点:针对持久化节点或持久化有序节点,可以设置一个存活时间,如果在存活时间之内,该节点没有任何修改并且没有任何子节点,它会被自动删除.</li>
</ol>
<h4 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h4><ol>
<li>分布式独占锁:使用临时节点,在同一个目录中进行创建,谁能够创建成功,谁就能够访问资源.获取独占锁之后,完成工作之后,临时节点进行删除.这个时候其他进程再通过相同的方式进行创建.</li>
<li>Master选举:第一种方法,通过独占锁的方式来实现Master选举,谁能够创建临时节点的话,谁就是Master,其他的不能够创建成功的微服务都对该处做了订阅;第二个方式是通过临时有序节点的特性来实现,每个微服务分前后的方式构成了一个有序节点,每个节点都注册了对于前一个节点的订阅.如果前面的节点被删除的话,后面一个就成为Master节点.</li>
</ol>
<p>Apache Dubbo集成ZK来实现服务注册</p>
<ol>
<li>服务动态上下线感知:就是服务调用者要感知到服务提供者上下线的变化</li>
<li>负载均衡</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>Dubbo服务启动时,会去ZooKeeper服务器上的/dubbo/com.gupaoedu.book.dubbo.IHelloService/providers目录下创建当前服务的URL,其中com.gupaoedu.book.dubbo.IHelloService是发布服务的接口全路径名称,providers表示服务提供者的类型,dubbo://ip:port表示该服务发布的协议及访问端口.其中URL是临时节点,如果微服务下线的话,节点就不存在了.</p>
<p><img src="Dubbo_ZooKeeper.png" alt="image-20200930001149410"></p>
<p>当Dubbo服务消费者启动时,会对/dubbo/com.gupaoedu.book.dubbo.IHelloService/providers节点下的子节点注册Watcher监听,感知服务提供方节点的上下线变化.服务消费者会在dubbo/com.gupaoedu.book.dubbo.IHelloService/consumers下写入自己的URL,这样做的目的是可以在监控平台上看到Dubbo服务正在被哪些服务调用.Dubbo服务的消费者通过获取providers下的服务,然后调用负载均衡算法(Sentitle)来计算出一个地址来进行远程访问(比如实现灰度发布)</p>
<p>dubbo在这里实现的功能就是注册发现服务,比如注册是在对应Znode(providers)中创建临时节点.发现服务是在对应Znode(consumers)中创建临时节点.ZooKeeper的粒度不是以微服务为单位,而是以服务提供者提供的接口为粒度.每个接口的下面有providers和consumers两个持久化节点.</p>
<p><img src="dubbo_zookeeper原理.png" alt="image-20200930004124454"></p>
<h4 id="Dubbo高级应用"><a href="#Dubbo高级应用" class="headerlink" title="Dubbo高级应用"></a>Dubbo高级应用</h4><p>对于Dubbo的高级功能，目前有较多的三方件有替代功能。</p>
<ol>
<li>集群容错：<ol>
<li><strong>Failover Cluster</strong>:失败自动切换。当服务调用失败后，会切换到集群中的其他机器进行重试。</li>
<li><strong>Failfast Cluster</strong>：快速失败。当服务调用失败，立即报错</li>
<li><strong>Failsafe Cluster</strong>:失败安全，出现异常后，直接忽略异</li>
</ol>
</li>
<li>负载均衡：目前Dubbo提供了4中负载均衡策略，默认是随机算法。</li>
<li>服务降级：把一些非必要的功能在流量较大的时间段暂时关闭。</li>
</ol>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><h3 id="Alibaba-Nacos"><a href="#Alibaba-Nacos" class="headerlink" title="Alibaba Nacos"></a>Alibaba Nacos</h3><p>Nacos致力于解决微服务中统一配置，服务注册与发现等问题。</p>
<ol>
<li>Nacos支持基于DNS和基于RPC的服务发现。服务提供者使用SDK/OpenAPI或者一个独立的Agent TODo注册Service后，服务消费者可以使用DNS或HTTP/API查找和发现服务。Nacos提供对服务的实时健康检查，阻止向不健康的主机或服务实例发送请求。</li>
<li>动态配置服务。动态配置服务可以以中心化，外部化和动态化的方式管理所有环境的应用配置和服务配置，可以使配置管理变得更加高效和敏捷。配置中心化管理实现无状态服务更加简单，让服务按需弹性扩展变得更容易。</li>
</ol>
<h3 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h3><p>Nacos提供了SDK及Open API的方式来完成服务注册与发现。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># 注册微服务</span></div><div class="line"><span class="symbol">OpenAPI:</span><span class="meta-keyword">/nacos/</span>v1<span class="meta-keyword">/ns/</span>instance(POST)</div><div class="line"><span class="symbol">SDK:</span>void registerInstance(String serviceName,String ip,String port) throws NacosException</div><div class="line"><span class="meta"># 获取所有实例</span></div><div class="line">Open API:<span class="meta-keyword">/nacos/</span>v1/instancelist(GET)</div><div class="line"><span class="symbol">SDK:</span> List<span class="params">&lt;Instance&gt;</span> getAllInstances(String serviceName) throws NacosException</div><div class="line"><span class="meta"># 监听服务(监听指定服务下的实例变化，监听服务机制可以让客户端及时感知服务提供者实例的变化)</span></div><div class="line">Open API:<span class="meta-keyword">/nacos/</span>v1<span class="meta-keyword">/ns/</span>instance/list(GET)</div><div class="line">SDK void subscribe(String serviceName,EventListener listener) throws NacosException</div></pre></td></tr></table></figure>
<h3 id="Nacos高可用部署"><a href="#Nacos高可用部署" class="headerlink" title="Nacos高可用部署"></a>Nacos高可用部署</h3><p>Nacos提供了类似于ZooKeeper的集群架构，包括一个Leader节点和多个Follow节点。和ZooKeeper不同的是，它的数据一致性算法采用的是Raft。</p>
<p>Nacos作为Spring Cloud Alibaba中服务注册与发现的核心组件，可以很好地帮助开发者将服务自动注册到Nacos服务端，并且能够动态感知和刷新某个服务实例的服务列表中。</p>
<p><img src="Nacos原理.png" alt="image-20201008233637596"></p>
<p>注册中心实现原理</p>
<ol>
<li>服务实例在启动时注册到服务注册者，并在关闭时注销</li>
<li>服务消费者查询服务注册表，获得可用实例</li>
<li>服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求。</li>
</ol>
<p><img src="注册中心.png" alt="image-20201008235558711"></p>
<p>Dubbo在这里只是作为一个通讯协议。</p>
<p>Nacos Naming Service作为单独的微服务，能够提供注册中心的作用，并且自身能够实现集群算法统一。</p>
<p><strong>Dubbo+Nacos Service与Dubbo+ZooKeeper的联系与区别</strong>：</p>
<ol>
<li>共同点:Nacos Service和ZooKeeper都提供了分布式集群信息通讯的作用，保证了信息的分布式节点的一致性</li>
<li>不同点：Dubbo + Nacos Service的方式下，实际上是通过Nacos的Open API的方式来实现了服务的注册与发现。并且，Nacos自身能够记录Open API存储的信息，保证在多个节点中的一致性的问题。Dubbo在这里只是作为通讯协议的作用</li>
<li>Dubbo + ZooKeeper时，Dubbo提供了服务的注册与发现的作用，Dubbo通过在分布式存储ZooKeeper中建立固定节点和临时节点的方式来实现服务的注册与发现，Dubbo在这里不仅仅提供了通讯协议的功能，还提供了服务的注册与发现的功能。而内部信息在多节点的一致性是通过ZooKeeper来进行保证的。</li>
</ol>
<p>心跳机制：就是客户端通过schedule定时向服务端发送一个数据包，然后启动一个线程不断检查服务端的回应。如果在设定时间内没有收到服务端的回应，则认为服务器出现故障。Nacos服务端会根据客户端的心跳包不断更新服务的状态。（是一个双向过程）</p>
<h2 id="Nacos实现统一配置管理"><a href="#Nacos实现统一配置管理" class="headerlink" title="Nacos实现统一配置管理"></a>Nacos实现统一配置管理</h2><p>各个应用自己独立维护本地配置的方式有其局限性：</p>
<ol>
<li>配置的动态更新。本地配置变化需要重启微服务才能够实现配置更新</li>
<li>配置集中化管理：在微服务中，微服务实例可能有上百个，如果配置属性发生变化的话，变更工作量是巨大</li>
<li>配置内容的安全性和权限。配置文件随着源代码统一提交到代码库中，容易造成生产环境配置信息的数据泄露</li>
<li>不同部署环境下配置的管理。</li>
</ol>
<p>最基本的方法就是把各个应用系统中的某些配置放在一个第三方中间件上进行统一维护。然后，对于统一配置中心上的数据的变更需要推动到相应的服务节点实现动态更新。包括Config Server和Config Client.</p>
<h3 id="Spring-Cloud-Alibaba-Nacos-Config"><a href="#Spring-Cloud-Alibaba-Nacos-Config" class="headerlink" title="Spring Cloud Alibaba Nacos Config"></a>Spring Cloud Alibaba Nacos Config</h3><p>Nacos 实现在不同的环境中加载不同配置的能力，主要是通过文件名来进行加载。在Spring Cloud Alibaba Nacos Config中加载Nacos Config Server中的配置对，不仅加载了Data ID以<code>${spring.application.name}.${file-extension:properties}</code>为前缀的基础配置，还会加载Data ID为<code>${spring.application.name}-${profile}.${file-extension:properties}</code>的基础配置</p>
<p><strong>bootstrap.properties</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring<span class="selector-class">.cloud</span><span class="selector-class">.nacos</span><span class="selector-class">.config</span><span class="selector-class">.file-extension</span>=yaml</div><div class="line">spring<span class="selector-class">.profiles</span><span class="selector-class">.active</span>=prod</div><div class="line">spring<span class="selector-class">.application</span><span class="selector-class">.name</span>=spring-cloud-nacos-config-sample</div></pre></td></tr></table></figure>
<p>如上图所示，可以通过加载<code>spring-cloud-nacos-config-sampl-prod.yaml</code>文件来实现微服务配置文件加载</p>
<h3 id="Nacos-Config自定义Namespace和Group"><a href="#Nacos-Config自定义Namespace和Group" class="headerlink" title="Nacos Config自定义Namespace和Group"></a>Nacos Config自定义Namespace和Group</h3><p>Nacos Config都采用默认的Namespace:public和Group：DEFAULT_GROUP.其中Namespace用于解决多环境及多租户用户数据的隔离问题，比如根据指定环境创建不同的Namespace，实现多环境的隔离，或者在多用户的场景中，每个用户可以维护自己的Namespace，实现每个用户的配置数据和注册数据的隔离。而Group可以更加专注于业务层面的数据分组。</p>
<p>Namespace -&gt;   Group   -&gt;   Data ID(通过Namespace-Group-DataID来获取到配置文件)</p>
<h3 id="Nacos-Config实现原理解析"><a href="#Nacos-Config实现原理解析" class="headerlink" title="Nacos Config实现原理解析"></a>Nacos Config实现原理解析</h3><h4 id="提供接口"><a href="#提供接口" class="headerlink" title="提供接口"></a>提供接口</h4><ol>
<li>获取配置，从Nacos Config Server中读取配置</li>
<li>监听配置：订阅感兴趣的配置，当配置发生变化时可以收到一个事件</li>
<li>发布配置：将配置发布到Nacos Config Server</li>
<li>删除配置：删除配置中心的指定配置</li>
</ol>
<h4 id="配置的CRUD"><a href="#配置的CRUD" class="headerlink" title="配置的CRUD"></a>配置的CRUD</h4><p>如何能够实现Nacos Server的数据一致性：通过数据库来实现持久化</p>
<p><img src="Nacos配置中心.png" alt="image-20201009233748455"></p>
<p>配置中心通过数据库来实现持久化，Config Service提供外部访问接口，来添加配置和删除配置等。Nacos Client是作为一个微服务实例，能够拉取最新的配置。</p>
<h4 id="动态监听之Pull-Or-Push"><a href="#动态监听之Pull-Or-Push" class="headerlink" title="动态监听之Pull Or Push"></a>动态监听之Pull Or Push</h4><ol>
<li>Pull：客户端从服务端主动拉取数据，客户端需要定时从服务端拉取一次数据，由于定时任务会存在一定的时间间隔，所以不能够实现实时更新。并且，如果没有服务端配置长时间不更新的情况下，会造成无效的Pull</li>
<li>Push：服务端主动把数据推送到客户端中，能够实现实时更新。但是呢，服务端需要维护与客户端的长连接，如果客户端的数量较多的话，需要耗费大量的内存资源来保存每个连接，并且检测连接的有效性，还需要心跳机制来维护每个连接的状态。对于消息的发送的复杂性集中与服务端中，由服务端来控制连接的存在，以及如果事件更新较快的话，可能会存在挤压。</li>
</ol>
<p>Nacos使用的是长轮询机制。所谓长轮询机制的好处在于：客户端自动拉取数据，由客户端来控制配置的更新，不需要服务器来维护与客户端的链接，能够减少服务端的资源使用量。并且，由于长轮询时间比较长，能够减少客户端发起请求的无效资源消耗量。另外，如果在长轮询过程中，出现事件更新的话，能够直接返回请求，来达到实时推送的作用，从而达到PUSH的操作。也就是说长轮询能够实现主动拉取（PULL）和实时推送（PUSH）</p>
<h4 id="长轮询机制"><a href="#长轮询机制" class="headerlink" title="长轮询机制"></a>长轮询机制</h4><p><img src="长轮询机制.png" alt="image-20201010001323906"></p>
<p><strong>长轮询的步骤如下：</strong></p>
<ol>
<li>客户端发起请求</li>
<li>请求被客户端处理，检查配置是否发生更新，如果配置已经发生更新的话，请求直接返回</li>
<li>如果请求到达时，请求没有发生变化，该请求进入到缓存队列中。如果在长轮询的过程中（比如29.5s中），有配置发生变化的话，通过遍历缓存中的对象（或者通过Map的方式来实现定点快速更新的方式），来将该请求进行返回</li>
<li>如果在长轮询的过程中（比如29.5s后）配置依然没有发生变化的，那么请求在定时任务的作用下，检查配置是否返回变化，并且返回最终的结果。</li>
</ol>
<p>优化点:这样的话，对于每个配置需要进行两次配置检查，第一次为处理PULL请求，第二次为定时任务检查配置是否更新。可以减少第二次配置检查，将这一此配置更新检查顺延到下一次的长轮询请求，来减少空闲请求占用的资源。也就是优化第4步，让其不做检查，直接返回结果。</p>
<h2 id="基于Sentinel的微服务限流及熔断"><a href="#基于Sentinel的微服务限流及熔断" class="headerlink" title="基于Sentinel的微服务限流及熔断"></a>基于Sentinel的微服务限流及熔断</h2><p>服务器处理请求的能力是有限的。有限的原因是在目前使用阻塞式的服务器（如tomcat）等，服务器处理每个请求都需要新建新的线程进行处理，消耗大量的资源。所以需要一定的系统保护策略：比如服务降级，限流和熔断等。</p>
<h3 id="服务限流的作用及实现"><a href="#服务限流的作用及实现" class="headerlink" title="服务限流的作用及实现"></a>服务限流的作用及实现</h3><p>限流的目的是通过限制并发访问数或者限制一个时间窗口内允许处理的请求数量来保护系统，一旦达到限制数量则对当前请求则对当前请求进行处理采用对应的拒绝策略，比如跳转到错误页面拒绝请求，进行排队系统，降级等。从本质上说，限流的主要作用是损失一部分用户的可用性，为大部分用户提供稳定可靠的服务。</p>
<h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>计数器算法：在指定周期内累加访问次数，当访问次数达到设定的阈值时，触发限流策略，当进入下一个时间周期内进行访问次数的清零。</p>
<p>缺点:无法解决瞬间值，比如在极短时间接收到很多请求，但是又不超过该时间周期允许的最大请求数，会系统造成危险。</p>
<h4 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h4><p>在固定窗口中分割出多个小时窗口，分别在每个小时间窗口记录访问次数，然后根据时间将窗口往前移动并删除过期的小时间窗口。最终只需要滑动窗口范围内的所有小时间窗口总的计算即可。该算法可以保证请求的速度平均。（TCP窗口就是该算法）</p>
<h4 id="令牌桶限流算法"><a href="#令牌桶限流算法" class="headerlink" title="令牌桶限流算法"></a>令牌桶限流算法</h4><p>令牌桶是网络流量整形和速率限制中最常使用的一种算法。对于每个请求，都需要从令牌桶中获得一个令牌，如果没有获得令牌，则需要触发限流策略。由于令牌桶有固定的大小，当请求速度小于令牌生成速度时，令牌桶会被填满。所以令牌桶能够处理突发流量。</p>
<p><img src="令牌桶.png" alt="image-20201011144449924"></p>
<h4 id="漏桶限流算法"><a href="#漏桶限流算法" class="headerlink" title="漏桶限流算法"></a>漏桶限流算法</h4><p>主要的作用是控制数据流入网络的速度，平滑网络上的突发流量。在漏桶算法内部同样维护一个容器，不管上面的水流速度多块，漏桶水滴的流出速度始终保持不变。实际上消息中间件就使用漏桶限流的思想。不管生产者的请求量有多大，消息的处理能力取决于消费者。</p>
<h3 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h3><p>服务熔断是指当某个服务提供者无法正常为服务调用者提供服务时，比如请求超时，服务异常时，为了防止整个系统出现雪崩效应，暂时将出现故障的接口隔离出来，断绝与外部接口的联系，当触发熔断之后，后续一段时间内该服务调用者的请求都会直接失败，直到目标服务恢复正常。一般通过平均响应时间，异常比例，异常数量来进行控制。</p>
<h3 id="分布式限流框架Sentinel"><a href="#分布式限流框架Sentinel" class="headerlink" title="分布式限流框架Sentinel"></a>分布式限流框架Sentinel</h3><p>该框架由两部分组成</p>
<ol>
<li>核心库（Java客户端）：能够运行在所有Java运行时环境</li>
<li>控制台（DashBoard)：基于Spring Boot开发，服务器端，用来展示机器发现，健康情况管理，监控，规则管理和推送的功能</li>
</ol>
<p>主要由三个要素：</p>
<ol>
<li>定义资源</li>
<li>定义限流规则</li>
<li>检验规则是否生效</li>
</ol>
<h4 id="限流规则"><a href="#限流规则" class="headerlink" title="限流规则"></a>限流规则</h4><ol>
<li>基于并发数和QPS（吞吐量）的流量控制</li>
<li>QPS流量控制行为（默认为直接拒绝，冷启动，匀速排队，冷启动+匀速排队）</li>
<li>调用关系流程策略（根据调用方限流，调用链路入口，具有关系的资源流量控制）</li>
</ol>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>可以通过Sentinel DashBoard来配置对每个URL的规则的定制</p>
<p>定义资源需要用户通过注解的方式进行定义。可以通过FlowRuleManager.loadRules()手动加载流控规则，也可以通过Sentinel Dashboard上针对资源动态创建流控规则。</p>
<h3 id="Sentinel架构"><a href="#Sentinel架构" class="headerlink" title="Sentinel架构"></a>Sentinel架构</h3><p><img src="Sentinel架构图.png" alt="image-20201011152453119"></p>
<p>Sentinel使用责任链模式，来对访问资源的请求进行保护，保证对每个请求都遍历每个规则进行验证。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>概念：ACID</p>
<p>原子性（Atomicity):事务必须是原子工作单元，不可继续分割，要么全部成功，要不全部失败</p>
<p>一致性（Consistency):事务完成时，所有的数据都必须保持一致</p>
<p>隔离性（Isolation):由并发事务所做的修改必须与任何并发事务所做的修改隔离</p>
<p>持久性（Durability):事务执行完成之后，它对系统的影响是永久性的。</p>
<p><strong>分布式事务</strong>是指事务的参与者，支持事务的服务器，资源服务器及事务管理器分别位于分布式系统的不同节点上。</p>
<p><strong>分布式事务存在的意义</strong>：在单体应用中，由于都是在Java中进行运行，可以通过Java锁等模式来控制原子特性。但是在不同进程或者不同节点上，缺少统一的对进程的管理，很难保证原子性。并且分布式系统，基于解耦的要求，数据拆分比较具体，存储资源的分布性。</p>
<h3 id="分布式事务问题的理论模型"><a href="#分布式事务问题的理论模型" class="headerlink" title="分布式事务问题的理论模型"></a>分布式事务问题的理论模型</h3><h4 id="X-OPEN分布式事务模型（二阶段提交）（2PC）"><a href="#X-OPEN分布式事务模型（二阶段提交）（2PC）" class="headerlink" title="X/OPEN分布式事务模型（二阶段提交）（2PC）"></a>X/OPEN分布式事务模型（二阶段提交）（2PC）</h4><p><img src="2段式.png" alt="image-20201011155503172"></p>
<p>缺点：资源在经过二段式任务时，资源一致被锁定。并且，如果在二段式任务的过程中，如果TM进程消失时，会出现资源永远被锁住的情况，因为资源锁住是没有超时时间的。并且，所有参与者（RM）都是事务阻塞性，对于任何一个指令，都必须要有明确的响应才能够执行下一步，否则处于阻塞状态，占用的资源一直被占用。</p>
<h4 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h4><p>在二段式提交的基础上，增加了一个询问阶段（TM向RM发送事务执行操作，询问是否可以完成指令，参与者只需要回答是或者不是即可，不需要做真实的操作）</p>
<p>相对于二段式提交，增加了超时机制，可以防止资源因为TM失败而被永久锁定），但是依然会出现脑裂情况，资源被占用较大的情况）</p>
<p>Zookeeper集群中的数据一致性，用到优化版的二阶段提交协议，优化的地方在于它不需要所有参与者在第一阶段返回成功才能提交事务，而是利用少数服务多数的投票机制来完成数据的提交或者回滚</p>
<h4 id="CAP定理和BASE理论"><a href="#CAP定理和BASE理论" class="headerlink" title="CAP定理和BASE理论"></a>CAP定理和BASE理论</h4><hr>
<p><strong>CAP定理</strong>：在分布式系统中不可能同时满足一致性，可用性，分区容错性。</p>
<ol>
<li>C:一致性，数据在多个副本中要保持一致</li>
<li>A：可用性，系统对外提供的服务必须一直处于可用状态</li>
<li>P：在分布式系统中遇到任何网络分区故障，系统仍然能够正常对外提供服务</li>
</ol>
<p>AP：放弃强一致性，实现最终的一致性，这是很多互联网公司解决分布式数据一致性问题的主要选择</p>
<p>CP：放弃高可用性，实现强一致性。前面提到的二阶段提交和三阶段提交都是采用这种方案，可能会导致用户完成一个操作会等待很长时间。</p>
<hr>
<p><strong>BASE理论：</strong>通过牺牲数据的强一致性来获得高可用性：</p>
<ol>
<li>Basically Available:(基本可用)：分布式系统在出现故障时，这个状态不影响系统的可用性，保证核心功能的可用</li>
<li>Soft State(软状态)：允许系统中的数据存在中间状态，这个状态不影响系统的可用性，也就是允许系统中不同节点的数据副本之间的同步存在延迟</li>
<li>Eventually Consisteng(最终一致性)：中间状态的数据在经过一段时间之后，会达到最终的数据一致性。</li>
</ol>
<p>也就是说，并不是要求数据的强一致性，在任何时刻都是一致性的，而是允许数据在一段时间内是不一致的，但是最终要是一致的。也就是说事务最终一定要完成，但是事务处理的过程中，数据允许不一致。</p>
<h3 id="分布式事务问题的常见解决方案"><a href="#分布式事务问题的常见解决方案" class="headerlink" title="分布式事务问题的常见解决方案"></a>分布式事务问题的常见解决方案</h3><h4 id="TCC补偿性方案"><a href="#TCC补偿性方案" class="headerlink" title="TCC补偿性方案"></a>TCC补偿性方案</h4><p>是一种比较成熟的分布式数据一致性解决方案，分为三个步骤：</p>
<ol>
<li>Try:对数据的校验或者资源的预留</li>
<li>Confirm:确认真正执行的任务，只操作Try阶段预留的资源</li>
<li>Cancel:取消执行，释放Try阶段预留的资源</li>
</ol>
<p><strong>实际上是一个二段式提交的模型，只是在二段式提交的基础上，增加了失败重试机制来补偿失败场景</strong>。TCC事务框架会记录一些分布式事务的操作日志，保存分布式事务运行的各个阶段和状态，TCC事务协调器会根据操作日志进行重试，以达到数据的最终一致性。</p>
<h4 id="基于可靠性信息的最终一致性方案"><a href="#基于可靠性信息的最终一致性方案" class="headerlink" title="基于可靠性信息的最终一致性方案"></a>基于可靠性信息的最终一致性方案</h4><p>基于可靠性信息传递来保证数据的一致性</p>
<p><img src="基于可靠性信息原理图.png" alt="image-20201011170548764">3</p>
<p><img src="基于可靠性信息原理.png" alt="image-20201011171152740"></p>
<h3 id="分布式事务框架Seata"><a href="#分布式事务框架Seata" class="headerlink" title="分布式事务框架Seata"></a>分布式事务框架Seata</h3><h4 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h4><p>AT模式是Seata最主推的分布式事务解决方案，基于XA进行演进。</p>
<p><img src="AT模式.png" alt="image-20201011171914447"></p>
<p>该模式实现分布式事务的中心化管理，保证了微服务只跟中心程序进行联系，而不用自己控制整个XA事务，从之前的网状式变成中心化管理</p>
<p>TC：Seata的服务器独立部署（通过独立部署做中心化管理）</p>
<p>TM:事务管理器</p>
<p>RM：资源管理器</p>
<ol>
<li>TM向TC注册全局事务，并生成全局唯一的XID</li>
<li>RM向TC注册分支事务，并将其纳入该XID对应的全局事务范围</li>
<li>RM向TC汇报资源的准备状态</li>
<li>TC汇总所有事务参与者的执行状态，决定分布式事务是全部回滚还是提交</li>
<li>TC通知所有RM提交和回滚事务</li>
</ol>
<h4 id="AT模式实现原理"><a href="#AT模式实现原理" class="headerlink" title="AT模式实现原理"></a>AT模式实现原理</h4><p>整体机制也是一个改进版的两阶段提交协议：</p>
<ol>
<li>第一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源</li>
<li>第二阶段：提交异步化：非常快速地完成。回滚通过第一阶段的回滚日志进行反向补偿。</li>
</ol>
<p>第一阶段：</p>
<p><img src="全局事务第一阶段.png" alt="image-20201011174716862"></p>
<p>第二阶段：</p>
<p><img src="全局事务提交.png" alt="image-20201011174624448"></p>
<p><img src="全局事务回滚.png" alt="image-20201011174549481"></p>
<p>该模式不一定能够成功：特别是对于较复杂的场景，比如数据库中有触发器的模式下，有可能会失败。</p>
<h2 id="RocketMQ分布式消息通讯"><a href="#RocketMQ分布式消息通讯" class="headerlink" title="RocketMQ分布式消息通讯"></a>RocketMQ分布式消息通讯</h2><p>消息通讯的作用：传统的HTTP/RPC通讯都是实时的，而消息通讯时通信非实时的，可以降低服务之间的耦合，提高系统的处理能力。（主要把消息发送出去就行啦，后续的消息的处理是由消费者进行处理，实现了解耦）</p>
<h3 id="Spring-Cloud-Alibaba-RocketMQ"><a href="#Spring-Cloud-Alibaba-RocketMQ" class="headerlink" title="Spring Cloud Alibaba RocketMQ"></a>Spring Cloud Alibaba RocketMQ</h3><p>Spring Cloud Stream的实现基于发布/订阅机制，核心由四部分构成：</p>
<ol>
<li><strong>1Spring Messaing:统一消息编程模型</strong></li>
</ol>
<p>Message:消息对象，包含消息头Header和消息体PayLoad</p>
<p>MessageChannel:消息通道接口，用于接受消息，提供send方法将消息发送到消息通道</p>
<p>MessageHandle：消息处理器接口，用于处理消息逻辑</p>
<ol>
<li><strong>Spring Integration:</strong></li>
</ol>
<p>MessageDispatcher:消息分发接口，用于分发消息和添加删除消息处理器</p>
<p>MessageRouter:消息路由接口，定义默认的输出消息通道</p>
<p>Filter:消息的过滤注解，用于配置消息过滤表达式</p>
<p>Aggregator:消息的聚合注解，用于将多条消息聚合成一条</p>
<p>Splitter:消息的分割，用于将一条消息拆分成多条</p>
<ol>
<li><strong>Bingders:目标绑定器，负责与外部消息中间件系统集成的组件</strong></li>
</ol>
<p>doBindProducer:绑定消息中间件客户端发送消息模块</p>
<p>doBindConsumer:绑定消息中间件客户端接受消息模块</p>
<ol>
<li><strong>Bindings：外部消息中间件系统与应用程序提供的消息生产者与消费者（由Binders创建）之间的桥梁。</strong></li>
</ol>
<p><img src="RocketMQ代码原理.png" alt="image-20201011190611081"></p>
<p>Spring Cloud Stream提供了简单易用编程模型，内部基于发布/订阅模型实现</p>
<p>Spring Cloud Stream的Binder提供标准协议，不同的消息中间件都可以按照标准协议接入。</p>
<p>Binder提供了bindConsumer和bindProducer接口协议，分别构造生产者和消费者。</p>
<h3 id="RocketMQ集群管理"><a href="#RocketMQ集群管理" class="headerlink" title="RocketMQ集群管理"></a>RocketMQ集群管理</h3><p><img src="RocketMQ集群管理图.png" alt="image-20201011215407652"></p>
<p>NameServer：支持Broker的动态注册和发现。主要包括服务注册（NameServer接受Broker集群的注册信息，保存下来作为路由信息的基本数据，并提供心跳检测机制，检查Broker是否还存活），路由信息管理（NameServer保存了Broker集群的路由信息，用户提供给客户端查询Broker的队列信息）</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ol>
<li><strong>Message</strong>:消息，系统所传输信息的物理载体，生产和消费数据的最小单位，每条信息必须属于一个Topic，RockerMQ中的每条信息都有唯一的MessageID,且可以携带具有业务标示的Key</li>
<li><strong>Topic</strong>:主题，表示一类信息的集合，每个主题都包含若干条信息，每条信息都只能够属于一个主题,Topic是RockerMQ进行消息订阅的基本单位。</li>
<li><strong>Queue</strong>:消息队列，组成Topic的最小单位，默认情况下一个Topic会对应多个Queue，Topic是逻辑概念，Queue是物理存储，在Consumer消费Topic信息时，底层实际上是拉取Queue信息。</li>
<li><strong>Tag</strong>:为消息设置的标志，用于同一个主题下区分不同类型的消息。来自同一个业务单元的消息，可以根据不同业务目的在同一个主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RockerMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费的处理逻辑，实现更好的扩展。</li>
<li><strong>ProducerGroup</strong>:同一类Producer的集合，这类Producer发送同一类信息且发送逻辑一致，如果发送的是事务信息且原始生产者在发送之后奔溃，则Broker服务器会联系同一个生产者组的其他生产者实例以提交或者回溯消费。</li>
<li><strong>ConsumerGroup</strong>:类似</li>
</ol>
<h4 id="Kafka与RocketMQ的区别和联系"><a href="#Kafka与RocketMQ的区别和联系" class="headerlink" title="Kafka与RocketMQ的区别和联系"></a>Kafka与RocketMQ的区别和联系</h4><p><strong>Kafka</strong>:</p>
<p>Topic是逻辑概念，区分（partition)是物理概念，1个Topic可以设置多个分区，每个分区可以设置多个副本，则有1个Master分区，多个Slave分区。只有Master分区提供服务。每个Broker中的Queue都有主备，一个Topic下面既有Master的Partition，也有Slave的Partition。由于只有Master的Partition才能够提供服务，所以每次都需要由ZooKeeper来做Master选择，节点间网络复杂，耗费大量的性能</p>
<p>RocketMQ:</p>
<p>Topic是逻辑概念，队列（Queue） 是物理概念，1个Topic可以设置多个Queue，每个Queue都可以设置多个副本。只有一个节点为Master，其他节点都是Slave。并且是在启动前就已经确定好的。一个Topic下的所有的Queue都为主。或者都为Slave。减少了ZooKeeper的Master选举操作，性能提高。所以选择NameServer而不是选择ZooKeeper作为中心。</p>
<h3 id="发送消费方式"><a href="#发送消费方式" class="headerlink" title="发送消费方式"></a>发送消费方式</h3><p>消息发送的方式有三种方式：</p>
<ol>
<li>同步：发送网络请求后，同步等待Broker服务器的返回结果，支持发送失败重试</li>
<li>异步：发送网络请求后立即返回，不会阻塞当前线程，不支持失败重试</li>
<li>单项：跟异步一致，单不支持回调</li>
</ol>
<p>消息模式有两种：</p>
<ol>
<li>集群消费：被消费集群中的其中一个消费者进行消费</li>
<li>广播消费：被消费集群中的每个消费者进行消费</li>
</ol>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>顺序消息有两种</p>
<ol>
<li>局部有序：发送同一个队列的信息有序，可以在发送信息时指定队列</li>
<li>全局有序：一个Topic下只有一个队列</li>
</ol>
<p>顺序发送的原理就是同一类信息发送到相同的队列，而且要使用同步发送。</p>
<p>顺序消费：同一个消息队列只允许Consumer集群中的一个消费线程拉取消息，拉取消息的时候选择独占锁，阻止同一个消费群组并发消费，导致乱序，但是允许被同一个消费群组的不同成员进行处理</p>
<h4 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h4><p>使用轮询机制来保证消息高性能收发。也就是在发送的时候，通过轮询机制轮询同一个Topic下的所有Queue进行发送，每次都尽可能地发送到不同的队列中，如果队列出现故障的话，就使用故障规避机制。消费使用并发消费（同一个消息队列提供给Consumer中的多个消费线程拉取消费，Consumer中会维护一个消费线程池，多个消费线程池可以并发去同一个消息队列中拉取消息进行消费，如果某个某个消费线程在监听器中进行业务处理时抛出异常，当前线程会进行失败重试，不会影响其他的消费线程）</p>
<p>并发消费不保证消息不被重复消费，RockerMQ能够保持消息至少被消费一次。</p>
<p>重复消费的场景是消息已经被消费，但是向Broker返回ACK时，返回ACK信息丢失，导致被其他的消费者线程重复消费。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>使用二段式方案来提交事务消息，第一阶段Producer向Broker发送预处理消息，此时消息还没有被投递出去，Consumer不能消费；第二阶段，Producer向Broker发送提交或回滚消息。</p>
<h3 id="高性能设计"><a href="#高性能设计" class="headerlink" title="高性能设计"></a>高性能设计</h3><h4 id="顺序写盘"><a href="#顺序写盘" class="headerlink" title="顺序写盘"></a>顺序写盘</h4><p>磁盘读写的过程：</p>
<ol>
<li>寻道：磁头移动定位到指定磁道，时间很长</li>
<li>旋转延迟：等待指定扇区旋转到磁头下，时间很短</li>
<li>数据传输：数据通过系统总线从磁盘传送到内存，时间很短</li>
</ol>
<p><img src="RocketMQ存储设计.png" alt="image-20201011232017380"></p>
<p>每个消息的负载都是写入到CommitLog中，进行加锁顺序写入，并通过线程异步几乎同时地将消息转发到消费队列文件（转发的没有消息负载）。</p>
<p>每个消息最重要的要素有：</p>
<ol>
<li>Topic</li>
<li>QueueId</li>
<li>queueOffset</li>
<li>physical offset</li>
</ol>
<h4 id="消息队列设计"><a href="#消息队列设计" class="headerlink" title="消息队列设计"></a>消息队列设计</h4><p>每个Broker会记录客户端对每个消费队列的消费偏移量，定位到ConsumerQueue里的相应记录（不包含消息的负载），并通过CommitLog的Offset定位到CommitLog文件里的该条消息。并且，会使用Page Cache机制来进行预读，增加消息的命中率。</p>
<h4 id="数据零拷贝"><a href="#数据零拷贝" class="headerlink" title="数据零拷贝"></a>数据零拷贝</h4><p>RocketMQ的文件读写操作都是通过Java　NIO中的MappedByteBuffer来进行文件映射。利用Java NIO的File Channel模型，可以直接将物理文件映射到缓冲区的Page Cache,少一次数据拷贝过程，提高读写速度。</p>
<h4 id="消息实时投递"><a href="#消息实时投递" class="headerlink" title="消息实时投递"></a>消息实时投递</h4><p>使用长轮询，还是以客户端Consumer轮询的方式主动发送拉取请求到服务端Broker，Broker如果检测到有新的消息会立即返回Consumer，如果没有新消息暂时不返回任何信息，挂起当前请求缓存到本地，Broker后台有个线程会检查挂起请求，等到消息产生时返回Consumer。</p>
<h3 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h3><h4 id="消息发送高可用"><a href="#消息发送高可用" class="headerlink" title="消息发送高可用"></a>消息发送高可用</h4><p><strong>消息发送重试机制</strong>：在消息发送出现异常时会尝试再次发送，默认最多重试三次</p>
<p><strong>故障规避机制</strong>：使用轮询算法选择一个消息队列，从故障列表判断该消息队列是否可用，进而继续判断故障列表的故障规避时间</p>
<h4 id="消息存储高可用"><a href="#消息存储高可用" class="headerlink" title="消息存储高可用"></a>消息存储高可用</h4><p><strong>同步刷盘</strong>：在同步刷盘的模式下，当消息写到内存后，会等待数据写到磁盘的CommitLog文件。</p>
<p><strong>异步刷盘</strong>：直接返回，不考虑提交到requestRead中的信息是否能够刷包，有可能会丢失一小部分数据。（默认）</p>
<p>读写分离来加快写入的速度：requestWrite是写队列，用于保存添加进来的刷盘任务，requestRead是读队列，在刷盘之前会把写队列的数据放到读队列中，刷盘的时候依次读取requestRead中的数据写入磁盘，写入完成后清空requestRead。读写分离设计的目的是在刷盘时不影响任务提交到列表中。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制一般采用ASYNC_FLUSH异步刷盘，SYNC_MASTER同步复制来实现高可用，这样即使有一条服务器出故障，也可以保证数据不丢失。</p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>可以从Slave中拉取数据，而不一定是从Master中拉取数据</p>
<h4 id="消费重试机制"><a href="#消费重试机制" class="headerlink" title="消费重试机制"></a>消费重试机制</h4><p>重试队列：在Consumer由于业务异常导致消费信息失败，将消费失败的消息重新发送到Broker保存在重试队列，这样设计不会影响整体消费进度，又必须防止消费失败的消息丢失，存放在“%RETRY%consumerGroup”重试topic中</p>
<p>私信队列：如果部分消息长时间消费重试一直失败，为了保证这部分消息不丢失，同时不能阻塞其他能重试消费成功的消息，超过最大重试消费次数之后的信息会进入到死信机制中，消息进入死信后不被消费，需要人为干预。私信队列存放在单独的Topic”%DLQ%+consumerGroup”中。</p>
<h2 id="微服务网关之Spring-Cloud-Gateway"><a href="#微服务网关之Spring-Cloud-Gateway" class="headerlink" title="微服务网关之Spring Cloud Gateway"></a>微服务网关之Spring Cloud Gateway</h2><p>对于应用开发来说，网状式设计耦合度太高，需要解耦。解耦有两种方式：</p>
<ol>
<li>中心化管理的方式：通过将所有的耦合都集中起来，做到中心化管理。微服务管理就是如此，比如将分布式事务管理集中到Seata TC中，比如将消息发送机制集中到RocketMQ中进行管理。集中式管理有其优点，比如统一管理，集中可视化处理，功能单一等，但是需要对集中点的可靠性有更高的要求</li>
<li>团状式管理：也就是类似于网络结构图等，该设计使用委托者模式或者叫做网关模式，通过网关来对外进行沟通，实现耦合度降低。这里只能够降低耦合度，不能够实现完全的解耦。耦合还是存在的。</li>
</ol>
<h3 id="API网关的作用"><a href="#API网关的作用" class="headerlink" title="API网关的作用"></a>API网关的作用</h3><p>功能：</p>
<ol>
<li>针对所有请求进行统一鉴权，限流，熔断和日志（比如实现灰度发布，将一部分流量发送到新的功能中）</li>
<li>协议转换：针对后端多种不同的协议，在网关层统一处理后HTTP对外提供服务。</li>
<li>统一错误码处理</li>
<li>请求转发</li>
</ol>
<h3 id="网关的本质"><a href="#网关的本质" class="headerlink" title="网关的本质"></a>网关的本质</h3><p>网关的本质是对请求进行路由转发，以及对请求进行前置和后置的过滤。</p>
<ol>
<li>请求转发和路由：接受客户端的所有请求，并将请求转发到后端的微服务中。相当于门面模式</li>
<li>过滤：网关会拦截所有请求并完成一系列的横切工作，比如鉴权，限流。</li>
</ol>
<p><img src="网关.png" alt="image-20201012231321393"></p>
<p>路由（Route):它是网关的基本组件，由ID，目标URI，Predicate集合，Filter集合组成</p>
<p>谓语（Predicate):提供了断言的功能，可以匹配HTTP请求中的任何内容，如果Predicate的聚合判断结果为true，则意味这该请求会被当前Router进行转发</p>
<ol>
<li>根据指定时间规则匹配路由</li>
<li>根据携带的Cookie是否匹配配置的规则</li>
<li>根据Header头消息对应的name和value与Predicate配置的值是否匹配</li>
<li>根据Host字段来进行路由</li>
<li>根据HTTP请求的Method属性来实现路由</li>
<li>根据请求路径来进行路由</li>
</ol>
<p>过滤器（Filter):为请求提供前置和后置的过滤</p>
<ol>
<li>Pre类型的过滤器在请求转发到后端微服务之前执行，在Pre类型过滤器链中可以做鉴权/限流等操作</li>
<li>Post类型的过滤在请求执行完之后，将结果返回客户端之前执行。</li>
</ol>
<p>GlobalFilter:会应用到所有的路由上，而GatewayFilter只会应用到单个路由或一个分组的路由上。</p>
<p>当Gateway接收到请求时，Filtering Web Handle处理器会将所有的GlobalFilter实例及所有路由上所配置的GatewayFilter实例添加到一条过滤链中。该过滤器链里的所有过滤器都会按照@Order注解所注定的数字的大小进行排序</p>
<p><img src="Spring_cloud_gateway集成Nacos.png" alt="image-20201012234118072"></p>
<p>在外部请求进入API网关时，会先经过SentinelGatewayFilter，在该过滤器中依次进行Route ID/API分组匹配，请求属性解析和参数组装，通过配置的网关限流规则来解析请求属性，并按照参数索引顺序组装参数数组，最终传入到SphU.entry(name,args)中。</p>
<p>在Sentinel API Gateway Adapter Common 模块中在Slot Chain中添加GatewayFlowSlot，专门用来处理网关限流规则的检查。</p>
<p>Sentinel限制规则最终在网关的入口为Filter。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;微服务的发展史&quot;&gt;&lt;a href=&quot;#微服务的发展史&quot; class=&quot;headerlink&quot; title=&quot;微服务的发展史&quot;&gt;&lt;/a&gt;微服务的发展史&lt;/h2&gt;&lt;h3 id=&quot;网站发展历史&quot;&gt;&lt;a href=&quot;#网站发展历史&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="微服务" scheme="https://caixueyuan.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Spring" scheme="https://caixueyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring起步</title>
    <link href="https://caixueyuan.github.io/2020/08/06/Spring%E8%B5%B7%E6%AD%A5/"/>
    <id>https://caixueyuan.github.io/2020/08/06/Spring起步/</id>
    <published>2020-08-06T15:42:46.000Z</published>
    <updated>2020-08-08T15:22:24.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring起步"><a href="#Spring起步" class="headerlink" title="Spring起步"></a>Spring起步</h2><h3 id="初始化Spring应用"><a href="#初始化Spring应用" class="headerlink" title="初始化Spring应用"></a>初始化Spring应用</h3><p>微服务一般都是打包成jar的方式，而不是war的方式。</p>
<h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h4><p>是一个组合注解</p>
<ol>
<li>@SpringBootConfiguration:将该类声明为配置类</li>
<li>@EnableAutoConfiguration：启动Spring Boot的自动配置。</li>
<li>@ComponentScan:启动组件扫描</li>
</ol>
<p>使用RunDashboard的方式，编译.idea下的文件workspace.xml文件（IDEA默认会使用devtools)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"RunDashboard"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"configurationTypes"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"SpringBootApplicationConfigurationType"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"ruleStates"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"ConfigurationTypeDashboardGroupingRule"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">RuleState</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"StatusDashboardGroupingRule"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">RuleState</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring起步&quot;&gt;&lt;a href=&quot;#Spring起步&quot; class=&quot;headerlink&quot; title=&quot;Spring起步&quot;&gt;&lt;/a&gt;Spring起步&lt;/h2&gt;&lt;h3 id=&quot;初始化Spring应用&quot;&gt;&lt;a href=&quot;#初始化Spring应用&quot; class
    
    </summary>
    
      <category term="Spring" scheme="https://caixueyuan.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://caixueyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>maven基础知识</title>
    <link href="https://caixueyuan.github.io/2020/07/19/maven%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2020/07/19/maven基础知识/</id>
    <published>2020-07-19T15:09:42.000Z</published>
    <updated>2020-08-06T15:40:40.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="maven核心概念"><a href="#maven核心概念" class="headerlink" title="maven核心概念"></a><strong>maven核心概念</strong></h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Clean<strong>生命周期</strong>：</p>
<ol>
<li>pre-clean:执行清理前需要完成的工作</li>
<li>clean:清理上一次构建过程中生成的文件，比如编译后的class文件</li>
<li>post-clean:执行清理后需要完成的工作</li>
</ol>
<p><strong>default生命周期</strong>：</p>
<ol>
<li>validate:验证项目结构是否正常，必要的配置文件是否存在</li>
<li>initialize:做构建前的初始化操作，比如初始化参数，创建必要的目录</li>
<li>generate-sources:产生在编译过程中需要的源代码</li>
<li>process-sources:处理源代码，比如过滤值</li>
<li>generate-resources：产生主代码中的资源在class path中的包</li>
<li>process-resources：将资源文件复制到classpath的对应包中</li>
<li>compile：编译项目中的源代码</li>
<li>process-classes:产生编译过程中生成的文件</li>
<li>generate-test-sources:产生编译过程中测试相关的代码</li>
<li>process-test-resources：处理测试代码</li>
<li>generate-test-resources：产生测试过程中的测试相关的代码</li>
<li>process-test-resources:将测试资源复制到classpath中</li>
<li>test-compile：编译测试代码</li>
<li>process-test-classes：产生编译测试代码过程的文件</li>
<li>test：运行测试案例</li>
<li>prepare-package：处理打包前需要初始化的准备工作</li>
<li>package：将编译后的class和资源打包成压缩文件，比如rar</li>
<li>pre-integration-test：做成集成测试后的收尾工作，比如清理集成环境的值</li>
<li>integration-test：集成测试</li>
<li>post-integration-test:完成集成测试后的收尾工作，比如清理集成环境的值</li>
<li>verify：检测测试后的包是否完好</li>
<li>install：将打包的组件以构件的形式，安装到本地依赖仓位中，以便共享给本地的其他项目中</li>
<li>deploy：运行集成和发布环境，将测试后的最终包以构件的方法发布到远程仓中，方便所有程序员共享。</li>
</ol>
<p>site<strong>建立和发布站点</strong>：</p>
<ol>
<li>pre-site:执行生成站点前的准备工作</li>
<li>site:生成站点工作</li>
<li>post-site：执行生成站点后的收尾工作</li>
<li>site-deploy：将生成的站点发布到服务器中。</li>
</ol>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>作用</strong>：maven只是对项目的构建过程进行了统一的抽象定义和管理。至于每个阶段由谁来做，maven自己不去实现，而是让对应的插件去完成。将插件的功能集成到maven生命周期的相关阶段中，让maven构建工作时自动调用插件完成指定的任务。有内置绑定和自定义绑定等。</p>
<ol>
<li>内置绑定：Maven在安装后，自动会为生命周期的主要阶段绑定了很多插件的目标。当用户通过命令或者图形界面执行生命周期的某些阶段时，对应的插件目标就会自动执行，完成任务</li>
<li>自定义绑定插件：通过<code>&lt;phase&gt;verify&lt;/phase&gt;</code>来完成绑定。</li>
</ol>
<p>在不同的生命周期阶段绑定不同的插件目标后，这些目标执行时按照阶段的顺序逐个执行。如果在一个阶段上绑定了多个目标，会按照插件生命的顺序执行。</p>
<p><strong>插件配置</strong>：了解插件绑定的默认生命周期阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mvn help:describe -Dplugin=org.apache.maven.plugins:maven-resource-plugin:<span class="number">3.0</span>.0 -Ddetail</div><div class="line">mvn help:describe -Dplugin=site -Dgoal=site -Ddetail</div><div class="line">mvn dependency:tree<span class="comment">//maven &lt;插件名称|前缀&gt;:&lt;目标&gt;[-D 参数名=参数值 ...]</span></div></pre></td></tr></table></figure>
<p><strong>解析插件</strong></p>
<p>插件仓库：默认为maven中心库，可以通过pluginRepositores-&gt;pluginRepository命令进行配置</p>
<p>插件默认的groupid:MAVEN官方的插件，为org.apache.maven.plugins</p>
<p>解析插件的版本：如果插件不属于核心插件范畴，maven会去检测所有仓库中的版本，最终会选择最新版本，而且这个最新版本不排除是快照版本。</p>
<p>解析插件的前缀：通过groupId/maven-metadata.xml中进行定义</p>
<h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>构件最终是文件的形式存在的。maven仓库其实就是使用固定规则的目录结构，把公共的构件保存在一个固定的存储位置中，需要的时候可以按照规则找到这些具体的构件文件。</p>
<p>maven查找构件的时候，先查看本地仓库，如果本地仓库存在坐标对应的构件，直接使用。如果本地仓库不存在所需要的构件，或者需要查看是否由更新的构件版本，maven就会去远程仓库查找，发现需要的构件后，下载到本地仓库后使用。如果本地仓库和远程仓库都没有找到需要的构件，maven会报错。</p>
<p>所有maven项目都是集成这个pom.xml文件，通常把这个pom叫做超级pom，与Java中的Object类一样，也是所有的类都自动继承Objects。而Object类也叫超级类。</p>
<p><code>&lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</code>用来控制maven对发布构件的构件和快照的构件下载。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span><span class="comment">&lt;!-- 配置maven从远程仓库检测更新的频率，默认为daily，表示每天检查更新 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span><span class="comment">&lt;!-- 配置检测校验和文件的策略 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过pom.xml中使用distributionManagement配置部署信息来，通过<server>来配置认证私服的认证信息。</server></p>
<p>快照版本只应该在开发团队内部的项目或者模块之间依赖使用。</p>
<p><strong>从仓库中解析依赖的机制</strong>：</p>
<ol>
<li>当依赖的范围是system的时候，Maven直接从本地文件系统中解析构件</li>
<li>根据依赖坐标计算仓库路径，尝试直接从本地仓库中寻找构件，如果发现对应的构件，就解析成功</li>
<li>如果在本地仓库中不存在相应的构件，就遍历所有的远程仓库，发现后，下载并解析使用</li>
<li>如果依赖的版本是RELEASE和LASTEST，就基于更新策略读取所有远程仓库的元数据文件(groupId/artifactId/maven-metadata.xml)，将其与本地仓库的对应源数据合并，计算出RELEASE或者LASTEST的真实值，然后各级该值检查本地仓库或者，从远程仓库中下载</li>
<li>如果依赖的版本是SNAPSHOT，基于更新策略读取所有远程仓库的元数据文件，将它与本地仓库对应的元数据合并，得到最新快照版本的值，然后根据该值检查本地仓库或者从远程仓库下载</li>
<li>如果最后解析得到的构件版本含有时间戳，先将文件下载下来，再将文件名中时间戳信息删除，剩下SNAPSHOT并使用</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> 匹配所有的远程仓库</div><div class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>external:*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> 匹配所有的远程仓库，使用localhost或者file://协议的除外</div><div class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span><span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> 匹配指定的几个远程仓库，每个仓库之间用逗号隔开</div><div class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!r1,r2<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  匹配除了指定仓库外的所有仓库</div></pre></td></tr></table></figure>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>依赖的范围：</p>
<ol>
<li>compile:编译依赖的范围，在编译，测试和运行时都能够使用</li>
<li>test:测试依赖范围</li>
<li>provided：已提供依赖范围，使用此范围，只在编译和测试的时候有效，运行项目的时候时是无效</li>
<li>runtime：运行时依赖的范围，只会对测试和运行的classpath有效，但在编译主代码时是无效的</li>
<li>system：系统依赖范围，在编译和测试中有效</li>
<li>import：导入依赖范围，该依赖范围不会对三种classpath产生实际的影响，将其他模块定义好的dependencyManagement导入当前Maven项目Pom的dependencyManagement中。</li>
</ol>
<p><strong>依赖调解</strong>:</p>
<ol>
<li>依赖调解原则：按照路径优先原则和声明预先原则来进行判断</li>
<li>可选依赖</li>
<li>排除依赖：通过<code>&lt;exclusion&gt;&lt;/execlusion&gt;</code>来排除依赖的groupId和artifictId</li>
<li>归类依赖：通过<code>&lt;properties&gt;&lt;project.build.spring.version&gt;4.2.7&lt;/project.build.version&gt;&lt;/properties&gt;</code>来配置版本依赖</li>
</ol>
<p><strong>继承和聚合</strong></p>
<p>Maven跟面向对象的语言相似，可以通过<parent></parent>的方式来继承一个父POM，这时候要注意了，被继承的POM只能够是POM类型(<packaging>POM</packaging>)</p>
<p>可以通过<modules><module>../abc</module></modules>来集合不同的模块，来让不同的模块同步构建</p>
<h3 id="Maven测试"><a href="#Maven测试" class="headerlink" title="Maven测试"></a>Maven测试</h3><p>在maven的default生命周期的test阶段，绑定的默认插件是maven-surefire_plugins。这是一个内置绑定，在默认情况下，maven-surefire-plugin的test阶段会自动执行测试源代码下的所有符合命名模式的测试类。符合命名模式的规范是：</p>
<ol>
<li>所有命名为Test开头的java类</li>
<li>所有命名为Test结尾的Java类</li>
<li>所有命名为TestCase结尾的Java类</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mvn package -DskipTests //可以通过来跳过运行测试案例</div><div class="line">mvn package -Dmaven.test.skip=true //同时控制了maven-compile-plugin和maven-surefire-plugin两个插件的行为，既跳过了测试代码的编译，也跳过了测试代码的运行</div><div class="line">mvn test -Dest=TestDemo //只执行TestDemo测试类</div></pre></td></tr></table></figure>
<p>可以通过maven-surefire-report-plugin插件来实现测试生成HTML版的测试报告</p>
<p>可以通过groupId=org.codehaus.mojo,artifactId=cobertura-maven-plugin来生成测试覆盖率报告，通过执行<code>mvn cobertura:cobertura</code>生成测试覆盖率报告。</p>
<p>插件可以自定义开发，插件本身也是一个maven项目，按照特定的变量进行配置，就可以进行使用。在使用之前要将项目install到本地或者私服中</p>
<p>Archetype为maven项目的创建模板，也可以进行定制。定制需要更改了archetype-catalog.xml文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;maven核心概念&quot;&gt;&lt;a href=&quot;#maven核心概念&quot; class=&quot;headerlink&quot; title=&quot;maven核心概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;maven核心概念&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期
    
    </summary>
    
      <category term="Java" scheme="https://caixueyuan.github.io/categories/Java/"/>
    
    
      <category term="Java构建" scheme="https://caixueyuan.github.io/tags/Java%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://caixueyuan.github.io/2020/06/14/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://caixueyuan.github.io/2020/06/14/Java8新特性/</id>
    <published>2020-06-14T01:14:30.000Z</published>
    <updated>2020-06-21T15:31:50.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h2><p>作用：软件原则DRY（Don’t repeat yourself,不要重复自己）</p>
<p><strong>概念</strong>：让方法接受多种行为作为参数，并在内部使用，来完成不同的行为。</p>
<p><strong>好处</strong>：行为参数化在于你可以把迭代要筛选的集合的逻辑与对集合中的每个元素应用的行为区分开来，可以重复使用同一个方法，给它不同的行为来达到不同的目的。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h3><p>它没有名称，但它有参数列表，函数主题，返回类型，可能还会有一个可以抛出的异常列表</p>
<p><strong>匿名</strong>：它不像普通的方法那样有一个明确的名称：写得少而想得多</p>
<p><strong>函数</strong>：不像方法那样属于特定的类。但与方法一样，Lambda有参数列表，函数主体，返回类型，还可能有可以抛出来的异常类型</p>
<p><strong>传递</strong>：Lambda表达式可以作为参数传递给方法或存储在变量中</p>
<p><strong>简洁</strong>：无需像匿名类那样写很多模板代码</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>只有在函数式接口的时候才可以传递Lambda表达式。函数式接口就是只有一个函数的接口。</p>
<h3 id="3-3-环绕处理模式"><a href="#3-3-环绕处理模式" class="headerlink" title="3.3 环绕处理模式"></a>3.3 环绕处理模式</h3><p><strong>概念</strong>：资源处理中打开一个资源，做一些处理，然后关闭资源。这种设置和清理 阶段总是很类似，并且会围绕着执行处理的那些重要代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">proccessFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file)))&#123;</div><div class="line">        <span class="keyword">return</span> br.readLine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-使用函数式接口"><a href="#3-4-使用函数式接口" class="headerlink" title="3.4 使用函数式接口"></a>3.4 使用函数式接口</h3><p><strong>Predicate</strong>:java.util.function.Predicate<t>接口定义了一个叫做test的抽象方法，它接受泛型T对象，并返回一个Boolean，</t></p>
<p><strong>Consumer</strong>:java.util.function.Consumer<t>定义一个叫accept的抽象方法，它接受泛型对象，没有返回（void)</t></p>
<p><strong>Function</strong>:java.util.function.Function<t,r>接口定义了一个叫做apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。</t,r></p>
<p>Java类型要么式引用类型（Byte,Integer)，要么式原始类型（int,byte)，但是泛型只能够绑定到引用类型。</p>
<p><strong>注意</strong>：任何函数式接口都不允许抛出受检异常。如果你需要Lambda表达式来抛出异常，有两种方法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda包在一个try/catch块中。</p>
<p><strong>lamdba表达式的接口是根据目标类型来进行推断的。</strong></p>
<h3 id="3-5-使用局部变量"><a href="#3-5-使用局部变量" class="headerlink" title="3.5 使用局部变量"></a>3.5 使用局部变量</h3><p>Lambda可以没有限制地捕获实例变量和静态变量，但是局部变量必须显性声明为final，或者事实上是final。换句话说，Lambda表达式只能够捕获给他们的局部变量一次。</p>
<h3 id="3-6-方法引用"><a href="#3-6-方法引用" class="headerlink" title="3.6 方法引用"></a>3.6 方法引用</h3><p>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</div><div class="line">inventory.sort(comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
<p>方法引用主要有三种：</p>
<p>1.指向静态方法的方法引用</p>
<p>2.指向任意类型实例方法的方法引用</p>
<p>3.指向现有对象的实例方法的方法引用</p>
<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p><strong>andThen</strong>:返回一个函数，它先对输入应用一个给定函数，在对输出应用另外一个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer,Integer&gt; f = x -&gt; x+<span class="number">1</span>;</div><div class="line">Function&lt;Integer,Integer&gt; g = x -&gt; x*<span class="number">2</span>;</div><div class="line">Function&lt;Integer,Integer&gt; h = f.andThen(g);</div><div class="line"><span class="keyword">int</span> result = h.apply(l);</div><div class="line"><span class="comment">//最后的结果g(f(x)) = (x+1)*2</span></div></pre></td></tr></table></figure>
<p><strong>andCompose:</strong>:先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer,Integer&gt; h = f.andCompose(g);</div><div class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</div><div class="line"><span class="comment">//最后的结果f(g(x))=x*2+1</span></div></pre></td></tr></table></figure>
<h2 id="4-流"><a href="#4-流" class="headerlink" title="4.流"></a>4.流</h2><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><p>代码能够以声明性方式写的：说明想要完成什么，而不是说明如何实现。可以将几个基础操作链接起来，来表达复杂的数据处理流水线。同时，filter/sorted/map/collect等操作是与具体线程模型无关的高层次构件，不需要关注数据处理任务并行的细节。</p>
<p><strong>概念</strong>：从支持数据处理操作的源生成的元素序列</p>
<p><strong>元素序列</strong>：可以访问特定元素类型的一组有序值，流主要提供的是一种计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</div><div class="line">    .map(Dish::getName)</div><div class="line">    .limit(<span class="number">3</span>)</div><div class="line">    .collect(toList())</div><div class="line"> <span class="comment">//在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素，链中的方法调用都在排队等待，直到调用collect</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//filter 接受Lambda，从流中排除某些元素</span></div><div class="line"><span class="comment">//map 接受一个Lambda，将元素转换成某些形式或提取信息</span></div><div class="line"><span class="comment">//limit  截断流，使其元素不超过给定数量</span></div><div class="line"><span class="comment">//collect 将流转换成其他形式</span></div></pre></td></tr></table></figure>
<h3 id="4-3-流和集合"><a href="#4-3-流和集合" class="headerlink" title="4.3 流和集合"></a>4.3 流和集合</h3><p><strong>集合</strong>：在内存中的数据结构，包含数据结构中目前所有的值，集合中的每个元素都得先算出来才能够添加到集合中(在空间中分布的一组值)</p>
<p><strong>流</strong>：按需消费，在概念上固定的数据结构，只有在消费者要求的时候才会计算值（在时间上分布的一组值）</p>
<p><strong>注意：流只能够消费一遍</strong></p>
<p><strong>内部迭代</strong>：流模式，它帮你把迭代做了，还把得到的流值存在了某个地方。Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现</p>
<p><strong>外部迭代</strong>：用户自己实现迭代</p>
<p><strong>map</strong>:接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射到一个新的元素中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; dishNameLengths = menu.stream()</div><div class="line">    .map(Dish::getName)</div><div class="line">    .map(String::length)</div><div class="line">    .collect(toList());</div></pre></td></tr></table></figure>
<p><strong>flatMap</strong>：各个数组并不是分别映射成一个流，而是把一个流中的每个值都换成另一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharactors = words.stream()</div><div class="line">    .map(w -&gt; w.split(<span class="string">""</span>))</div><div class="line">    .floatMap(Arrays::stream)</div><div class="line">    .distinct()</div><div class="line">    .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>findFirst和findAny的区别</strong>：找到第一个元素在并行上限制更多，如果不关心返回的元素是那个的话，请使用findAny，因为它在使用并行时限制较少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">Optional&lt;Integer&gt; firstSquareDevisibleByThree = someNumbers.stream()</div><div class="line">    .map(x -&gt; x * x)</div><div class="line">    .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">    .findFirst();</div></pre></td></tr></table></figure>
<h2 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h2><p>流支持两种类型的操作：中间操作和终端操作。中间操作可以链接起来，将一个流转换成一个流。这些操作不会消耗流，其目的是建立一个流水线。与此相反，终端操作会消耗流，以产生一个最终结果。比如返回流中的最大元素。他们通常可以通过优化流水线来缩短计算时间。</p>
<h3 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h3><p><strong>查找流中的最大值和最小值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Dish&gt; dishCaleriesComparator = Comparator.comparingInt(Dish::getCalories);</div><div class="line">Optional&lt;Dish&gt; mostCaloriesDish = menu.stream().collect(maxBy(dishCaloriesComparator));</div></pre></td></tr></table></figure>
<p>Java 8引入了Optional，它是一个容器，可以包含也可以不包含值。这里它完美地代表了可能也可能不返回菜肴的情况。</p>
<p><strong>汇总</strong>，可接受一个把对象映射为求和所需要的int函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们所需要的汇总操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.summingInt;</div><div class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(summingInt(Dish::getCalories()));</div></pre></td></tr></table></figure>
<p><strong>连接字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining(<span class="string">", "</span>));</div></pre></td></tr></table></figure>
<p> <strong>广义归约汇总</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> totalCalories = menu.stream().collect(reducing(<span class="number">0</span>,Dish::getCalories,(i,j) -&gt; i+j));</div><div class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream().collect(reducing((d1,d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</div></pre></td></tr></table></figure>
<p><strong>分组</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType));</div></pre></td></tr></table></figure>
<p><strong>按照子组收集数据</strong>:传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type,Long&gt; typesCount = menu.stream().collect(groupingBy(Dish::getType,counting()));</div><div class="line">Map&lt;Dish.Type,Dish&gt; mostCaloricByType = menu.stream().collect(groupingBy(Dish::getType,collectingAndThen(</div><div class="line">	maxBy(comparingInt(Dish::getCalories)),Optional::get)));</div></pre></td></tr></table></figure>
<p><strong>分区</strong>：由一个谓语作为分类函数，它分分区函数。分区函数返回一个布尔值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean,List&lt;Dish&gt;&gt; partiotionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian));</div></pre></td></tr></table></figure>
<p>将数字按照质数和非质数分区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">2</span>,candidate).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h3><p><strong>supplier</strong>:必须返回一个接口为空的Supplier，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用</p>
<p><strong>accumulator</strong>:返回执行归约操作的函数，当遍历到流中第n个元素时，这个函数执行时会有两个参数：保存归约结果的累加器，还有第n个元素本身</p>
<p><strong>finisher</strong>：在遍历完流后，finisher方法必须返回在累积过程中的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。</p>
<p><strong>combiner</strong>:定义对流中的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。</p>
<p><strong>characteristics</strong>:返回一个不可变的Characteristics集合，定义了收集器的行为。</p>
<ol>
<li>UNORDERED——归约结果不受流中项目的遍历和累积顺序的影响</li>
<li>CONCURRENT——accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约</li>
<li>IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。将累加器A不加检查地转换为结果R是安全的</li>
</ol>
<h2 id="并行数据处理和性能"><a href="#并行数据处理和性能" class="headerlink" title="并行数据处理和性能"></a>并行数据处理和性能</h2><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>可以通过对收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分为多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>,i-&gt;i+<span class="number">1</span>)<span class="comment">//顺序处理</span></div><div class="line">        .limit(n)</div><div class="line">        .parallel()</div><div class="line">        .reduce(<span class="number">0L</span>,Long::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置并行流使用的线程池：默认情况下使用的线程池的个数为处理器的数量，这个值为<code>Runtime.getRuntime().available-Processors()</code>得到的。可以通过修改系统属性<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>来改变线程池大小。</p>
<p>把流标记为并行，其实是给顺序处理增加开销，还要把每次求和操作分到一个不同的线程中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelRangedSum</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>,n)</div><div class="line">        .parallel()</div><div class="line">        .reduce(<span class="number">0L</span>,Long::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并行化过程本身需要对流进行递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并到一个值。</p>
<h3 id="分支-合并框架"><a href="#分支-合并框架" class="headerlink" title="分支/合并框架"></a>分支/合并框架</h3><p>分支/合并框架的目的是以递归方式将可以并行的任务拆分为更小的任务，然后将每个子任务的结果合并起来生成整体结果。</p>
<p><strong>RecursiveTask</strong>：并行任务，结果有返回值</p>
<p><strong>RecursiveAction</strong>：并行任务，结果没有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = end - start;</div><div class="line">    <span class="keyword">if</span>(length &lt;= THRESHOLD)&#123;</div><div class="line">        <span class="keyword">return</span> computeSequentially();</div><div class="line">    &#125;</div><div class="line">    ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start,start+length/<span class="number">2</span>);</div><div class="line">    leftTask.fork();</div><div class="line">    ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start+length/<span class="number">2</span>,end);</div><div class="line">    Long rightResult = rightTask.compute();<span class="comment">//第一个线程</span></div><div class="line">    Long leftResult = leftTask.join();<span class="comment">//第二个线程，对于一个任务调用join方法会阻塞调用方，直到该任务做出结果</span></div><div class="line">    <span class="keyword">return</span> leftResult + rightResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重构-测试和调试"><a href="#重构-测试和调试" class="headerlink" title="重构/测试和调试"></a>重构/测试和调试</h2><h3 id="匿名类和lambda表达式"><a href="#匿名类和lambda表达式" class="headerlink" title="匿名类和lambda表达式"></a>匿名类和lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在匿名类中，this代表的是类的自身，但是在Lambda，它代表的是包含类。其次，匿名类可以屏蔽包含类的变量，而lambda表达式不会</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">Runnable r1 = () -&gt; &#123;<span class="comment">//类的上下文</span></div><div class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;<span class="comment">//编译错误</span></div><div class="line">    System.out.println(a);</div><div class="line">&#125;</div><div class="line">Runnable r2 = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通过行为参数化传递代码&quot;&gt;&lt;a href=&quot;#通过行为参数化传递代码&quot; class=&quot;headerlink&quot; title=&quot;通过行为参数化传递代码&quot;&gt;&lt;/a&gt;通过行为参数化传递代码&lt;/h2&gt;&lt;p&gt;作用：软件原则DRY（Don’t repeat yourself,不
    
    </summary>
    
      <category term="Java" scheme="https://caixueyuan.github.io/categories/Java/"/>
    
    
      <category term="Java8" scheme="https://caixueyuan.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>考试</title>
    <link href="https://caixueyuan.github.io/2020/05/12/%E8%80%83%E8%AF%95/"/>
    <id>https://caixueyuan.github.io/2020/05/12/考试/</id>
    <published>2020-05-12T15:37:04.000Z</published>
    <updated>2020-05-14T16:01:21.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-05-12"><a href="#2020-05-12" class="headerlink" title="2020/05/12"></a>2020/05/12</h2><p><strong>错题一</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        x+=<span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"x="</span>+Test.x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        x = x/<span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果：运行正确，结果为0</span></div></pre></td></tr></table></figure>
<p><strong>错题二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</div><div class="line">    Y y = <span class="keyword">new</span> Y();<span class="comment">//1</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">X</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"X"</span>);<span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Y</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"Y"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</div><div class="line">    Y y = <span class="keyword">new</span> Y();<span class="comment">//3</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"Z"</span>);<span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> Test();</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//YXYZ</span></div></pre></td></tr></table></figure>
<p><strong>错题三</strong>：instanceof运算符能够用来判断一个对象是否为：一个类的实例，一个实现指定接口的类的实例，一个子类的实例</p>
<p><strong>错题四</strong>：equals()和hashcode()的关系：</p>
<p>equals()相等的两个对象，他们的hashcode肯定相等，</p>
<p>hashcode()相等的两个对象，他们的equals()不一定相等</p>
<p>在hashmap中，key值是不可能重复的，由HashCode和equals方法共同判断key值是否相等，如果两个对象的hashcode相同，也不能够说明key值相等</p>
<p>错误五：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Parent test = <span class="keyword">null</span>;<span class="comment">//会正确地加载静态方法</span></div><div class="line">        test.hello();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//能够正确运行，返回hello</span></div></pre></td></tr></table></figure>
<p>错误六：</p>
<p><img src="image-20200513002308980.png" alt="image-20200513002308980"></p>
<p>Class类在java.lang包中</p>
<p>动态代理技术可以动态创建一个代理对象，反射不行</p>
<p>反射访问私有成员时，Field调用setAccessible可解除访问符限制</p>
<p>CGLIB可以实现字符码修改，反射不能够实现字节码修改</p>
<p>反射会动态创建额外对象，比如每个成员方法只有一个Method对象作为root，他不会直接暴露给用户，调用的时候会返回一个Method的包装类</p>
<p>反射带来的效率问题主要是动态解析类，JVM无法对反射代码进行优化</p>
<p>错题七：</p>
<p><img src="image-20200513002225647.png" alt="image-20200513002225647"></p>
<p><img src="image-20200513002141998.png" alt="image-20200513002141998"></p>
<h2 id="2020-05-13"><a href="#2020-05-13" class="headerlink" title="2020/05/13"></a>2020/05/13</h2><p><strong>错误一</strong>：变量的第一个字母不能够是数字，可以是下划线</p>
<p><strong>错误二</strong>：InputStreamReader可用来处理Unicode，BufferedReader,Writer和PipedInputStream都不能够处理Unicode</p>
<p><strong>错误三</strong>：</p>
<p><img src="image-20200514000131825.png" alt="image-20200514000131825"></p>
<p><strong>错误四：</strong></p>
<p><img src="image-20200514000324218.png" alt="image-20200514000324218"></p>
<p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。</p>
<p><strong>错误五</strong>：</p>
<p>HashTable，ConcurrentHashMap是线程安全的，其他的Map都不是线程安全的。</p>
<p><strong>错误六</strong>：</p>
<p><strong>抽象类</strong></p>
<p><img src="image-20200514000920753.png" alt="image-20200514000920753"></p>
<p>接口中可以由default,static方法。</p>
<p>特点:</p>
<p>1.抽象类中可以构造方法</p>
<p>2.抽象类中可以存在普通属性，方法，静态属性和方法。</p>
<p>3.抽象类中可以存在抽象方法。</p>
<p>4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</p>
<p>5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。</p>
<p><strong>接口</strong></p>
<p>1.在接口中只有方法的声明，没有方法体。</p>
<p>2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上</p>
<p>public static final </p>
<p>3.在接口中的方法，永远都被public来修饰。</p>
<p>4.接口中没有构造方法，也不能实例化接口的对象。</p>
<p>5.接口可以实现多继承</p>
<p>6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法</p>
<p>7.则实现类定义为抽象类。</p>
<p><strong>错误六</strong>：</p>
<p><img src="image-20200514001436984.png" alt="image-20200514001436984"></p>
<p>静态方法不能访问非静态变量，A和C错；</p>
<p>抽象类中的抽象方法不能有方法体，B错；</p>
<p>一个类中有多个类声明时，只能有一个public类，D错</p>
<h2 id="2020-05-14"><a href="#2020-05-14" class="headerlink" title="2020/05/14"></a>2020/05/14</h2><p><strong>错误一</strong>：JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public。接口中方法默认是 abstract public,所以在接口只写函数声明是符合语法规则<strong>。但是</strong>变量默认是用public final static 修饰的，意思它是静态常量，常量不管在接口中还是类中必须在声明时初始化，必须在声明时并给出初始化。接口中只有常量定义，没有变量声明。**</p>
<p><strong>错误二</strong>：</p>
<p>java的访问权限有public、protected、private和default的，default不能修饰变量</p>
<p><strong>错误三：</strong></p>
<p>堆区：只存放类对象，线程共享；</p>
<p>方法区：又叫静态存储区，存放class文件和静态数据，线程共享;</p>
<p>栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2020-05-12&quot;&gt;&lt;a href=&quot;#2020-05-12&quot; class=&quot;headerlink&quot; title=&quot;2020/05/12&quot;&gt;&lt;/a&gt;2020/05/12&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;错题一&lt;/strong&gt;：&lt;/p&gt;
&lt;figure clas
    
    </summary>
    
      <category term="编程考试" scheme="https://caixueyuan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95/"/>
    
    
      <category term="考试" scheme="https://caixueyuan.github.io/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>脚本和shell</title>
    <link href="https://caixueyuan.github.io/2019/11/12/shell%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2019/11/12/shell基础知识/</id>
    <published>2019-11-12T15:27:49.000Z</published>
    <updated>2019-12-15T15:19:13.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell基础知识"><a href="#shell基础知识" class="headerlink" title="shell基础知识"></a>shell基础知识</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//管道</div><div class="line">cut -d: -f7 &lt; /etc/passwd | sort -u</div><div class="line">//只有当/tmp/t2被成功送入到打印队列后才会删除/tmp/t2</div><div class="line">lpr /tmp/t2 &amp;&amp; rm /tmp/t2</div><div class="line">//只有当第一条命令执行失败才会执行第二条语句</div><div class="line">cp --preserve --recursive /etc/* /spare/backup || echo "Did not make backup"</div><div class="line">//用户环境变量</div><div class="line">bash ~/.profile</div><div class="line">bash ~/.bash_profile</div><div class="line">//将输出的语句进行执行</div><div class="line">find / -type f -name "*.log" 2&gt;/dev/null | grep -v boot.log | while read fname;do echo mv $fname $&#123;fname&#125;;done;|bash -x</div></pre></td></tr></table></figure>
<h2 id="引导和关机"><a href="#引导和关机" class="headerlink" title="引导和关机"></a>引导和关机</h2><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><ol>
<li>从MRB读取引导加载程序</li>
<li>加载并初始化内核</li>
<li>检测和配置设备</li>
<li>创建内核线程</li>
<li>系统管理员干预</li>
<li>执行系统启动脚本</li>
</ol>
<p>mount -o rw, remount /：重新挂载根目录</p>
<p><code>/etc/init.d/</code>:能够启动或者停止各个服务。当主脚本把系统引入到一个新的运行级别时，它不是直接在<code>/etc/init/d</code>目录下寻找，而是查找<code>/etc/rc**level**.d</code>目录下</p>
<p>这些目录的运行脚本都是软链接到/etc/init.d目录下的脚本，当init从低运行级向高运行级过渡时，它按照数字递增的顺序，带start参数运行所有以S开头的脚本。当init从高运行级向低运行级别过渡时，它按照数字递增的顺序，带Stop参数运行所有以K开头的脚本</p>
<h3 id="访问控制和超级权限"><a href="#访问控制和超级权限" class="headerlink" title="访问控制和超级权限"></a>访问控制和超级权限</h3><p><code>/etc/passwd</code>：记录用户的个数</p>
<p><code>/etc/group</code>:记录用户组的个数</p>
<p>bash在登陆模式启动要读~/.bash_profile，在非登录模式则读取~/.bashrc</p>
<p><code>/etc/sudoers</code>:这个文件列出了授权使用sudo的人以及允许他们在每台主机上运行的命令。如果提供给sudo的命令运行运行，那么sudo就提示输入这个用户自己的口令并执行命令。可以通过visudo来编辑该文件</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>Unix和Linux都没有提供新进程去运行某个特定程序的系统调用，现有进程必须克隆自身去创建一个新进程，克隆出的进程能够把它正在运行的那个程序替换成另外一个不同的程序</p>
<p><code>kill pid</code>:请求彻底终止某次执行。它期待接受该信号的进程清除自身的状态并退出。但是该命令不能够保证进程会被杀死。因为TERM信号可能会被捕获/封锁或者忽略。</p>
<p><strong>设置nice值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nice -n 5 ~/bin/longtask</div><div class="line">sudo renice -5 8829</div><div class="line">sudo renice 5 -u boggs</div></pre></td></tr></table></figure>
<p><strong>ps命令使用</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps aux</div><div class="line">ps lax #能够显示父进程，谦让值字段以及进程正在等待的资源(WCHAN)</div><div class="line">find /home -size +1M -print0 | xargs -0 ls -l</div></pre></td></tr></table></figure>
<p>/proc目录下的进程信息文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd</td>
<td>进程正在执行的命令或者程序</td>
</tr>
<tr>
<td>cmdline</td>
<td>进程的完整命令行</td>
</tr>
<tr>
<td>cwd</td>
<td>链到进程当前目录的符号链接</td>
</tr>
<tr>
<td>environ</td>
<td>进程的环境变量</td>
</tr>
<tr>
<td>statm</td>
<td>内存使用情况的信息</td>
</tr>
<tr>
<td>exe</td>
<td>链到正被执行的文件的符号链接</td>
</tr>
<tr>
<td>stat</td>
<td>进程的总体状态信息</td>
</tr>
<tr>
<td>fd</td>
<td>子目录，其中包含链到每个打开文件的描述符的链接</td>
</tr>
<tr>
<td>maps</td>
<td>内存映射信息（共享段/库）</td>
</tr>
<tr>
<td>root</td>
<td>链到进程的根目录的符号链接</td>
</tr>
<tr>
<td>stat</td>
<td>进程的总体状态信息（ps最擅长解析这些信息）</td>
</tr>
</tbody>
</table>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mount /dev/hda4 /users</div><div class="line"><span class="meta">#</span><span class="bash"> 输出正在使用该文件系统上的某个文件或者目录的每个进程的PID</span></div><div class="line">fuser -c /usr</div></pre></td></tr></table></figure>
<p>挂载在某个特定系统上的文件系统清单保存在/etc/fstab文件、/etc/vfstab(Solaris)文件。当系统引导时，包含在这个文件中的信息让这些文件系统先被检查(fsck)再自动挂载到系统中</p>
<p><strong>umount</strong>命令用来卸载文件系统，在大多数系统上，不能够卸载处于“busy”状态的文件系统。umount -f命令能够强制卸载一个处于忙状态的文件系统。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>f,o</td>
<td>进程有一个为了读或者写而打开的文件</td>
</tr>
<tr>
<td>c</td>
<td>进程的当前目录在这个文件系统中</td>
</tr>
<tr>
<td>e,t</td>
<td>进程目前在执行一个文件</td>
</tr>
<tr>
<td>r</td>
<td>进程的根目录在这个文件系统中</td>
</tr>
<tr>
<td>m,s</td>
<td>进程已经映射了一个文件或者共享库</td>
</tr>
</tbody>
</table>
<p><img src="image-20191126000328683.png" alt="image-20191126000328683"></p>
<p><img src="image-20191126000407140.png" alt="image-20191126000407140"></p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>文件有以下几种类型：普通文件，目录，字符设备文件，块设备文件，本地域套接字，有名管道，符号链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln old ../new#硬链接</div><div class="line">ls -s old ../new#软连接</div></pre></td></tr></table></figure>
<p>硬链接和软链接的区别：硬链接时直接引用，而符号链接是通过名称来引用的。</p>
<p>主设备号告诉内核该文件访问哪个驱动程序，次设备号告诉驱动程序对哪个物理单元寻址。</p>
<p>字符设备文件让与之相关的驱动程序做它们自己的输入和输出缓冲。块设备文件由处理块数据的I/O的驱动程序使用，并要求内核为之缓冲。</p>
<p>setuid和setgid：让执行该命令的用户能够以该命令所有者的权限来执行。</p>
<p>粘滞位（/tmp）：所有的用户能够在该目录下拥有所有的权限，能够在该目录下任意创建文件，修改和删除文件，但是呢，别的用户不能够动到别人的文件</p>
<p>umask：分配默认的权限。默认的umask值是022，它不允许属组和其他用户有写入权限。</p>
<h2 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h2><p>/etc/passwd:用户信息</p>
<p>/etc/shadow:用户密码</p>
<p>linux中口令加密算法及其长度限制 位置：/etc/login.defs</p>
<p>如果把/etc/login.defs中的DEFAULT_HOME设为no，那么就会禁止没有主目录的用户登录。</p>
<p>可以通过chsh命令来改变自己的shell，chfn来修改使用LDAP或者其他目录服务管理登录信息。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>文件名</th>
<th>设置环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>bash</td>
<td>.bashrc     .bash_profile</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>sh</td>
<td>.profile</td>
<td>设置搜索路径/终端类型和环境</td>
</tr>
<tr>
<td>vim</td>
<td>.vimrc       .excr</td>
<td>设置vim编辑器的选项</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo useradd -c "caixueyuan" -d /home/caixueyuan -g caixueyuan -G student -m -s /bin/sh caixueyuan</div><div class="line">userdel caixueyuan#删除用户</div><div class="line">usermod -L user#锁住用户</div><div class="line">usermod -U user#解锁用户</div></pre></td></tr></table></figure>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> -T选项从硬盘的高速缓存中读取信息，并且指示总线上的数据传输率，跟物理硬盘介质的吞吐量有关</span></div><div class="line"><span class="meta">#</span><span class="bash"> -t 从物理盘片读数据</span></div><div class="line">sudo hdparm -Tt /dev/sda</div></pre></td></tr></table></figure>
<p>Linux的LVM配置过程依次为以下不同的阶段：</p>
<ol>
<li><p>创建和初始化物理卷</p>
</li>
<li><p>把物理卷加入到一个卷组中</p>
</li>
<li><p>在卷组中创建逻辑卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">   #</span><span class="bash">创建物理卷</span></div><div class="line">   sudo pvcreate /dev/md0</div><div class="line"><span class="meta">   #</span><span class="bash">创建卷组</span></div><div class="line">   sudo vgcreate DEMO /dev/md0</div><div class="line"><span class="meta">   #</span><span class="bash">创建逻辑卷</span></div><div class="line">   sudo lvcreate -L 100G -n web1 DEMO</div><div class="line"><span class="meta">   #</span><span class="bash">创建文件系统</span></div><div class="line">   sudo mkfs /dev/DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">挂载</span></div><div class="line">   sudo mkdir /mnt/web1</div><div class="line">   sudo mount /dev/DEMO/web1 /mnt/web1</div><div class="line"><span class="meta">   #</span><span class="bash">创建快照（创建快照最好跟数据一样大)</span></div><div class="line">   sudo lvcreate -L 100G -s -n web1-snap DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">给逻辑卷增加空间</span></div><div class="line">   sudo  umount /mnt/web1</div><div class="line">   sudo lvchange -an DEMO/web1</div><div class="line">   sudo lvresize -L +10G DEMo/web1</div><div class="line">   sudo lvchange -ay DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">改变文件系统的大小</span></div><div class="line">   sudo e2fsck -f /dev/DEMO/web1</div><div class="line">   sudo resize2fs /dev/DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">将ext2文件系统转为ext4文件系统</span></div><div class="line">tune2fs -j /dev/hda4</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>   <strong>mkfs</strong>：格式化文件系统</p>
<p>   <strong>fsck</strong>：检查和修复文件系统</p>
<p>   <strong>mount</strong>：挂载文件系统</p>
<p>   <strong>df</strong>:核对一个文件系统的大小</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">挂载硬盘上所有本地的ext4文件系统</span></div><div class="line">sudo mount -at ext4、</div><div class="line"><span class="meta">#</span><span class="bash"> 查看交互分区的设置</span></div><div class="line">sudo swapon -s</div></pre></td></tr></table></figure>
<p>   周期性进程</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">配置方法</span></div><div class="line">55 23 * * 0-3,6 /staff/trent/bin/checkservers</div><div class="line">30 2 * * 1 (cd /user/joe/project; make)</div><div class="line"><span class="meta">#</span><span class="bash"> 用filename来替换任何以前版本的crontab文件</span></div><div class="line">crontab filename</div><div class="line"><span class="meta">#</span><span class="bash"> 编辑文件</span></div><div class="line">crontab -e filename</div><div class="line"><span class="meta">#</span><span class="bash"> cron.deny和cron.allow指定哪些用户可以提交crontab文件</span></div><div class="line"><span class="meta">#</span><span class="bash">删除core文件</span></div><div class="line">find / -xdev -type f '(' -name core -o name 'core.[0-9]*' ')' -atime +7 -exec rm -f &#123;&#125; ';'</div><div class="line">find . ! -name  . ! -name lost+found -type d -mtime +3 -exec /bin/rm -rf &#123;&#125; ';'</div></pre></td></tr></table></figure>
<p>   系统的crontab在/etc/crontab文件中和/etc/cron.d目录中。</p>
<p>   在/etc/cron.daily中的脚本每天运行一次，在/etc/cron.weekly中的脚本每周运行一次。</p>
<h2 id="软件安装和管理"><a href="#软件安装和管理" class="headerlink" title="软件安装和管理"></a>软件安装和管理</h2><h3 id="高级软件包管理系统"><a href="#高级软件包管理系统" class="headerlink" title="高级软件包管理系统"></a>高级软件包管理系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rpm -i#安装</div><div class="line">rpm -U #更新</div><div class="line">rpm -e #卸载</div><div class="line">rpm -q #查询</div><div class="line">rpm -qa #显示系统已经安装的软件包的完整清单</div><div class="line">rpm --query --whatrequires openssh#在尝试升级之前判断出会有其他软件包依赖OpenSSH</div><div class="line">dpkg -l | grep package #判断某个软件是否安装的方便途径</div><div class="line">sudo git rm --cached mtab #在当前的库影像里删除mtab文件</div></pre></td></tr></table></figure>
<ol>
<li>apt-get 最重要的配置文件是/etc/apt/source.list，它告诉apt-get 到哪里去找它的软件包。规定了软件包的类型，指向一个文件/CD-ROM/HTTP服务器或者FTP服务器的URL，组件可能的清单。</li>
<li>apt-mirror在/etc/apt/里放了一个叫做mirror.list的文件，在默认情况下，mirror.list包括了正在使用的Ubuntu版本的所有库。</li>
<li>apt-get dist-upgrade会下载并安装已经在本地机器上安装过的任何软件包的新版本</li>
<li>默认返回yes来使用-yes选项</li>
<li>apt-get –download-only自动下载任何改动过的软件包，但是不安装</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;shell基础知识&quot;&gt;&lt;a href=&quot;#shell基础知识&quot; class=&quot;headerlink&quot; title=&quot;shell基础知识&quot;&gt;&lt;/a&gt;shell基础知识&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="操作系统" scheme="https://caixueyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux系统管理技术手册" scheme="https://caixueyuan.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准模板库</title>
    <link href="https://caixueyuan.github.io/2019/10/25/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <id>https://caixueyuan.github.io/2019/10/25/C-标准模板库/</id>
    <published>2019-10-24T16:24:38.000Z</published>
    <updated>2019-11-07T16:24:50.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string类和标准模板库"><a href="#string类和标准模板库" class="headerlink" title="string类和标准模板库"></a>string类和标准模板库</h2><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> info[<span class="number">100</span>];</div><div class="line"><span class="built_in">cin</span> &gt;&gt; info;</div><div class="line"><span class="built_in">cin</span>.getline(info,<span class="number">100</span>);</div><div class="line"><span class="built_in">cin</span>.get(info,<span class="number">100</span>);</div><div class="line"><span class="built_in">cin</span>.getline(info,<span class="string">":"</span>);</div><div class="line"><span class="built_in">string</span> stuff;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; stuff;</div><div class="line">getline(<span class="built_in">cin</span>,stuff);</div><div class="line">getline(stuff,<span class="string">":"</span>);</div></pre></td></tr></table></figure>
<p>string对象的最大允许长度，由常量string::npos指定，这通常是最大的unsigned int值</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>shared_ptr</strong>:创建智能更高的指针，跟踪引用特定对象的智能指针数，引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用delete。</p>
<p><strong>auto_ptr</strong>：建立所有权概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。</p>
<p><strong>unique_ptr</strong>:如果出现了浅拷贝的赋值方式下，会在编译的过程中报错误</p>
<p>能够使用auto_ptr的地方最好使用unique_ptr，能够在编译的过程中设别浅拷贝风险。</p>
<p>unique_ptr智能指针有数组和非数组的方式</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="title">class</span> <span class="title">TooBig2</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span>:T cutoff;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    TooBig2(<span class="keyword">const</span> T &amp; t):cutoff(t)&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>&#123;<span class="keyword">return</span> tooBig&lt;T&gt;(v,cutoff)&#125;<span class="comment">//函数对象</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;class T&gt;</div><div class="line"><span class="keyword">bool</span> tooBig(<span class="keyword">const</span> T &amp; val,<span class="keyword">const</span> T &amp; lim)&#123;<span class="keyword">return</span> val&gt;lim;&#125;</div><div class="line"></div><div class="line">TooBig2&lt;<span class="keyword">int</span>&gt; tB100(<span class="number">100</span>);</div><div class="line"><span class="keyword">int</span> x;<span class="built_in">cin</span> &gt;&gt; x;</div><div class="line"><span class="keyword">if</span>(tB100(x))<span class="comment">//same as if (tooBig(x,100))</span></div><div class="line"><span class="comment">//调用tB100(x)相当于调用tooBig(x,100),但两个参数的函数转换为单参数的函数对象，其中第二个参数被用于构建函数对象，简而言之，类函数符TooBig2时一个函数适配器，使得函数能够满足不同的接口</span></div></pre></td></tr></table></figure>
<p>复制构造函数和移动构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复制构造函数</span></div><div class="line">Useless &amp; Useless:<span class="keyword">operator</span>=(<span class="keyword">const</span> Useless &amp; f)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;f)</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span>[] pc;</div><div class="line">    n = f.n;</div><div class="line">    pc = <span class="keyword">new</span> <span class="keyword">char</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        pc[i]=f.pc[<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//移动构造函数</span></div><div class="line">Useless &amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp; f)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;f)</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span>[] pc;</div><div class="line">    n = f.n;</div><div class="line">    pc = f.pc;</div><div class="line">    f.n = <span class="number">0</span>;</div><div class="line">    f.pc = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以使用std::move来强制调用移动构造函数</span></div><div class="line">Useless four = <span class="built_in">std</span>::move(one);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string类和标准模板库&quot;&gt;&lt;a href=&quot;#string类和标准模板库&quot; class=&quot;headerlink&quot; title=&quot;string类和标准模板库&quot;&gt;&lt;/a&gt;string类和标准模板库&lt;/h2&gt;&lt;h3 id=&quot;string类&quot;&gt;&lt;a href=&quot;#st
    
    </summary>
    
      <category term="C++,学习笔记" scheme="https://caixueyuan.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://caixueyuan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>powershell学习笔记</title>
    <link href="https://caixueyuan.github.io/2019/09/08/powershell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2019/09/08/powershell学习笔记/</id>
    <published>2019-09-08T04:41:58.000Z</published>
    <updated>2019-10-21T14:41:36.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="powershell交互式"><a href="#powershell交互式" class="headerlink" title="powershell交互式"></a>powershell交互式</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查询别名所指的真实cmdlet命令。</span></div><div class="line"><span class="built_in">Get-Alias</span> -name ls</div><div class="line"><span class="comment"># 查看所有以Remove打头的cmdlet命令的别名</span></div><div class="line">ls alias: | where &#123;<span class="variable">$_</span>.Definition.Startswith(<span class="string">"Remove"</span>)&#125;</div><div class="line"><span class="comment"># 设置别名</span></div><div class="line"><span class="built_in">Set-Alias</span> -Name edit -Value notepad</div><div class="line"><span class="comment"># 显示别名</span></div><div class="line">echo <span class="variable">$alias:edit</span></div><div class="line"><span class="comment">#删除别名</span></div><div class="line">del-Alias alias:edit</div><div class="line"><span class="comment">#保存别名</span></div><div class="line"><span class="built_in">Import-Alias</span> alias.ps1</div><div class="line"><span class="comment">#导入别名</span></div><div class="line"><span class="built_in">Export-Alias</span> -force alias.ps1</div><div class="line"><span class="comment">#使用函数</span></div><div class="line"><span class="keyword">function</span> test-conn</div><div class="line">&#123;</div><div class="line"><span class="built_in">Test-Connection</span> -Count <span class="number">2</span> -ComputerName <span class="variable">$args</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Set-Alias</span> tc test-conn</div><div class="line">tc <span class="number">127.0</span>.<span class="number">0.1</span></div><div class="line"><span class="comment"># 获取文件的内容</span></div><div class="line"><span class="built_in">Get-Content</span> test.ps1</div></pre></td></tr></table></figure>
<p>powershell解析命令的顺序</p>
<ol>
<li>别名</li>
<li>函数</li>
<li>cmdlets，内置命令</li>
<li>外部的ps1文件</li>
<li>外部的普通文件</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建只读变量</span></div><div class="line"><span class="built_in">New-Variable</span> num -Value <span class="number">100</span> -Force -Option readonly</div><div class="line"><span class="comment">#删除变量</span></div><div class="line">del Variable:num -Force</div><div class="line"><span class="comment">#声明常量</span></div><div class="line"><span class="built_in">new-variable</span> num -Value <span class="string">"strong"</span> -Option constant</div><div class="line"><span class="comment">#查看变量表述</span></div><div class="line"><span class="built_in">new-variable</span> name -Value <span class="string">"me"</span> -Description <span class="string">"This is my name"</span></div></pre></td></tr></table></figure>
<h3 id="特殊变量说明"><a href="#特殊变量说明" class="headerlink" title="特殊变量说明"></a>特殊变量说明</h3><table>
<thead>
<tr>
<th>$$</th>
<th>包含会话所收到的最后一行的最后一个令牌</th>
</tr>
</thead>
<tbody>
<tr>
<td>$?</td>
<td>包含最后一个操作的执行状态</td>
</tr>
<tr>
<td>$^</td>
<td>包含会话所收到的最后一行的第一个令牌</td>
</tr>
<tr>
<td>$_</td>
<td>包含管道对象中的当前对象</td>
</tr>
<tr>
<td>$Args</td>
<td>包含由未声明参数或传递给函数，脚本或脚本块的参数值组成的数组</td>
</tr>
<tr>
<td>$LastExitCode</td>
<td>包含运行的最后一个基于windows的程序的退出代码</td>
</tr>
</tbody>
</table>
<p><strong>环境变量</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查找环境变量</span></div><div class="line">ls env:</div><div class="line"><span class="comment"># 创建新的环境变量</span></div><div class="line"><span class="variable">$env:mytest</span> = <span class="string">"This is my test"</span></div><div class="line"><span class="comment"># 对当前用户设置环境变量，重新打开powershell仍然有效</span></div><div class="line">[environment]::SetEnvironmentvariable(<span class="string">"Path"</span>, <span class="string">";c:\powershellscript"</span>, <span class="string">"User"</span>)</div><div class="line">[environment]::GetEnvironmentvariable(<span class="string">"Path"</span>, <span class="string">"User"</span>)</div></pre></td></tr></table></figure>
<p><strong>更改变量的可见性</strong>：在运行脚本时使用一个原点和空格，powershell不会给脚本创建自己的变量作用域，它会共享当前控制台的作用域。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><table>
<thead>
<tr>
<th>变量</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>$global</td>
<td>全局变量，在所有的作用域中有效</td>
</tr>
<tr>
<td>$script</td>
<td>脚本变量，只会在脚本内部有效，包括脚本中的函数，一旦脚本运行结束，就会被回收</td>
</tr>
<tr>
<td>$private</td>
<td>只在当前作用域有效</td>
</tr>
<tr>
<td>$local</td>
<td>默认变量，在当前作用域有效，其他作用域只对它有只读权限</td>
</tr>
</tbody>
</table>
<p>$private限制的变量不能够再$global修改，不但不能够修改，还会删除当前的值</p>
<p>$local修饰的变量可以通过$global在函数内部更改</p>
<p><strong>变量类型</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义强类型变量</span></div><div class="line">[byte]<span class="variable">$b</span>=<span class="number">101</span></div><div class="line">[ XML ]<span class="variable">$xml</span>=(<span class="built_in">Get-Content</span> .LogoTestConfig.xml)</div><div class="line"><span class="comment"># 修改变量的属性</span></div><div class="line">(<span class="built_in">Get-Variable</span> str).Description=<span class="string">"变量的描述已经改变"</span></div><div class="line"><span class="built_in">Get-Variable</span> str | <span class="built_in">format-table</span> Name,Description</div><div class="line"><span class="built_in">Set-Variable</span> var -Option <span class="string">"ReadOnly"</span></div><div class="line">(<span class="built_in">Get-Variable</span> var).Options</div><div class="line"><span class="comment"># Attributes属性</span></div><div class="line"><span class="variable">$var</span>=<span class="string">"限制变量"</span></div><div class="line"><span class="variable">$condition</span>= <span class="built_in">New-Object</span> System.Management.Automation.ValidateLengthAttribute -ArgumentList <span class="number">2</span>,<span class="number">5</span></div><div class="line">(<span class="built_in">Get-Variable</span> var).Attributes.Add(<span class="variable">$condition</span>)</div></pre></td></tr></table></figure>
<p>Attributes[System.Management.Automation.PSVariableAttributeCollection]属性，如果这个Attributes为空，可以给这个变量存放任何 类型的数据，Powershell会自己选择合适的类型。一旦这个Attributes属性确定下来，就不能随意存放数据了</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 判断变量的类型</span></div><div class="line"><span class="variable">$ip</span> -is [array]</div><div class="line"><span class="variable">$ip</span>.ToCharArray() -is [array]</div><div class="line">ipconfig | <span class="built_in">Select-String</span> <span class="string">"IP"</span></div><div class="line"><span class="comment"># 创建空数组</span></div><div class="line"><span class="variable">$a</span>=@()</div><div class="line"><span class="comment"># 创建一个元素的数组</span></div><div class="line"><span class="variable">$a</span>=,<span class="string">"moss"</span></div><div class="line"><span class="comment">#访问数组</span></div><div class="line"><span class="variable">$result</span>[result.count(<span class="number">0</span>-<span class="number">1</span>)]</div><div class="line"><span class="comment">#逆序输出数组</span></div><div class="line"><span class="variable">$books</span>[(<span class="variable">$books</span>.count)..<span class="number">0</span>]</div><div class="line"><span class="comment">#添加元素</span></div><div class="line"><span class="variable">$books</span>+=<span class="string">"元素4"</span></div><div class="line"><span class="comment">#复制数组</span></div><div class="line"><span class="variable">$chsBak</span>=<span class="variable">$chs</span> <span class="comment">#浅复制</span></div><div class="line"><span class="variable">$chsBak</span>=<span class="variable">$chs</span>.Clone() <span class="comment">#深复制</span></div><div class="line"><span class="comment">#查看和验证变量的数据类型</span></div><div class="line"><span class="variable">$result</span>.gettype().name</div><div class="line"><span class="comment">#int类型的最大值</span></div><div class="line">([int32]::MaxValue)</div><div class="line"><span class="comment">#强类型数组</span></div><div class="line">[int[]] <span class="variable">$nums</span>=@()</div><div class="line"><span class="comment">#哈希表</span></div><div class="line"><span class="variable">$str</span>=@&#123;Name=<span class="string">"小明"</span>;Age=<span class="string">"12"</span>&#125;</div><div class="line"><span class="variable">$str</span>.Keys</div><div class="line"><span class="variable">$str</span>.Values</div><div class="line"><span class="variable">$str</span>.Remove(<span class="string">"Name"</span>)</div></pre></td></tr></table></figure>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><img src="管道.png" alt="1567933553288"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#遍历C盘的所有文件</span></div><div class="line">Dir C: -recurse</div><div class="line"><span class="comment">#以脚本块作为属性</span></div><div class="line">ls | <span class="built_in">Format-Table</span> Name,&#123; [int](<span class="variable">$_</span>.Length/<span class="number">1</span>kb) &#125;</div><div class="line"><span class="variable">$column</span> = @&#123;Expression=&#123; [int](<span class="variable">$_</span>.Length/<span class="number">1</span>KB) &#125;; Label=<span class="string">"KB"</span> &#125;</div><div class="line">Dir | <span class="built_in">Format-Table</span> Name, <span class="variable">$column</span></div><div class="line">ls | <span class="built_in">Format-Table</span> -AutoSize</div><div class="line"><span class="comment">#排序</span></div><div class="line">ls | <span class="built_in">Sort-Object</span> Length -Descending</div><div class="line">Dir | <span class="built_in">Sort-Object</span> @&#123;expression=<span class="string">"Length"</span>;Descending=<span class="literal">$true</span>&#125;,@&#123;ex</div><div class="line">pression=<span class="string">"Name"</span>;Ascending=<span class="literal">$true</span>&#125;</div><div class="line"><span class="comment">#分组</span></div><div class="line">ls | <span class="built_in">Group-Object</span> Extension <span class="comment">#按照扩展名进行分组</span></div><div class="line">ls | <span class="built_in">Group-Object</span> &#123;<span class="variable">$_</span>.name.SubString(<span class="number">0</span>,<span class="number">1</span>).toUpper()&#125; <span class="comment">#按照首字母来排序</span></div><div class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Group-Object</span> Company -NoElement <span class="comment">#根据当前应用程序的发布者分组</span></div><div class="line"><span class="built_in">Get-service</span> | <span class="built_in">Select-Object</span> -First <span class="number">1</span> | <span class="built_in">format-list</span> *</div><div class="line"><span class="built_in">Get-service</span> | <span class="built_in">Select-Object</span> -First <span class="number">1</span> | <span class="built_in">Get-Member</span> -MemberType</div><div class="line"><span class="built_in">get-service</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">"Running"</span>&#125;</div><div class="line"><span class="comment"># 流出最后修改的5个文件</span></div><div class="line">Dir | <span class="built_in">Select-Object</span> -ExcludeProperty <span class="string">"*N*"</span> -First <span class="number">5</span></div><div class="line"><span class="comment">#统计和计算</span></div><div class="line">ls | measure length -Average -Sum -Maximum -Minimum</div></pre></td></tr></table></figure>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建对象</span></div><div class="line"><span class="variable">$pocketknife</span>=<span class="built_in">New-Object</span> object</div><div class="line"><span class="comment"># 并向对象逐个增加属性</span></div><div class="line"><span class="built_in">Add-Member</span> -InputObject <span class="variable">$pocketknife</span> -Name Color -Value <span class="string">"Red"</span> -MemberType NoteProperty</div><div class="line"><span class="variable">$pocketknife</span> | <span class="built_in">Add-Member</span> NoteProperty Blades <span class="number">3</span></div><div class="line"><span class="built_in">Add-Member</span> -memberType ScriptMethod <span class="nomarkup">-In</span> <span class="variable">$pocketknife</span> -name cut -Value &#123; <span class="string">"I'm whittling now"</span> &#125;</div><div class="line"><span class="variable">$pocketknife</span> | <span class="built_in">Add-Member</span> ScriptMethod corkscrew &#123; <span class="string">"Pop! Cheers!"</span> &#125;</div><div class="line"><span class="comment">#调用方法时一定要加上原括号，方法不会执行，但是可以返回方法的基本信息</span></div><div class="line"><span class="variable">$pocketknife</span>.cut()</div><div class="line"><span class="comment"># 获取枚举变量的值</span></div><div class="line">[System.Enum]::GetNames([System.ConsoleColor])</div><div class="line"><span class="comment"># 查看所有属性，返回成员详细信息，如果只显示属性可以使用参数memberType为"Porperty"</span></div><div class="line"><span class="variable">$host</span> | <span class="built_in">Get-Member</span> -memberType property</div><div class="line"><span class="comment"># 列出一个对象的所有方法</span></div><div class="line"><span class="variable">$Host</span> | <span class="built_in">Get-Member</span> -MemberType Method</div><div class="line"><span class="variable">$Host</span>.UI.RawUI | <span class="built_in">Get-Member</span> -me method | where &#123;<span class="variable">$_</span>.Name <span class="nomarkup">-notlike</span> <span class="string">'*_*'</span>&#125;</div><div class="line"><span class="comment">#列出静态方法</span></div><div class="line">[System.DateTime] | <span class="built_in">Get-Member</span> -static -memberType *Method</div><div class="line"><span class="comment"># 调用静态方法</span></div><div class="line">[System.DateTime]::Parse(<span class="string">"2012-10-13 23:42:55"</span>)</div><div class="line">[String].GetConstructors() | <span class="keyword">foreach</span> &#123;<span class="variable">$_</span>.tostring()&#125;</div></pre></td></tr></table></figure>
<p>MemberType包括</p>
<p><strong>AliasProperty</strong>：另外一个属性的别名<br><strong>CodeProperty</strong>：通过静态的.Net方法返回属性的内容<br><strong>Property</strong>：真正的属性<br><strong>NoteProperty</strong>：随后增加的属性<br><strong>ScriptProperty</strong>：通过脚本执行返回一个属性的值<br><strong>ParameterizedProperty</strong>：需要传递参数的属性</p>
<h2 id="循环和判断"><a href="#循环和判断" class="headerlink" title="循环和判断"></a>循环和判断</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取进程名称为notepad的进程</span></div><div class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.Name <span class="nomarkup">-eq</span> <span class="string">"notepad"</span>&#125;</div><div class="line"><span class="comment"># switch使用方式</span></div><div class="line"><span class="keyword">switch</span>(<span class="variable">$value</span>)</div><div class="line">&#123;</div><div class="line">    <span class="number">1</span> &#123;<span class="string">"Beijing"</span>&#125;</div><div class="line">    <span class="number">2</span> &#123;<span class="string">"Shanghai"</span>&#125;</div><div class="line">    <span class="number">3</span> &#123;<span class="string">"Tianjin"</span>&#125;</div><div class="line">    <span class="number">4</span> &#123;<span class="string">"Chongqing"</span>&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">#foreach-object方法</span></div><div class="line"><span class="built_in">Get-WmiObject</span> Win32_Service | <span class="built_in">ForEach-Object</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$_</span>.ProcessId <span class="nomarkup">-gt</span> <span class="number">3000</span>)</div><div class="line">    &#123; <span class="string">"&#123;0&#125;(&#123;1&#125;)"</span> -f <span class="variable">$_</span>.DisplayName,<span class="variable">$_</span>.ProcessID&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 对管道结果逐个处理</span></div><div class="line"><span class="keyword">foreach</span>(<span class="variable">$file</span> <span class="keyword">in</span> dir c:\windows)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="variable">$file</span>.Length <span class="nomarkup">-gt</span> <span class="number">1</span>mb)</div><div class="line">    &#123;</div><div class="line">        <span class="variable">$File</span>.Name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 逐行读取文件</span></div><div class="line"><span class="keyword">for</span>(<span class="variable">$file</span>=[IO.File]::OpenText(<span class="string">"c:autoexec.bat"</span>) ; !(<span class="variable">$file</span>.EndOfStream);<span class="variable">$line</span>=<span class="variable">$file</span>.ReadLine() )</div><div class="line">&#123;</div><div class="line">    <span class="variable">$line</span>;</div><div class="line">&#125;</div><div class="line"><span class="variable">$file</span>.Close()</div><div class="line"><span class="comment">#函数</span></div><div class="line"><span class="keyword">Function</span> FuncName （args[]）</div><div class="line">&#123;</div><div class="line">      code;</div><div class="line">&#125;</div><div class="line">del <span class="keyword">function</span>:funcName</div><div class="line"><span class="comment"># 定义输入参数类型</span></div><div class="line"><span class="keyword">function</span> subtract([int]<span class="variable">$value1</span>=<span class="number">0</span>,[int]<span class="variable">$value2</span>=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#从这里开始隐藏所有的错误信息</span></div><div class="line"><span class="variable">$ErrorActionPreference</span>=<span class="string">"SilentlyContinue"</span> <span class="comment"># 关闭错误输出</span></div><div class="line"><span class="variable">$ErrorActionPreference</span>=<span class="string">"Continue"</span> <span class="comment">#开启错误输出</span></div><div class="line"><span class="comment"># 管道</span></div><div class="line"><span class="variable">$input</span> <span class="comment">#管道输入</span></div><div class="line"><span class="variable">$args</span> <span class="comment">#参数输入</span></div></pre></td></tr></table></figure>
<h2 id="powershell脚本"><a href="#powershell脚本" class="headerlink" title="powershell脚本"></a>powershell脚本</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取和更改脚本执行策略</span></div><div class="line"><span class="built_in">Get-ExecutionPolicy</span></div><div class="line"><span class="built_in">Set-ExecutionPolicy</span> UnRestricted</div></pre></td></tr></table></figure>
<p><strong>Unrestricted:</strong>权限最高，可以不受限制执行任何脚本。<br><strong>Default:</strong>为Powershell默认的策略：Restricted，不允许任何脚本执行。<br><strong>AllSigned：</strong>所有脚本都必须经过签名才能在运行。<br><strong>RemoteSigned：</strong>本地脚本无限制，但是对来自网络的脚本必须经过签名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 给脚本的参数绑定数据类型，绑定帮助信息，如果脚本缺少参数，或者输入的参数类型不正确，就会报错	</span></div><div class="line"><span class="keyword">param</span>(</div><div class="line">[string]<span class="variable">$Name</span>=$(<span class="keyword">throw</span> <span class="string">"Parameter missing: -name Name"</span>) ,</div><div class="line">[int]<span class="variable">$Age</span>=$(<span class="keyword">throw</span> <span class="string">"Parameter missing: -age x as number"</span>)</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="string">"Name= <span class="variable">$Name</span>"</span></div><div class="line"><span class="string">"Age=<span class="variable">$Age</span>"</span></div></pre></td></tr></table></figure>
<p>在Powershell脚本的处理中，绝大多数情况下遇到的都是集合，一旦上一条命令产生一个中间结果，下一条命令就对这个中间结果及时处理，及时释放资源。这样可以节省内存，也减少了用户的等待时间。在处理大量数据时，尤其值得推荐。高速流模式的管道定义包括三部分：begin,process,end。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">Write-Host</span> <span class="string">"管道脚本环境初始化"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">process</span></div><div class="line">&#123;</div><div class="line">    <span class="variable">$ele</span>=<span class="variable">$_</span></div><div class="line">    <span class="keyword">if</span>(<span class="variable">$_</span>.Extension <span class="nomarkup">-ne</span> <span class="string">""</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">switch</span>(<span class="variable">$_</span>.Extension.tolower())</div><div class="line">        &#123;</div><div class="line">            <span class="string">".ps1"</span> &#123;<span class="string">"脚本文件："</span>+ <span class="variable">$ele</span>.name&#125;</div><div class="line">            <span class="string">".txt"</span> &#123;<span class="string">"文本文件："</span>+ <span class="variable">$ele</span>.Name&#125;</div><div class="line">            <span class="string">".gz"</span>  &#123;<span class="string">"压缩文件："</span>+ <span class="variable">$ele</span>.Name&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">Write-Host</span> <span class="string">"管道脚本环境恢复"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件查找操作</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 支持正则表达式</span></div><div class="line">Dir <span class="variable">$home</span> -include [a-f]*.ps1 -recurse</div><div class="line"><span class="comment"># 具体为当你的过滤条件没有正则表达式时，使用-filter，可以显著提高效率。</span></div><div class="line">Dir <span class="variable">$home</span> -recurse | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.length <span class="nomarkup">-gt</span> <span class="number">100</span>MB &#125;</div><div class="line"><span class="comment"># 获取目录下的文件 Get-Childitem dir</span></div><div class="line"><span class="comment"># 获取文件 get-item</span></div></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$CurrentyDir</span> = <span class="built_in">Split-Path</span> -Parent <span class="variable">$MyInvocation</span>.MyCommand.Definition;</div><div class="line"><span class="variable">$parentDir</span> = (<span class="built_in">get-item</span> <span class="variable">$CurrentyDir</span> ).parent.FullName</div><div class="line">echo <span class="variable">$parentDir</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;powershell交互式&quot;&gt;&lt;a href=&quot;#powershell交互式&quot; class=&quot;headerlink&quot; title=&quot;powershell交互式&quot;&gt;&lt;/a&gt;powershell交互式&lt;/h2&gt;&lt;h3 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; cla
    
    </summary>
    
      <category term="shell学习笔记" scheme="https://caixueyuan.github.io/categories/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="shell" scheme="https://caixueyuan.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>C++高级知识</title>
    <link href="https://caixueyuan.github.io/2019/09/04/C-%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2019/09/04/C-高级知识/</id>
    <published>2019-09-03T16:03:59.000Z</published>
    <updated>2019-10-23T16:28:45.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p><strong>概念解析</strong></p>
<p>1，隐式实例化:声明一个或者多个对象，指出所需要的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;T1,T2&gt;</span></div><div class="line">&#123;</div><div class="line">	T1 t1;</div><div class="line">	T2 t2;</div><div class="line">&#125;</div><div class="line">ArrayTP&lt;<span class="keyword">int</span>,<span class="number">100</span>&gt; stuff;<span class="comment">//隐式实例化</span></div></pre></td></tr></table></figure>
<p>2，显式实例化：当使用关键字template并指出所需类型来声明类是，将生成类声明的显性实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;string,100&gt;;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，没有创建或提及类对象，但是编译器将生成类声明</p>
<p>3，显式具体化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedArray</span></span></div><div class="line">&#123;  </div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">SortedArray</span>&lt;const char *&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//显式具体化</span></div><div class="line">&#125;;</div><div class="line">SortedArray&lt;<span class="keyword">int</span>&gt; scores;<span class="comment">//使用第一个</span></div><div class="line">SortedArray&lt;con <span class="keyword">char</span> *&gt; detes;<span class="comment">//使用第二个</span></div></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">marm</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">//标志marm不抛出任何错误</span></div><div class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)<span class="keyword">int</span>;<span class="comment">//如果出现分配内存失败不会报错误，而是返回空指针</span></div></pre></td></tr></table></figure>
<p>引发异常时总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。基类引用可以执行派生类对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类模板&quot;&gt;&lt;a href=&quot;#类模板&quot; class=&quot;headerlink&quot; title=&quot;类模板&quot;&gt;&lt;/a&gt;类模板&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，隐式实例化:声明一个或者多个对象，指出所需要的类型&lt;/p&gt;
&lt;figu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://caixueyuan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类的使用</title>
    <link href="https://caixueyuan.github.io/2019/08/08/C-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2019/08/08/C-类的使用/</id>
    <published>2019-08-08T15:22:58.000Z</published>
    <updated>2019-08-11T16:57:58.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h2><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p><img src="调用复制构造函数.png" alt="1565278116357"></p>
<p>复制构造函数是要通过复制类来实现新建类。</p>
<p><strong>默认的复制构造函数是浅复制，也就是只复制字面性变量，不复制指针类型，所以这里一定要注意一种错误，就是容易导致多个变量析构同一块内存导致报错误。</strong></p>
<p><img src="复制构造函数.png" alt="1565277907579"></p>
<p>上图为深复制，也就是对于指针类型所指定的对象也能够实现复制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> StringBad temp)</span></span>;<span class="comment">//这样的传值函数也是使用传值，也就是要变成</span></div><div class="line">StringBad input;</div><div class="line">show(input);<span class="comment">//void show()&#123; StringBad temp = input;&#125;调用了复制构造函数</span></div></pre></td></tr></table></figure>
<h3 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">"message"</span>)</span></span>;</div><div class="line">StringBad knot;</div><div class="line">knot = headline1;<span class="comment">//这里使用的是赋值构造函数，因为对于knot已经进行初始化，已经有一块内存啦，只是将headline1的内容赋值给knot内存而已</span></div><div class="line">StringBad metto = knot;<span class="comment">//对于这里，metto本身是没有内存的，所以这个时候需要初始化一块内存出来，所以这里使用的是复制构造函数，复制一块内存来构造对象</span></div><div class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个引用，赋值构造函数</span></div><div class="line">StringBad::StringBad(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个对象，是复制构造函数</span></div></pre></td></tr></table></figure>
<p><strong>复制构造函数</strong>：返回一个对象，也就是一块内存</p>
<p><strong>赋值构造函数</strong>：返回一个引用，并没有多出一块内存，只是将旧内存赋值给新内存而已</p>
<h3 id="使用复制构造函数和赋值析构函数的时机"><a href="#使用复制构造函数和赋值析构函数的时机" class="headerlink" title="使用复制构造函数和赋值析构函数的时机"></a>使用复制构造函数和赋值析构函数的时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Star sirius;</div><div class="line">Star copy = sirius;<span class="comment">//复制构造函数</span></div><div class="line">Star assignment;</div><div class="line">assignment = sirius;<span class="comment">//赋值构造函数</span></div></pre></td></tr></table></figure>
<p><code>Star copy = sirius;</code>这里是由于类没有被初始化，所以需要new出来一个对象，这个时候需要调用复制构造函数</p>
<p><code>assignment = sirius;</code>这里是因为类已经被初始化，内存空间已经存在，只是将其他对象的值复制到当前对象中，所以这个时候调用的是赋值构造函数</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>如果要把临时对象返回，要返回对象而不是引用或者指针。因为临时对象会被析构</li>
<li>new和delete对应，new[] 和 delete[]，一定要注意，delete[] 是delete多对象，包含了char * temp = “abc”这种情况</li>
</ol>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><h3 id="派生类的调用"><a href="#派生类的调用" class="headerlink" title="派生类的调用"></a>派生类的调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tabtenn1.h -- a table-tennis base class</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="comment">// simple base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> firstname;</div><div class="line">    <span class="built_in">string</span> lastname;</div><div class="line">    <span class="keyword">bool</span> hasTable;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// simple derived class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                 <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123;rating = r;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">TableTennisPlayer parent;</div><div class="line">parent.Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer son;</div><div class="line">son.Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//对于引用和指针都是一样的情况，只会根据静态类型来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer *son1 = <span class="keyword">new</span> RatedPlayer();</div><div class="line">son1-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//如果对于父类的Name函数的定义为virtual void Name() const;会根据类的动态类型（实际类型）来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div></pre></td></tr></table></figure>
<ol>
<li><strong>如果是对象的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果是引用或者指针的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果使用virtual的话，将根据指针或者引用所对应的实际类型来调用函数</strong></li>
</ol>
<h3 id="继承中基类和派生类："><a href="#继承中基类和派生类：" class="headerlink" title="继承中基类和派生类："></a>继承中基类和派生类：</h3><p>构造函数不能够为虚函数，而析构函数应是虚函数，除非类不能够做基类。基类要保证基类中的成员变量能够被正常析构，派生类也要保证派生类中的成员变量能够被正常析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * base1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Base()&#123;<span class="keyword">delete</span>[] base1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * derived1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Derived()&#123;<span class="keyword">delete</span>[] derived1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//基类要保证基类的成员变量被析构，派生类要保证派生类中的成员变量被析构</span></div></pre></td></tr></table></figure>
<p>在派生类中定义类的话，要确定是使用父类还是子类的函数，通过作用域来进行获取。</p>
<p>最好要对类数据成员采用私有访问控制private，不要使用保护控制控制protected，同时通过基类方法使得派生类能够访问到基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//最好使用这一种</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBase1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> base1;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>友元函数并非是类的成员函数，不能够被继承</strong></p>
<h3 id="什么样的成员变量要被析构掉"><a href="#什么样的成员变量要被析构掉" class="headerlink" title="什么样的成员变量要被析构掉"></a>什么样的成员变量要被析构掉</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * label;</div><div class="line">    <span class="keyword">char</span> message[<span class="number">100</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>成员变量label是指针，其对象是被new出来的，指针所指的对象是在堆中，需要被析构掉</p>
<p>成员变量message是数组，其对象不是被new出来的，对象所存在的内存空间是在栈中，不需要被析构，可以被C++自动析构掉。</p>
<h3 id="派生类的使用"><a href="#派生类的使用" class="headerlink" title="派生类的使用"></a>派生类的使用</h3><p><strong>当初始化列表包含多个项目时，这些项目的初始化顺序时跟类的声明顺序保持一致，而不是在初始化列表中的顺序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> m_a;</div><div class="line">    <span class="keyword">int</span> m_b;</div><div class="line">    <span class="keyword">int</span> m_c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base(<span class="keyword">int</span> a,<span class="keyword">int</span> c,<span class="keyword">int</span> b):m_c(c),m_b(b),m_a(a)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用using来重新定义访问权限</strong></p>
<p>在访问基类的成员函数时，我们需要使用<code>std::valarray&lt;double&gt;::min()</code>来调用基类的成员函数的，但是如果我们使用了using来将基类的成员函数引入到派生类中，这样我们可以像使用派生类的成员函数一样使用基类的成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用using的方式将基类的成员函数引入到当前类中，这样就能够像使用当前类的成语函数一样去使用基类的成员函数</p>
<h3 id="类的静态成员变量或者静态成语函数"><a href="#类的静态成员变量或者静态成语函数" class="headerlink" title="类的静态成员变量或者静态成语函数"></a>类的静态成员变量或者静态成语函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> Base::a = <span class="number">1</span>;<span class="comment">//正确，初始化类的静态成员变量的时候不需要考虑访问权限</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; Base::a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//错误，访问静态成员变量的时候还是要考虑访问权限的</span></div></pre></td></tr></table></figure>
<ol>
<li>不能通过类名来调用类的非静态成员函数</li>
<li>类的对象能够使用静态成员函数和非静态成员函数</li>
<li>静态成员函数不能够引用非静态成员函数</li>
<li>类的非静态成员函数可以调用静态成员函数</li>
</ol>
<p><strong>原因：</strong></p>
<p>首先，类的静态函数是属于类的，类在没有初始化的时候就应该有的，所以类的静态函数不能够引用类的非静态成员函数，因为在类未初始化之前还没有非静态成员函数，如果调用非静态成员就会报错</p>
<p>类的非静态成员函数在调用时，这时类的静态成员函数早已经可用啦，所以能够调用</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&#123;</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;<span class="comment">//会报错误</span></div><div class="line"></div><div class="line"><span class="comment">//使用虚继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;</div><div class="line"><span class="comment">//构造函数</span></div><div class="line">SingerWaiter::SingerWaiter(<span class="keyword">const</span> Worker &amp;wt):Worker(wt),Singer(wt),Waiter(wt)&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>报错误的原因</strong>：</p>
<p>如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例，也就是说从Singer和Waiter两个基类中继承了两个Worker，多个基类实例都是问题</p>
<p><strong>采用虚继承</strong>：</p>
<p>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数</p>
<p>通过优先规则来解决二义性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类和动态内存分配&quot;&gt;&lt;a href=&quot;#类和动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;类和动态内存分配&quot;&gt;&lt;/a&gt;类和动态内存分配&lt;/h2&gt;&lt;h3 id=&quot;复制构造函数&quot;&gt;&lt;a href=&quot;#复制构造函数&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础命令</title>
    <link href="https://caixueyuan.github.io/2019/08/06/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://caixueyuan.github.io/2019/08/06/Linux基础命令/</id>
    <published>2019-08-05T16:23:23.000Z</published>
    <updated>2019-08-29T16:58:49.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux用户管理"><a href="#linux用户管理" class="headerlink" title="linux用户管理"></a>linux用户管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">新增用户</span></div><div class="line">useradd -m cxy -d /home/cxy -g group -u uid</div><div class="line"><span class="meta">#</span><span class="bash">修改用户的根目录</span></div><div class="line">usermod -d /home/cxy_new -m cxy</div><div class="line"><span class="meta">#</span><span class="bash">锁住用户</span></div><div class="line">usermod -L cxy</div><div class="line"><span class="meta">#</span><span class="bash">解锁用户</span></div><div class="line">usermod -U cxy</div><div class="line"><span class="meta">#</span><span class="bash">删除用户</span></div><div class="line">userdel cxy</div><div class="line"><span class="meta">#</span><span class="bash">添加用户组</span></div><div class="line">groupadd group1</div><div class="line"><span class="meta">#</span><span class="bash">删除用户组</span></div><div class="line">groupdel group1</div><div class="line"><span class="meta">#</span><span class="bash">查看用户的详细信息</span></div><div class="line">w</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash">查看定时任务后台程序是否启动</span></div><div class="line">systemctl | grep cron</div><div class="line">systemctl | grep crond</div><div class="line"><span class="meta">#</span><span class="bash">将定时任务加入到前台程序中</span></div><div class="line">crontab job1.cron</div><div class="line"><span class="meta">#</span><span class="bash">查看程序中的定时任务</span></div><div class="line">crontab -l</div><div class="line"><span class="meta">#</span><span class="bash">查看程序中的定时任务</span></div><div class="line">crontab -r</div><div class="line"><span class="meta">#</span><span class="bash">只能够有一个定时任务</span></div></pre></td></tr></table></figure>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看目录下所有问题，包括隐藏文件</span></div><div class="line">ls -la</div><div class="line"><span class="meta">#</span><span class="bash">加上-n参数可以显示每行的行数</span></div><div class="line">cat -n file.log</div><div class="line"><span class="meta">#</span><span class="bash">查看文件的头20行</span></div><div class="line">head -n 20 file.log</div><div class="line"><span class="meta">#</span><span class="bash">查看文件的尾20行</span></div><div class="line">tail -n 20 file.log</div><div class="line"><span class="meta">#</span><span class="bash">动态查看文件的尾部10行</span></div><div class="line">tail -f file.log</div><div class="line"><span class="meta">#</span><span class="bash">将window文件转换为linux文件</span></div><div class="line">dos2unix file.log</div><div class="line"><span class="meta">#</span><span class="bash">创建目录</span></div><div class="line">mkdir -p /opt/oss/caixueyuan</div></pre></td></tr></table></figure>
<h3 id="文件和目录的权限"><a href="#文件和目录的权限" class="headerlink" title="文件和目录的权限"></a>文件和目录的权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">设置文件为隐藏文件</span></div><div class="line">chattr +a a.log</div><div class="line"><span class="meta">#</span><span class="bash">设置文件为非隐藏文件</span></div><div class="line">chattr -a a.log</div><div class="line"><span class="meta">#</span><span class="bash">设置SUID权限，这样普通用户可以使用root的身份来执行这个命令</span></div><div class="line">chmod u+s filename</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">which</span>用于从系统的PATH变量所定义的目录中查找可执行文件的绝对路径</span></div><div class="line">which filename</div><div class="line"><span class="meta">#</span><span class="bash">whereis用于从系统的PATH变量所定义的目录中查找二进制文件和man文件</span></div><div class="line">whereis filename</div><div class="line"><span class="meta">#</span><span class="bash">指定解压后的位置</span></div><div class="line">tar -zxvf boot.tgz -C /tmp</div></pre></td></tr></table></figure>
<p><strong>find命令</strong></p>
<p><img src="find.png" alt="1565195424826"></p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包括</p>
<ol>
<li>超级块：文件系统的总体信息，是文件系统的核心，有多个超级块，以防止由于磁盘出现坏块导致全部文件系统无法使用</li>
<li>inode：存储所有与文件有关的元数据，也就是文件所有者，权限等属性数据以及指向的数据块</li>
<li>数据块：真实存放文件数据的部分</li>
<li>目录块：包括文件名和文件在目录中的位置，并包括文件的inode信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">进行磁盘划分</span></div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span><span class="bash">格式化磁盘,</span></div><div class="line">mkfs -t ext3 /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">将DEVICE挂载到DEVICE_POINT上</span></div><div class="line">mount DEVICE DEVICE_POINT</div><div class="line">mount /dev/sdb1 newDirectory</div><div class="line"><span class="meta">#</span><span class="bash">查看可用空间</span></div><div class="line">df -h | grep sdb1</div><div class="line"><span class="meta">#</span><span class="bash">设置启动自动挂载/etc/fstab</span></div><div class="line">echo "/dev/sdb1 /root/newDisk ext3 default 0 0" &gt;&gt; /etc/fstab</div><div class="line"><span class="meta">#</span><span class="bash">检查修复磁盘出现逻辑错误，要保证磁盘为未挂载的状态</span></div><div class="line">fsck -t ext4 /dev/sda8</div><div class="line"><span class="meta">#</span><span class="bash">卸载磁盘</span></div><div class="line">unmount /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">检查磁盘的物理坏道</span></div><div class="line">badblocks -v /dev/sdb1</div></pre></td></tr></table></figure>
<p>将一块磁盘挂载到操作系统的步骤：先对磁盘进行划分，将磁盘格式化，刷进去文件系统，然后将磁盘挂载到操作系统中，然后将挂载操作设置为开机自启动</p>
<h3 id="逻辑卷（Logic-Volume-Manager）"><a href="#逻辑卷（Logic-Volume-Manager）" class="headerlink" title="逻辑卷（Logic Volume Manager）"></a>逻辑卷（Logic Volume Manager）</h3><p><strong>LVM</strong>是介于硬盘裸设备和文件系统的中间层</p>
<ol>
<li><strong>物理卷（Physical Volumn,PV)</strong>：物理磁盘分区，比如/dev/sdb1</li>
<li><strong>卷组（Volumn Group,VG)</strong>:PV的集合</li>
<li><strong>逻辑卷（Logic Volume,LV)</strong>:PV中划出来的一块逻辑磁盘</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">创建物理卷pvcreate,pvdisplay</span></div><div class="line">fdisk -l</div><div class="line">fdisk /dev/sdb  n</div><div class="line"><span class="meta">#</span><span class="bash">设置物理卷的Id为8e</span></div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span><span class="bash">现在已经有磁盘，从磁盘创建出物理卷</span></div><div class="line">pvcreate /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">将逻辑卷组成一个物理卷组</span></div><div class="line">vgcreate First_LV /dev/sdb1 /dev/sdb2</div><div class="line"><span class="meta">#</span><span class="bash">扩展物理卷组，加入一个新的物理卷</span></div><div class="line">pvextend First_LV /dev/sdb3</div><div class="line"><span class="meta">#</span><span class="bash">创建逻辑卷lvcreate</span></div><div class="line">lvcreate -L 100M -n sdb First_VG</div><div class="line"><span class="meta">#</span><span class="bash">创建文件系统</span></div><div class="line">mkfs -t ext4 /dev/First_LV/First_VG</div><div class="line"><span class="meta">#</span><span class="bash">进行挂载</span></div><div class="line">mount /dev/First_LV/First_VG /root/cxy</div></pre></td></tr></table></figure>
<p><img src="修改分区代码.png" alt="1565714641249"></p>
<h3 id="硬链接和软连接"><a href="#硬链接和软连接" class="headerlink" title="硬链接和软连接"></a>硬链接和软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看文件的说明</span></div><div class="line">ls -li</div><div class="line"><span class="meta">#</span><span class="bash">创建硬链接</span></div><div class="line">ln file.txt file.hard_txt</div><div class="line"><span class="meta">#</span><span class="bash">创建软连接</span></div><div class="line">ln -s file.txt file.soft_txt</div></pre></td></tr></table></figure>
<p><img src="硬链接.png" alt="1565885043739"></p>
<p>该详细信息中的第三列中的<strong>2</strong>的意思为源文件的关联个数，也就是该文件所包含的硬链接的个数</p>
<p><strong>硬链接</strong>:通过索引节点来链接，一个文件可以有多个文件名，多个文件名指向同一个inode是可以的</p>
<p><strong>软连接</strong>：是一个包含了另外一个文件路径名的文件，可以指向任意文件或者目录，可以跨不同的文件系统</p>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><p>固定大小的缓存，缓存的大小为4KByte。符号为”|”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/init.d | more</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">grep [-ivnc] <span class="string">'需要匹配的字符'</span> 文件名</span></div><div class="line"><span class="meta">#</span><span class="bash">-i不区分大小写</span></div><div class="line"><span class="meta">#</span><span class="bash">-v反向查找</span></div><div class="line"><span class="meta">#</span><span class="bash">-n查找并获取行号</span></div><div class="line"><span class="meta">#</span><span class="bash">-c统计需要匹配的字符的个数</span></div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">sort [-ntkr] 文件名</span></div><div class="line"><span class="meta">#</span><span class="bash">-n按照数字来排列，而不是按照字符，默认是按照字符</span></div><div class="line"><span class="meta">#</span><span class="bash">-t指定分隔符grep -t <span class="string">":"</span> -k 2 file.txt</span></div><div class="line"><span class="meta">#</span><span class="bash">-k指定是按照第几列来排序</span></div><div class="line"><span class="meta">#</span><span class="bash">-r反向排序</span></div><div class="line">grep -t ":" -k 2 file.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">uniq [-ic]</span></div><div class="line"><span class="meta">#</span><span class="bash">-i忽略大小写</span></div><div class="line"><span class="meta">#</span><span class="bash">-c统计不同字符的个数</span></div><div class="line">cat file.txt | sort | uniq -c</div></pre></td></tr></table></figure>
<p>使用uniq一般情况下都是跟sort进行使用，因为uniq只会比较跟相邻位置的字符是否相同</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">cut -f指定的列 -d <span class="string">'分隔符'</span></span></div><div class="line"><span class="meta">#</span><span class="bash">查看file.txt文件，以:为分隔符，获取第1，6和7列</span></div><div class="line">cat file.txt | cut -f1,6-7 -d ':'</div><div class="line"><span class="meta">#</span><span class="bash">查看file.txt文件，获取第1-5个字符和第7-10个字符</span></div><div class="line">cat file.txt | cut -c1-5,7-10</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">tr命令使用</span></div><div class="line"><span class="meta">#</span><span class="bash">小写转为大小</span></div><div class="line">cat file.txt | tr '[a-z]' '[A-Z]'</div><div class="line"><span class="meta">#</span><span class="bash">删除字符:</span></div><div class="line">cat file.txt | tr -d ':'</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">paste合并文件</span></div><div class="line"><span class="meta">#</span><span class="bash">将1.txt和2.txt文件按照行进行合并，中间用tab分割</span></div><div class="line">paste 1.txt 2.txt</div><div class="line">paste 1.txt 2.txt -d :</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">split分割文件</span></div><div class="line"><span class="meta">#</span><span class="bash">以500行为一个文件进行分割</span></div><div class="line">split -l 500 big.txt small_file_</div><div class="line"><span class="meta">#</span><span class="bash">以大小进行划分</span></div><div class="line">split -b 64M big.bin small_file_</div></pre></td></tr></table></figure>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看和设置网络网卡</span></div><div class="line">ifconfig</div><div class="line"><span class="meta">#</span><span class="bash">启停网卡</span></div><div class="line">ifup eth0</div><div class="line">ifdown eth0</div><div class="line">ifconfig eth0 down</div><div class="line">ifconfig eth0 up</div><div class="line"><span class="meta">#</span><span class="bash">重启网络服务</span></div><div class="line">service network restart</div><div class="line"><span class="meta">#</span><span class="bash">查看系统当前的路由</span></div><div class="line">route -n</div><div class="line"><span class="meta">#</span><span class="bash">traceroute查看请求所经过的路由器的路径</span></div><div class="line">traceroute 14.215.177.38</div></pre></td></tr></table></figure>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">ps </span></div><div class="line"><span class="meta">#</span><span class="bash">-A 列出所有的进程</span></div><div class="line"><span class="meta">#</span><span class="bash">-a 列出不和本终端有关的所有进程</span></div><div class="line"><span class="meta">#</span><span class="bash">-aux显示所有其他包含其他使用者的进程</span></div><div class="line"><span class="meta">#</span><span class="bash">RSS 显示进程占用的内存的大小</span></div><div class="line"><span class="meta">#</span><span class="bash">VSZ 显示进程占用的虚拟内存的大小</span></div><div class="line"><span class="meta">#</span><span class="bash">查看进程号</span></div><div class="line">pidof Nemgr</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">kill</span></span></div><div class="line">kill -9 1001#强制停止进程，并没有释放内存</div><div class="line">kill -15 1001#使进程正常退出</div><div class="line"><span class="meta">#</span><span class="bash">lsof 查看进程打开的文件</span></div><div class="line">lsof -p pid</div><div class="line">lsof -i:22</div><div class="line"><span class="meta">#</span><span class="bash">nice，renice修改进程的优先级</span></div><div class="line">nice -n -10 ./run.sh</div><div class="line">renice -10 -p pid</div></pre></td></tr></table></figure>
<p><img src="top.png" alt="1566142036437"></p>
<p><img src="top1.png" alt="1566142284292"></p>
<h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><p><img src="/rpm.png" alt="1566144649678"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">rpm安装软件</span></div><div class="line">rpm -ivh packege.rpm</div><div class="line"><span class="meta">#</span><span class="bash">安装软件包，并重新定义安装路径</span></div><div class="line">rpm -ivh --relocate /=/usr/local/package_name package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">升级软件包</span></div><div class="line">rpm -Uvh package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">删除软件</span></div><div class="line">rpm -e package_name --nodeps</div><div class="line"><span class="meta">#</span><span class="bash">查看系统中所有已经安装的包</span></div><div class="line">rpm -qa</div><div class="line"><span class="meta">#</span><span class="bash">查看某个包的依赖关系</span></div><div class="line">rpm -qpR package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">yum安装操作</span></div><div class="line">yum install package</div><div class="line"><span class="meta">#</span><span class="bash">更新系统中所有需要更新的包</span></div><div class="line">yum update</div><div class="line"><span class="meta">#</span><span class="bash">查找操作</span></div><div class="line">yum list</div><div class="line">yum list installed</div><div class="line">yum info package</div><div class="line"><span class="meta">#</span><span class="bash">删除操作</span></div><div class="line">yum remove package</div><div class="line"><span class="meta">#</span><span class="bash">清除操作</span></div><div class="line">yum clean</div><div class="line">yum clean all &amp;&amp; yum makecache</div></pre></td></tr></table></figure>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shift+$</td>
<td>到当前行的末尾</td>
</tr>
<tr>
<td>u</td>
<td>撤销操作</td>
</tr>
<tr>
<td>:n</td>
<td>跳转到第n行</td>
</tr>
<tr>
<td>p</td>
<td>黏贴</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做操作</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
</tbody>
</table>
<p><img src="替换用法.png" alt="1566146582848"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li>“.”：除换行符之外的任意一个字符</li>
<li>*:用来匹配前一个字符0次或者任意多次，.*用来匹配任意长度的不包含换行的字符</li>
<li>{n,m}:重复匹配前一个字符n-m次</li>
<li>^或$:开始和结束的标识</li>
<li>[]:用来匹配方括号内出现的任一个字符</li>
<li>\：转义字符</li>
<li>\&lt;和\&gt;:用于界定单词的左边界和右边界，比如\bhelloy用来匹配以hello开头的单词</li>
<li>\d:用来匹配数字</li>
<li>\b:匹配单词的边界</li>
<li>\B:匹配非单词的边界</li>
<li>\w:匹配数字，字母和下划线，”\W”：\w的取反</li>
<li>\s:匹配任何空白字符，”\S”：匹配任何非空白字符</li>
</ol>
<p><strong>通配符</strong>：</p>
<ol>
<li>?:用来匹配一个字符</li>
<li>{}:用来匹配所有括号内包含的以逗号隔开的字符</li>
<li>^或者!:用来取反</li>
</ol>
<p><strong>POSIX字符</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">[:alnum:]	文本数字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:alpha:]	文字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:digit:]	数字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:graph:]	非空字符（非空格，控制字符）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:lower:]	小写字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:ctrl:]	控制字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:<span class="built_in">print</span>:]	非空字符（包括空格）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:punct:]	标点符号</span></div><div class="line"><span class="meta">#</span><span class="bash">[:space:]	所有空白字符（新行，空行，制表符）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:upper:]	大写字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:xdigit:]	十六进制数字（0-9,a<span class="_">-f</span>,A-F）</span></div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo "helloworld" | grep "hello\B"#helloworld</div><div class="line">echo "helloworld" | grep "hello\b"#返回空值</div><div class="line">^0[0-9]\&#123;2,3\&#125;( |-)[0-9]\&#123;8\&#125; = ^0[0-9]\&#123;2,3\&#125;[\ \-][0-9]\&#123;8\&#125;#这两种是等价的</div><div class="line">grep -ivc "good" a.log#查找不包含good的行数</div><div class="line">grep -c '^$' a.log#匹配空行</div></pre></td></tr></table></figure>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed<strong>是对于每行进行处理的</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">语句1等价与语句2</span></div><div class="line">sed -e 's/hello/HELLO/g;s/abc/ABC/g' a.txt</div><div class="line">sed -e 's/hello/HELLO/g' -e "s/abc/ABC/g" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">在原文件中删除最后一行</span></div><div class="line">sed -i "$d" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">删除所有的空行</span></div><div class="line">sed "/^$/d" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">将每一行以this开头的this替换成that</span></div><div class="line">sed 's/^this/that/' a.log</div><div class="line"><span class="meta">#</span><span class="bash">将每一行的1，2,3转换成A,B,C</span></div><div class="line">sed 'y/123/ABC' a.log</div><div class="line"><span class="meta">#</span><span class="bash">使用i的话，在第2行的上一行插入Insert，第2行插入后变成第3行</span></div><div class="line"><span class="meta">#</span><span class="bash">使用a的话，在第2行的后一行插入Insert，也就是在第三行新增一行插入Insert</span></div><div class="line">sed "2 i Insert" a.log</div><div class="line"><span class="meta">#</span><span class="bash">在空行的后面加上另外一个文件的内容</span></div><div class="line">sed '/^$/r /etc/passwd' Sed.txt</div><div class="line"><span class="meta">#</span><span class="bash">打印实际处理的行</span></div><div class="line">sed -n 's/the/THE/p' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">将sed的结果重定向到output文件中</span></div><div class="line">sed -n '1,2 w output' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">指定需要做的操作</span></div><div class="line">sed -f Sed.rules a.txt</div></pre></td></tr></table></figure>
<p><img src="sed1.png" alt="1566406358092"></p>
<p><img src="sed2.png" alt="1566406376244"></p>
<p><img src="sed3.png" alt="1566406401384"></p>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>作用：是对每一列进行处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk -F . '&#123;print $1,$2&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取每一列的列数</span></div><div class="line">awk -F . '&#123;print NF&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取倒数第二列的值</span></div><div class="line">awk -F . '&#123;print $(NF-1)&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取第一列的第6个字符到最后</span></div><div class="line">awk -F . '&#123;print substr($1,6)&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取每一列的长度</span></div><div class="line">awk '&#123;print length&#125;' a.txt</div></pre></td></tr></table></figure>
<h2 id="shell编程概述"><a href="#shell编程概述" class="headerlink" title="shell编程概述"></a>shell编程概述</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">type cd #判断命令是不是内置命令</div><div class="line">alias myShutdown='shutdown -h now'#设置命令的别名</div><div class="line">unalias myShutdown #取消别名</div><div class="line">jobs #查看暂停的任务</div><div class="line">bg 1 #将任务放在后台运行</div><div class="line">fg 1 #将任务放在前台运行</div><div class="line">declare -i num=1 #定义变量num的类型为整形</div><div class="line">declare -r readonly=1 #定义变量readonly为只读</div><div class="line">declare -a arr='&#123;([0]='a' [1]='b' [2]='c''')&#125;' #定义变量</div><div class="line">declare -F #显示脚本定义的函数</div><div class="line">declare -f #显示脚本定义的函数体</div><div class="line">break n #跳出n层循环</div><div class="line">continue n #continue2层循环</div><div class="line">eval $cmd #将所跟的参数作为shell的输入，并执行产生的命令</div><div class="line">find ./ -name *.sh -exec ls -l &#123;&#125; \;</div><div class="line">export value=1 #当前shell和子shell能够获取得到变量</div><div class="line">pwd -P #显示真实路径，而不是软连接命令</div><div class="line">local #局部变量，只能够在函数内声明和使用</div><div class="line">read n #从控制台获取变量</div><div class="line">ulimit -n 4094 #设置打开的文件的最大个数</div><div class="line">cat /etc/security/limits.conf #设置打开文件的最大个数等限制</div></pre></td></tr></table></figure>
<p><img src="输入参数1.png" alt="1566578135477"></p>
<p><img src="输入参数2.png" alt="1566578169261"></p>
<h2 id="shell基础编程"><a href="#shell基础编程" class="headerlink" title="shell基础编程"></a>shell基础编程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">echo $EUID #获取用户的UID</div><div class="line">echo $FUNCNAME #获取函数的名字</div><div class="line">echo $HISTFILE #获取输入历史记录中的文件</div><div class="line">echo $HISTFILESIZE #存储历史记录的文件的最大条数</div><div class="line">echo $HOSTNAME #主机的名字</div><div class="line">echo $HOSTTYPE #显示是x86还是ARM</div><div class="line">echo $MACHTYPE #显示主机的GNU标识</div><div class="line">echo $LANG #显示当前环境的语言环境</div><div class="line">echo $PWD #显示当前路径</div><div class="line">echo $OLDPWD #显示上一个路径</div><div class="line">echo $PATH #显示环境变量</div></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unset name #取消变量</div><div class="line"><span class="meta">$</span><span class="bash">@  $* <span class="comment">#位置参数 </span></span></div><div class="line">declare -a Array;#声明索引数组</div><div class="line">echo $&#123;#Array[@]&#125; #获取索引元素的长度</div><div class="line">Conn=($&#123;Array[@]&#125; $&#123;Array[@]&#125;) #连接数组</div><div class="line">Conn=($&#123;Array[@]/helloworld/helloworld2&#125;) #将数组中的元素中有helloworld替换成helloworld2</div><div class="line">unset Conn[1] #取消数组中第1个元素</div><div class="line">readonly RO=100 #只读变量，不能够修改</div></pre></td></tr></table></figure>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><strong>部分引用</strong>：双引号，在双引号里面，$，反引号，转义符这3中特殊字符依然会被解析成特殊意义</li>
<li><strong>全引用</strong>：单引号中的任何字符都是作为普通字符</li>
<li><strong>命令替换</strong>：将命令的标准输出作为值赋给某个变量。反引号等价于$()</li>
</ol>
<p>$[]和$(())类似，可用于简单的算术运算。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo $[1+1] #输出2</div><div class="line">expr 2 \* 2 #输出4</div><div class="line">declare -i J #声明整数</div></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ol>
<li>*:任意长度的字符串，不包含点号和斜线号</li>
<li>?:匹配单个字符</li>
<li>[]:匹配其中的任意一个字符。*和？在[]中则变成了普通字符，没有通配的功效</li>
</ol>
<p><img src="变量扩展.png" alt="1566838063691"></p>
<p><img src="位置参数.png" alt="1566838175259"></p>
<h2 id="测试和判断"><a href="#测试和判断" class="headerlink" title="测试和判断"></a>测试和判断</h2><p>测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">判断文件是否存在</span></div><div class="line">if [ ! -e filename ]; then</div><div class="line">	echo "the $filename is not exists"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">判断字符串是否相等</span></div><div class="line">if [ "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "the $str1 is big"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">判断数字是否相等</span></div><div class="line">if [ "$num1" -lt "$num2" ]; then</div><div class="line">	echo "the $num1 is small"</div><div class="line">fi</div><div class="line">if [ "$num1" -lt "$num2"] &amp;&amp; [ "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "right"</div><div class="line">fi</div><div class="line">if [ "$num1" -lt "$num2" -a "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "right"</div><div class="line">fi</div><div class="line">if [ -e $filename ]; then</div><div class="line">	echo "$filename is exists"</div><div class="line">else</div><div class="line">	echo "$filename is not exists"</div><div class="line">fi</div><div class="line">if [ "$num1" \&lt; 60 ]; then</div><div class="line">	echo "不及格"</div><div class="line">elif [ "$num1" \&lt; 80 ]; then</div><div class="line">	echo "良好"</div><div class="line">else</div><div class="line">	echo "优秀"</div><div class="line">fi</div><div class="line">OS=`uname -s`</div><div class="line">case "$OS" in </div><div class="line">FreeBSD) echo "This is FreeBSD"</div><div class="line">*) echo "This is linux"</div><div class="line">esac</div><div class="line"><span class="meta">#</span><span class="bash">输入值</span></div><div class="line">read -p "input " input</div></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">计算1-100的和</span></div><div class="line">declare -i num</div><div class="line">for i in `seq 1 100`</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 2 100) 计算奇数的和</span></div><div class="line">do</div><div class="line">	sum+=i</div><div class="line">done</div><div class="line">echo sum</div><div class="line"><span class="meta">#</span><span class="bash">遍历输入参数</span></div><div class="line">for VARIABLE in $@</div><div class="line">do</div><div class="line">	echo "$VARIABLE"</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash">计算1-100</span></div><div class="line">declare -i result</div><div class="line">for ((i=1;i&lt;=100;i++))</div><div class="line">do</div><div class="line">	result+=i</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>循环</span></div><div class="line">sum01=0</div><div class="line">sum02=0</div><div class="line">i=1</div><div class="line">j=1</div><div class="line">while [[ $i -le 100 ]]</div><div class="line">do</div><div class="line">	let "sum01+=i"</div><div class="line">	let "j=i%2"</div><div class="line">	if [ "$j" -ne 0 ]; then</div><div class="line">		let "sum02+=i"</div><div class="line">	fi</div><div class="line">	let "i++"</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>例子</span></div><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></div><div class="line">while read LINE</div><div class="line">do</div><div class="line">	NAME=`echo $LINE|awk '&#123;print $1&#125;'`</div><div class="line">	echo "$NAME"</div><div class="line">done &lt; student_info.txt</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash">!/bin/bash</span></div><div class="line">cat student_info.txt | while read LINE</div><div class="line">do</div><div class="line">	NAME=`echo $LINE|awk '&#123;print $1&#125;'`</div><div class="line">	echo "$NAME"</div><div class="line">done </div><div class="line"><span class="meta">#</span><span class="bash">until</span></div><div class="line">until [[ $i -gt 100 ]]</div><div class="line">do</div><div class="line">	echo -n $i #不换行</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">break</span>和<span class="built_in">continue</span></span></div><div class="line">continue n #继续嵌套循环的嵌套数</div><div class="line">continue #继续当前循环</div></pre></td></tr></table></figure>
<p><img src="select.png" alt="1566924776979"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">返回值</span></div><div class="line">function func1()&#123;</div><div class="line">do</div><div class="line">	if [ -f $1 ]; then</div><div class="line">		return 0</div><div class="line">	else</div><div class="line">		return 1</div><div class="line">	fi</div><div class="line">done</div><div class="line">&#125;</div><div class="line">func1</div><div class="line">if [ $? -eq 0 ]; then</div><div class="line">	echo "the file $1 is exists"</div><div class="line">else</div><div class="line">	echo "the file $1 is not exists"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">有输入值和<span class="built_in">shift</span>(列表每次推移1个元素)<span class="built_in">shift</span> 2(列表每次推移2个元素)</span></div><div class="line">function func2()&#123;</div><div class="line">until [ $# -eq 0 ]</div><div class="line">do</div><div class="line">	echo "the parameter \$1 is $1,the parameter size is $#"</div><div class="line">	shift</div><div class="line">done</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span><span class="bash">递归函数</span></div><div class="line">function factorial01()&#123;</div><div class="line">	local NUMBER=$1</div><div class="line">	if [ $NUMBER -le 0 ]; then</div><div class="line">		RES=1</div><div class="line">	else</div><div class="line">		factorial01 $((NUMBER-1))</div><div class="line">		TEMP=$RES</div><div class="line">		NUMBER=$NUMBER</div><div class="line">		RES=$((TEMP*NUMBER))</div><div class="line">	fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><img src="重定向.png" alt="1567096570598"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/passwd 2&gt;error.txt 1&gt;right.txt</div><div class="line"><span class="meta">#</span><span class="bash">标识重定向</span></div><div class="line">ls -l /etc/passwd &gt; stdout.txt 2&gt;&amp;1</div><div class="line">ls -l /etc/ &gt; stdout.txt 2&gt;/dev/null</div></pre></td></tr></table></figure>
<h3 id="使用exec"><a href="#使用exec" class="headerlink" title="使用exec"></a>使用exec</h3><p><img src="exec.png" alt="1567097045597"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">指定文件标识符</span></div><div class="line">exec 3&lt;fruit01.txt</div><div class="line">sort &lt;&amp;3</div><div class="line"><span class="meta">#</span><span class="bash">关闭文件标识符</span></div><div class="line">exec 3&lt;&amp;-</div><div class="line"><span class="meta">#</span><span class="bash">将<span class="built_in">exec</span>的输出重定向到终端中</span></div><div class="line">exec &gt;/dev/tty</div><div class="line"><span class="meta">#</span><span class="bash">&lt;&lt; END当输入END的时候，输入结束，这里是区分大小写的</span></div><div class="line">sort &lt;&lt; END</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;linux用户管理&quot;&gt;&lt;a href=&quot;#linux用户管理&quot; class=&quot;headerlink&quot; title=&quot;linux用户管理&quot;&gt;&lt;/a&gt;linux用户管理&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++PrimePlus第9章</title>
    <link href="https://caixueyuan.github.io/2019/08/04/C-PrimePlus%E7%AC%AC10%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/08/04/C-PrimePlus第10章/</id>
    <published>2019-08-04T03:29:08.000Z</published>
    <updated>2019-08-08T15:22:27.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><h3 id="include的使用"><a href="#include的使用" class="headerlink" title="#include的使用"></a>#include的使用</h3><ol>
<li><p><code>#include&lt;iostream&gt;</code>如果文件包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找</p>
</li>
<li><p><code>#include&quot;stdio.h&quot;</code> 如果文件是包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录，如果没有的话，则在标准位置中查找</p>
</li>
<li><p>在编码的过程中，不要使用#include一个CPP代码，会导致多重定义</p>
</li>
<li><p>尽量使用这种方式来定义头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> CORRORDIN_H_</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h3><p><strong>概念</strong>：</p>
<ol>
<li>定义是有分配存储空间的，只能够定义一次<code>int a;</code></li>
<li>声明是引用声明，不用给变量分配存储空间，可以多次被引用<code>a=1;</code></li>
</ol>
<h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>主要分为两种：</p>
<ol>
<li>外部链接性：不只是当前文件可以使用，其他别的文件也可以引用声明到</li>
<li>内部链接性：一般都是静态变量，只能够在当前文件中使用，其他别的文件不能够引用声明到</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> external = <span class="number">10</span>;<span class="comment">//外部链接性，在当前文件中定义，其他文件如果要使用该变量，必须加上extern int external;进行引用声明</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> inside = <span class="number">11</span>;<span class="comment">//内部链接性，因为是内部链接性，只在当前的文件中起作用，不用担心跟其他文件的全局变量冲突</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count;<span class="comment">//局部变量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count1;<span class="comment">//作用域还是在该代码块中，但是呢，每次运行该代码块该变量都会一致存在，跟全局变量没啥子区别，就是声明作用域小了一些</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_number=<span class="number">0</span>;<span class="comment">//内部链接性，由const定义的变量都不是外部链接性</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_number1=<span class="number">10</span>;<span class="comment">//如果想使用外部链接性的const变量的话，就要加上extern进行定义。但是呢，一般情况下，如果想使用外部链接性的const变量，可以将变量定义在头文件中，然后使用#include"header.h"将变量加入到该文件中比较好</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//函数默认是外部链接性，其他文件默认就可以引用到</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//static修饰的函数为内部链接性，只能够在本文件中使用</span></div></pre></td></tr></table></figure>
<h3 id="语句链接性："><a href="#语句链接性：" class="headerlink" title="语句链接性："></a>语句链接性：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C语句获取函数描述符号去查找函数</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C++语句获取函数描述符号去查找函数</span></div></pre></td></tr></table></figure>
<h3 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//这种是using编译指令</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//使用using声明</span></div><div class="line"><span class="keyword">namespace</span> MEF= <span class="built_in">std</span>;<span class="comment">//有些时候可以使用名称空间别名的方式来缩短名称空间</span></div></pre></td></tr></table></figure>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p><strong>const和mutable</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></div><div class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;<span class="comment">//可以修改，不受const的限制</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">"abc"</span>,<span class="number">1</span>&#125;;</div><div class="line">veep.name = <span class="string">""</span>;<span class="comment">//错误，不能够修改</span></div><div class="line">veep.accesses = <span class="number">1</span>;<span class="comment">//可以修改</span></div></pre></td></tr></table></figure>
<p><strong>函数搜索顺序</strong>：</p>
<p>首先是本文件，然后才是程序员编写的其他的文件，然后再是库函数。所以有些时候可以使用覆盖的方式来覆盖库函数来实现比库函数更多的功能。</p>
<p><strong>const函数</strong>：</p>
<p>void stock::show() const一般在不修改类的成员变量的时候都要将函数声明为const，这样可以起到保护类的成员变量的作用</p>
<h2 id="类的声明和使用"><a href="#类的声明和使用" class="headerlink" title="类的声明和使用"></a>类的声明和使用</h2><h3 id="作用域为类的常量的方法"><a href="#作用域为类的常量的方法" class="headerlink" title="作用域为类的常量的方法"></a>作用域为类的常量的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是错误的，因为声明只是描述对象形式，并没有创建对象，所以在创建对象之前，并没有用于存储对象的空间，而const int Months = 12;在运行的时候就需要空间进行存储空间，所以这种的对象声明是错误</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span>&#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用这种方法声明枚举的时候并不会创建类数据成员，所有对象都不包含枚举，Months只是一个符号名称，在声明的时候不需要空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该变量将于其他静态静态变量一样，在运行的时候存放在文件中</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>A = B <em> 1.0;//可以使用成员函数来调用 `A = B.operator</em>(1.0)`</p>
<p>A = 1.0 * B;//由于1在前面，不能够使用成员函数的方式来实现，所以只能够使用非成员函数的方式来使用<code>A = operator&lt;&lt;(1.0,B)</code></p>
<p><strong>友元函数的好处</strong>：本身不是成员函数，而是一个普通函数，不属于类，而又能够跟成员函数一样访问类的内部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MyTime.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> hours;</div><div class="line">    <span class="keyword">int</span> minutes;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Time();</div><div class="line">    Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m = <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</div><div class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)</div><div class="line">        &#123; <span class="keyword">return</span> t * m; &#125;   <span class="comment">// inline definition</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//MyTime.cpp</span></div><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">" minutes"</span>;</div><div class="line">    <span class="keyword">return</span> os; </div><div class="line">&#125;<span class="comment">//返回一个引用，重载运算符，第一个参数不是该成员</span></div></pre></td></tr></table></figure>
<h3 id="隐形转换和显性转换"><a href="#隐形转换和显性转换" class="headerlink" title="隐形转换和显性转换"></a>隐形转换和显性转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONEWT_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STONEWT_H_</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stonewt</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span> &#123;Lbs_per_stn = <span class="number">14</span>&#125;;      <span class="comment">// pounds per stone</span></div><div class="line">    <span class="keyword">int</span> stone;                    <span class="comment">// whole stones</span></div><div class="line">    <span class="keyword">double</span> pds_left;              <span class="comment">// fractional pounds</span></div><div class="line">    <span class="keyword">double</span> pounds;                <span class="comment">// entire weight in pounds</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Stonewt(<span class="keyword">double</span> lbs);          <span class="comment">// constructor for double pounds</span></div><div class="line">    Stonewt(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs); <span class="comment">// constructor for stone, lbs</span></div><div class="line">    Stonewt();                    <span class="comment">// default constructor</span></div><div class="line">    ~Stonewt();</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in pounds format</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in stone format</span></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">Stonewt myCat;</div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//OK，类的隐形转换</span></div><div class="line"><span class="comment">//如果使用explicit来禁止隐形转换的话，也就是用explicit Stonewt(double lbs);的话</span></div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//错误，因为禁止了隐形转换</span></div><div class="line">myCat = (Stonewt) <span class="number">19.6</span>;<span class="comment">//OK,因为是显性转换</span></div></pre></td></tr></table></figure>
<p><strong>转换函数</strong>：就是将之前的Stonewt转换为double类型等。如<code>operator int() const</code>或者<code>operator double() const</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</div><div class="line"><span class="keyword">double</span> host = <span class="keyword">double</span>(wolfe);<span class="comment">//将wolfe转换为double类型</span></div><div class="line"><span class="keyword">double</span> host = wolfe;<span class="comment">//显性</span></div><div class="line"><span class="keyword">double</span> host = (<span class="keyword">double</span>) wolfe;<span class="comment">//显性</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：最好少用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存模型和名称空间&quot;&gt;&lt;a href=&quot;#内存模型和名称空间&quot; class=&quot;headerlink&quot; title=&quot;内存模型和名称空间&quot;&gt;&lt;/a&gt;内存模型和名称空间&lt;/h2&gt;&lt;h3 id=&quot;include的使用&quot;&gt;&lt;a href=&quot;#include的使用&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime Plus第9章</title>
    <link href="https://caixueyuan.github.io/2019/07/31/C-Prime-Plus%E7%AC%AC9%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/31/C-Prime-Plus第9章/</id>
    <published>2019-07-30T16:02:06.000Z</published>
    <updated>2019-07-30T16:25:28.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>重载</strong>：</p>
<ol>
<li>重载不区分const和非const变量</li>
<li>重载不区分引用和非引用</li>
<li>重载不区分返回值</li>
</ol>
<p><strong>模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>;<span class="comment">//常规模板</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job&amp; a,job&amp; b);<span class="comment">//具体化</span></div></pre></td></tr></table></figure>
<p>具体函数优于具体化，优于常规模板</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重载不区分const和非const变量&lt;/li&gt;
&lt;li&gt;重载不区分引用
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C语句编译与链接</title>
    <link href="https://caixueyuan.github.io/2019/07/25/C%E8%AF%AD%E5%8F%A5%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>https://caixueyuan.github.io/2019/07/25/C语句编译与链接/</id>
    <published>2019-07-25T15:17:34.000Z</published>
    <updated>2019-07-30T16:01:06.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="运行库.png" alt="1564068683784"></p>
<p><strong>操作系统应用程序编程接口</strong>：应用程序的接口的提供者是运行库（Runtime Library），运行库使用操作系统提供的系统调用接口。</p>
<p><strong>直接使用物理内存的坏处</strong>：</p>
<ol>
<li>地址空间不连续</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p><strong>使用虚拟地址</strong>：</p>
<p><img src="虚拟地址.png" alt="1564069609677"></p>
<p>程序只能够访问到虚拟地址，不感知物理地址，一个程序可以分为好多段，好多页，页分为虚拟页，物理页和磁盘页。程序访问的是虚拟地址，如果虚拟地址映射的物理页不在物理内存中，会出现缺页中断，由操作系统进行接管，来处理缺页中断，所以呢，程序并不感知物理地址。</p>
<p>用户线程和内核线程并不总是一对一，又可能是多对一或者是多对多。</p>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p><img src="编译链接过程.png" alt="1564071456112"></p>
<p>预处理（processing)，编译（Compilation），汇编（Assembled），链接（Linking）</p>
<p><strong>预编译</strong>：</p>
<ol>
<li>展开所有的宏定义”#define”</li>
<li>处理所有条件预编译指令,”#if”,”#ifdef”,”elif”,”#else”,”#endif”</li>
<li>处理”#include”预编译指令，递归地将包含的文件插入到该编译指令的位置</li>
<li>删除所有的注释</li>
<li>添加行号和文件名标识</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E main.c -o main.i</div></pre></td></tr></table></figure>
<p><strong>编译</strong>：</p>
<p>将预编译之后的代码进行编译，得到汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -s main.i -o main.s</div></pre></td></tr></table></figure>
<p><strong>汇编</strong>：</p>
<p>将汇编代码转换为机器指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c main.s -o main.o</div></pre></td></tr></table></figure>
<p><strong>链接</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o -L /usr/lib/gcc/i486-linux-gnu/4.1.3 -L /usr/lib/ -L /lib hello.o --start-group -lgcc -l gcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o /usr/lib/crtn/o</div></pre></td></tr></table></figure>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="编译过程.png" alt="1564147367310"></p>
<ol>
<li><strong>词法</strong>：lex程序，将源代码的字符序列分割成一系列的记号</li>
<li><strong>语法分析</strong>：根据记号进行分析，产生语法树</li>
<li><strong>语义分析</strong>：分为静态语义和动态语义，对语法树中进行标识</li>
<li><strong>中间代码生成</strong>：将语法树转为中间代码。中间代码使得编译器可以被分为前端和后端，前端可以负责产生机器无关的中间代码，后端将中间代码转换为目标机器代码。<strong>三地址码</strong>：就是对于中间代码，操作都是三个地址+一个操作</li>
<li><strong>目标代码生成与优化</strong>：通过代码生成器来生成目标机器代码</li>
</ol>
<h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p><strong>符号</strong>：用来表示一个地址，这个地址可以是一个子程序的起始地址，也可以是变量的起始地址。    </p>
<p>链接的主要内容是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正常链接好，“程序员人工调整地址”，包括地址和空间分配，符号决议和重定位。</p>
<p><strong>静态链接</strong>：每次函数调用都必须确切知道函数的地址，但是由于每个模块都是单独编译的，在编译器编译的时候并不知道函数的地址，所以等到链接的时候由链接器将这些指令的目标地址来修正，得到函数的地址。对于全局变量和定义在其他文件的变量也是一样的道理。</p>
<p><strong>重定位</strong>：给程序中每个引用到其他文件的地址打补丁，让他们引用到正确的绝对地址。、</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>可重定位文件</strong>（relocatable file)：包含代码和数据，可以被用来链接成可执行文件和共享目标文件。包括静态链接文件</li>
<li>可执行文件（executable file）：可执行文件</li>
<li>共享目标文件（Shared Object File）：包含代码和数据，有两个作用：跟可重定位文件生成新的可执行文件，或者可以与可执行文件结合来运行程序</li>
<li>核心转储文件（core dump file):core文件</li>
</ol>
<h3 id="目标文件格式-1"><a href="#目标文件格式-1" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>文件头</strong>:描述整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接以及入口地址，目标硬件和目标操作系统等信息，还包括一个段表，描述我呢见中各个段在文件中的偏移位置及段的属性</li>
<li><strong>text段</strong>：机器代码（在内存都是只读）</li>
<li><strong>data段</strong>：已初始化的全局变量和局部变量</li>
<li><strong>bss段</strong>：未初始化的全局变量和局部静态变量</li>
</ol>
<h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test.c</div><div class="line">objdump -h test.o</div><div class="line">size test.o</div></pre></td></tr></table></figure>
<p><img src="编译目标文件.png" alt="1564155339409"></p>
<p><img src="编译内存段.png" alt="1564155384053"></p>
<ol>
<li><p><strong>代码段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -s -d test.o</div></pre></td></tr></table></figure>
</li>
<li><p><strong>数据段和只读数据段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -x -s -d test.o</div></pre></td></tr></table></figure>
<p>.rodata为只读数据段，存储程序中的只读变量和字符串变量</p>
</li>
<li><p><strong>BSS段</strong></p>
<p>未初始化的变量</p>
</li>
</ol>
<p>其他小技巧：</p>
<p><strong>分析mp3等其他文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o</div><div class="line">objdump -ht image.o</div></pre></td></tr></table></figure>
<p><strong>自定义段</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(<span class="string">"FOO"</span>)))<span class="keyword">int</span> global = <span class="number">42</span>;<span class="comment">//变量将放在FOO段中</span></div></pre></td></tr></table></figure>
<h3 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">readelf -<span class="keyword">h</span> <span class="keyword">test</span>.o<span class="comment">//查看文件头</span></div><div class="line">readelf -S <span class="keyword">test</span>.o<span class="comment">//查看段表</span></div></pre></td></tr></table></figure>
<ol>
<li>.rel.text:重定位表</li>
<li>.shstrtab:字符串表</li>
</ol>
<h3 id="链接的接口：符号"><a href="#链接的接口：符号" class="headerlink" title="链接的接口：符号"></a>链接的接口：符号</h3><p>定义C++宏，只有在C++程序中才能够进行编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">size_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><p><strong>强符号</strong>：默认函数和初始化的全局变量</p>
<p><strong>弱符号</strong>：未初始化的全局变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;<span class="comment">//啥都不是</span></div><div class="line"><span class="keyword">int</span> weak;<span class="comment">//弱符号</span></div><div class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;<span class="comment">//强符号</span></div><div class="line">__attribute__((weak)) weak2=<span class="number">2</span><span class="comment">//弱符号</span></div></pre></td></tr></table></figure>
<p><strong>强引用</strong>：对外部目标文件的符号引用在目标文件被最终链接到可执行文件时，要被正确决议，如果没有找到错误，要报编译错误</p>
<p><strong>弱引用</strong>：如果符号没有被定义不报错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__attribute__((weakref)) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(foo)</div><div class="line">		foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gcc中生成调试段：加上-g</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;运行库.png&quot; alt=&quot;1564068683784&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统应用程
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux,C++" scheme="https://caixueyuan.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++程序概述</title>
    <link href="https://caixueyuan.github.io/2019/07/23/C-%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/23/C-程序概述/</id>
    <published>2019-07-22T16:21:59.000Z</published>
    <updated>2019-07-22T16:41:16.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h2><p><img src="冯诺依曼式" alt="img"></p>
<p>上面为冯诺依曼式计算机</p>
<p>指令执行的过程：</p>
<p>（1） 程序计数器PC将指令的地址发送给地址寄存器AR</p>
<p>（2）地址寄存器到响应的存储单元中将指令取出放入指令寄存器</p>
<p>（3） 指令寄存器将指令交给指令译码器ID进行译码，经过分析这条指令的操作数是一个地址</p>
<p>（4）控制器将指令中的地址传回地址寄存器AR</p>
<p>（6）在控制器的协调下，到相应的存储器中取出数据，将其送到运算器的缓冲寄存器DR</p>
<p>（7）缓冲寄存器将数据送到算数逻辑单元ALU</p>
<p>（8）操作控制器发送一个加一操作的信号给算数逻辑单元ALU</p>
<p>（9）ALU完成运算，并将运算结果放回到累加器中</p>
<p>详情请见：<a href="https://blog.csdn.net/chenkaibsw/article/details/78315931" target="_blank" rel="external">冯诺依曼式计算机</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可执行程序&quot;&gt;&lt;a href=&quot;#可执行程序&quot; class=&quot;headerlink&quot; title=&quot;可执行程序&quot;&gt;&lt;/a&gt;可执行程序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;冯诺依曼式&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面为冯诺依曼式计算机&lt;/p&gt;
&lt;p&gt;指令执行
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="LinuxC++" scheme="https://caixueyuan.github.io/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://caixueyuan.github.io/2019/07/21/C-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/07/21/C-基础/</id>
    <published>2019-07-21T15:17:43.000Z</published>
    <updated>2019-07-23T16:23:39.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p><strong>sizeof</strong>返回的是表达式结果类型的大小，而不是实际对象值的内存的大小</p>
<p><img src="1563722534600.png" alt="1563722534600"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>static_cast:任何具有明确定义的类型转换，主要不包含底层const，都可以使用static_cast.</li>
<li>const_cast:只能改变运算对象的底层const，将const对象转换为非const对象，没办法做类型转换</li>
<li>reinterpret_cast:为运算对象的位模式提供较低层次上的重新解析，不改变内容，只改变了表达的方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span>* pc1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div><div class="line"><span class="keyword">int</span> *ip;</div><div class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);<span class="comment">//实际上pc存储的还是int类型的指针</span></div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="局部静态成员"><a href="#局部静态成员" class="headerlink" title="局部静态成员"></a>局部静态成员</h3><p><strong>局部静态成员</strong>：在程序执行路径第一次经过此对象定义语句的时候初始化，直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对其有影响</p>
<p><img src="1563811767670.png" alt="1563811767670"></p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配</p>
<p><strong>initializer_list</strong>:可变参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//expect和actual是string对象</span></div><div class="line"><span class="keyword">if</span>(expected != actual)</div><div class="line">    error_msg(&#123;<span class="string">"function"</span>,expected,actual&#125;);</div><div class="line"><span class="keyword">else</span></div><div class="line">    error_msg(&#123;<span class="string">"functionX"</span>,<span class="string">"OKAY"</span>&#125;);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(ErrCode e,<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg() &lt;&lt; <span class="string">":"</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem:il)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值</strong>：</h3><ol>
<li>不要返回局部对象的引用和指针。因为如果返回局部对象的引用时，由于函数运行结束之后局部对象会被析构，导致返回值为未知对象。</li>
<li>引用返回左值，返回值可以作为左值，如果返回的是引用的话</li>
</ol>
<p><strong>重载函数</strong>：</p>
<p>C++重载的是不区分顶层，区分底层</p>
<p>C++中名字查找发生在类型检查之前</p>
<p><img src="重载.png" alt="1563897046529"></p>
<p><strong>内联函数</strong>：内联函数只是向编译器发出的一个请求，编译器可以忽略这个请求。通常就是在每个调用点内联展开。</p>
<p><strong>constexpr函数</strong>：函数的返回值以及所有形参的类型都是字面值类型，而且函数体内必须有且只有一条return语句。constexpr为内联函数，不一定返回常量表达式。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>assert预处理宏：是预处理器，而不是编译器检查的。用来检查不可能的情况</p>
<p><strong>NDEBUG预处理变量</strong>：assert的行为依赖于这个预处理变量的状态，如果定义了这个预处理变量，就什么都不做。</p>
<p><img src="预处理1.png" alt="1563898004510"></p>
<p><img src="预处理2.png" alt="1563898033745"></p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool lengthCompare(const string &amp;,const string &amp;);</div><div class="line">bool (*pf)(const string&amp;,const string &amp;);</div><div class="line">pf = lengthCompare;</div><div class="line">pf = &amp;lengthCompare;</div><div class="line">bool b1 = pf("a","b");</div><div class="line">bool b2 = (*pf)("a","b");</div><div class="line"></div><div class="line">//声明函数指针</div><div class="line">int (*f1(int))(int*,int);</div><div class="line">auto f1(int) -&gt; int(*)(int*,int);</div><div class="line"></div><div class="line">//使用decltype简化书写函数返回类型的过程，第三个函数接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。</div><div class="line">string:size_type sumLength(const string&amp; ,const string &amp;);</div><div class="line">string:size_type largeLength(const string&amp;,const string &amp;);</div><div class="line">decltype (sumLength) *getLength(const string &amp;);//*表示返回指针类型</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表达式&quot;&gt;&lt;a href=&quot;#表达式&quot; class=&quot;headerlink&quot; title=&quot;表达式&quot;&gt;&lt;/a&gt;表达式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;sizeof&lt;/strong&gt;返回的是表达式结果类型的大小，而不是实际对象值的内存的大小&lt;/p&gt;
&lt;p&gt;&lt;img s
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime第四章</title>
    <link href="https://caixueyuan.github.io/2019/07/18/C-Prime%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/18/C-Prime第四章/</id>
    <published>2019-07-17T16:08:00.000Z</published>
    <updated>2019-07-17T16:53:22.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><ol>
<li>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</li>
<li>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</li>
</ol>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><ol>
<li><strong>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</strong></li>
<li><strong>变量能且只能够定义一次，而可以被多次声明</strong></li>
</ol>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ol>
<li><strong>引用:</strong>引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</li>
<li><strong>引用必须被初始化</strong></li>
<li><strong>如果想要在多个文件之间共享</strong>const对象，必须在变量的定义之前添加extern关键字。</li>
</ol>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line"></div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>：auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line"></div><div class="line">​    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"></div><div class="line">​    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line"></div><div class="line">​    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr[<span class="number">10</span>];<span class="comment">//10个整形数组的指针</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>] = &amp;ptr;<span class="comment">//一个指针指向有10个元素的数组</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (&amp;ptr)[<span class="number">10</span>] = ptr;<span class="comment">//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<h2 id="C语句风格的数组"><a href="#C语句风格的数组" class="headerlink" title="C语句风格的数组:"></a>C语句风格的数组:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure>
<p>这样可以创建一个数组（将数组转换为vector）</p>
<p><img src="1563380478962.png" alt="1563380478962"></p>
<p>使用别名来代替类型</p>
<p><img src="使用别名来代替类型.png" alt="使用别名来代替类型"></p>
<p>第一行和第二行是等价的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/li&gt;
&lt;li&gt;初始化不是赋值，
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记(变量和基础类型)</title>
    <link href="https://caixueyuan.github.io/2019/07/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/08/C-学习笔记/</id>
    <published>2019-07-08T15:37:50.000Z</published>
    <updated>2019-07-17T15:52:13.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><blockquote>
<p>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</p>
<p>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</p>
</blockquote>
<h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</p>
<p><strong>变量能且只能够定义一次，而可以被多次声明</strong></p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>引用</strong>：引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</p>
<p><strong>引用必须被初始化</strong></p>
<p>如果想要在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>:auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> *<span class="built_in">ptr</span>[<span class="number">10</span>]<span class="comment">;//10个整形数组的指针</span></div><div class="line"><span class="built_in">int</span> (*<span class="built_in">ptr</span>)[<span class="number">10</span>] = &amp;<span class="built_in">ptr</span><span class="comment">;//一个指针指向有10个元素的数组</span></div><div class="line"><span class="built_in">int</span> (&amp;<span class="built_in">ptr</span>)[<span class="number">10</span>] = <span class="built_in">ptr</span><span class="comment">;//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<p><em>C语句风格的数组</em>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/p&gt;
&lt;p&gt;初始化
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++学习笔记" scheme="https://caixueyuan.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>linux设备驱动程序</title>
    <link href="https://caixueyuan.github.io/2019/05/29/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://caixueyuan.github.io/2019/05/29/linux设备驱动程序/</id>
    <published>2019-05-29T15:58:36.000Z</published>
    <updated>2019-06-09T16:11:16.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h2><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E6%80%BB%E7%BA%BF.gif" alt="总线"></p>
<p>两条高速总线用于在内存芯片上来回传送数据：前端总线将CPU连接到RAM控制器上，而后端总线将CPU连接到外部硬件的高速缓存上。</p>
<p>主机上的桥将系统总线和前端总线连接在一起。</p>
<p>任何设备只能够连接到一条总线上。</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/PC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.gif" alt="IO体系结构"></p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E4%B8%93%E7%94%A8IO%E7%AB%AF%E5%8F%A3.gif" alt="专用接口"></p>
<p>I/O端口有两种方式：既可以使用为独立的I/O地址空间，又可以被映射到物理地址空间，这样就可以通过内存来访问I/O端口啦。不过一般情况下，都是作为独立的I/O地址空间。</p>
<p>一般情况下，I/O有四个汇编指令，分别为in、out、ins、outs</p>
<p>对于I/O端口，有特殊的数据结构来对应（resource），主要的作用是唯一性地指定I/O地址空间，让地址不重复</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。在相反方向上，它检测设备状态的变化，并对起状态寄存器作用的I/O端口进行相应的更新。（也就是说将值转换为数据，并监控I/O状态)</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><blockquote>
<ul>
<li><p>对从I/O接口收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作。</p>
</li>
<li><p>对从设备接收到的电信号进行转换和适当的解释，并修改（通过I/O接口）状态寄存器的值。</p>
</li>
</ul>
</blockquote>
<h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs文件系统的目标是展现设备驱动程序模型组件间的层次关系，允许用户态应用程序访问内核内部数据结构的一种文件系统</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.PNG" alt="sysfs文件系统"></p>
<p><code>sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用；sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核的数据结构以及它们的属性</code></p>
<p><img src="https://blog.csdn.net/zqixiao_09/article/details/50864489" alt="详细信息"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O体系结构&quot;&gt;&lt;a href=&quot;#I-O体系结构&quot; class=&quot;headerlink&quot; title=&quot;I/O体系结构&quot;&gt;&lt;/a&gt;I/O体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caixue
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
