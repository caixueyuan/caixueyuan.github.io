<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2020-06-14T16:05:46.761Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://caixueyuan.github.io/2020/06/14/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://caixueyuan.github.io/2020/06/14/Java8新特性/</id>
    <published>2020-06-14T01:14:30.000Z</published>
    <updated>2020-06-14T16:05:46.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过行为参数化传递代码"><a href="#通过行为参数化传递代码" class="headerlink" title="通过行为参数化传递代码"></a>通过行为参数化传递代码</h2><p>作用：软件原则DRY（Don’t repeat yourself,不要重复自己）</p>
<p><strong>概念</strong>：让方法接受多种行为作为参数，并在内部使用，来完成不同的行为。</p>
<p><strong>好处</strong>：行为参数化在于你可以把迭代要筛选的集合的逻辑与对集合中的每个元素应用的行为区分开来，可以重复使用同一个方法，给它不同的行为来达到不同的目的。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda管中窥豹"><a href="#Lambda管中窥豹" class="headerlink" title="Lambda管中窥豹"></a>Lambda管中窥豹</h3><p>它没有名称，但它有参数列表，函数主题，返回类型，可能还会有一个可以抛出的异常列表</p>
<p><strong>匿名</strong>：它不像普通的方法那样有一个明确的名称：写得少而想得多</p>
<p><strong>函数</strong>：不像方法那样属于特定的类。但与方法一样，Lambda有参数列表，函数主体，返回类型，还可能有可以抛出来的异常类型</p>
<p><strong>传递</strong>：Lambda表达式可以作为参数传递给方法或存储在变量中</p>
<p><strong>简洁</strong>：无需像匿名类那样写很多模板代码</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>只有在函数式接口的时候才可以传递Lambda表达式。函数式接口就是只有一个函数的接口。</p>
<h3 id="3-3-环绕处理模式"><a href="#3-3-环绕处理模式" class="headerlink" title="3.3 环绕处理模式"></a>3.3 环绕处理模式</h3><p><strong>概念</strong>：资源处理中打开一个资源，做一些处理，然后关闭资源。这种设置和清理 阶段总是很类似，并且会围绕着执行处理的那些重要代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">proccessFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file)))&#123;</div><div class="line">        <span class="keyword">return</span> br.readLine();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-使用函数式接口"><a href="#3-4-使用函数式接口" class="headerlink" title="3.4 使用函数式接口"></a>3.4 使用函数式接口</h3><p><strong>Predicate</strong>:java.util.function.Predicate<t>接口定义了一个叫做test的抽象方法，它接受泛型T对象，并返回一个Boolean，</t></p>
<p><strong>Consumer</strong>:java.util.function.Consumer<t>定义一个叫accept的抽象方法，它接受泛型对象，没有返回（void)</t></p>
<p><strong>Function</strong>:java.util.function.Function<t,r>接口定义了一个叫做apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。</t,r></p>
<p>Java类型要么式引用类型（Byte,Integer)，要么式原始类型（int,byte)，但是泛型只能够绑定到引用类型。</p>
<p><strong>注意</strong>：任何函数式接口都不允许抛出受检异常。如果你需要Lambda表达式来抛出异常，有两种方法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda包在一个try/catch块中。</p>
<p><strong>lamdba表达式的接口是根据目标类型来进行推断的。</strong></p>
<h3 id="3-5-使用局部变量"><a href="#3-5-使用局部变量" class="headerlink" title="3.5 使用局部变量"></a>3.5 使用局部变量</h3><p>Lambda可以没有限制地捕获实例变量和静态变量，但是局部变量必须显性声明为final，或者事实上是final。换句话说，Lambda表达式只能够捕获给他们的局部变量一次。</p>
<h3 id="3-6-方法引用"><a href="#3-6-方法引用" class="headerlink" title="3.6 方法引用"></a>3.6 方法引用</h3><p>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inventory.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</div><div class="line">inventory.sort(comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
<p>方法引用主要有三种：</p>
<p>1.指向静态方法的方法引用</p>
<p>2.指向任意类型实例方法的方法引用</p>
<p>3.指向现有对象的实例方法的方法引用</p>
<h3 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h3><p><strong>andThen</strong>:返回一个函数，它先对输入应用一个给定函数，在对输出应用另外一个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer,Integer&gt; f = x -&gt; x+<span class="number">1</span>;</div><div class="line">Function&lt;Integer,Integer&gt; g = x -&gt; x*<span class="number">2</span>;</div><div class="line">Function&lt;Integer,Integer&gt; h = f.andThen(g);</div><div class="line"><span class="keyword">int</span> result = h.apply(l);</div><div class="line"><span class="comment">//最后的结果g(f(x)) = (x+1)*2</span></div></pre></td></tr></table></figure>
<p><strong>andCompose:</strong>:先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer,Integer&gt; h = f.andCompose(g);</div><div class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</div><div class="line"><span class="comment">//最后的结果f(g(x))=x*2+1</span></div></pre></td></tr></table></figure>
<h2 id="4-流"><a href="#4-流" class="headerlink" title="4.流"></a>4.流</h2><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h3><p>代码能够以声明性方式写的：说明想要完成什么，而不是说明如何实现。可以将几个基础操作链接起来，来表达复杂的数据处理流水线。同时，filter/sorted/map/collect等操作是与具体线程模型无关的高层次构件，不需要关注数据处理任务并行的细节。</p>
<p><strong>概念</strong>：从支持数据处理操作的源生成的元素序列</p>
<p><strong>元素序列</strong>：可以访问特定元素类型的一组有序值，流主要提供的是一种计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menu.stream().filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</div><div class="line">    .map(Dish::getName)</div><div class="line">    .limit(<span class="number">3</span>)</div><div class="line">    .collect(toList())</div><div class="line"> <span class="comment">//在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素，链中的方法调用都在排队等待，直到调用collect</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//filter 接受Lambda，从流中排除某些元素</span></div><div class="line"><span class="comment">//map 接受一个Lambda，将元素转换成某些形式或提取信息</span></div><div class="line"><span class="comment">//limit  截断流，使其元素不超过给定数量</span></div><div class="line"><span class="comment">//collect 将流转换成其他形式</span></div></pre></td></tr></table></figure>
<h3 id="4-3-流和集合"><a href="#4-3-流和集合" class="headerlink" title="4.3 流和集合"></a>4.3 流和集合</h3><p><strong>集合</strong>：在内存中的数据结构，包含数据结构中目前所有的值，集合中的每个元素都得先算出来才能够添加到集合中(在空间中分布的一组值)</p>
<p><strong>流</strong>：按需消费，在概念上固定的数据结构，只有在消费者要求的时候才会计算值（在时间上分布的一组值）</p>
<p><strong>注意：流只能够消费一遍</strong></p>
<p><strong>内部迭代</strong>：流模式，它帮你把迭代做了，还把得到的流值存在了某个地方。Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现</p>
<p><strong>外部迭代</strong>：用户自己实现迭代</p>
<p><strong>map</strong>:接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射到一个新的元素中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; dishNameLengths = menu.stream()</div><div class="line">    .map(Dish::getName)</div><div class="line">    .map(String::length)</div><div class="line">    .collect(toList());</div></pre></td></tr></table></figure>
<p><strong>flatMap</strong>：各个数组并不是分别映射成一个流，而是把一个流中的每个值都换成另一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharactors = words.stream()</div><div class="line">    .map(w -&gt; w.split(<span class="string">""</span>))</div><div class="line">    .floatMap(Arrays::stream)</div><div class="line">    .distinct()</div><div class="line">    .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><strong>findFirst和findAny的区别</strong>：找到第一个元素在并行上限制更多，如果不关心返回的元素是那个的话，请使用findAny，因为它在使用并行时限制较少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">Optional&lt;Integer&gt; firstSquareDevisibleByThree = someNumbers.stream()</div><div class="line">    .map(x -&gt; x * x)</div><div class="line">    .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">    .findFirst();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通过行为参数化传递代码&quot;&gt;&lt;a href=&quot;#通过行为参数化传递代码&quot; class=&quot;headerlink&quot; title=&quot;通过行为参数化传递代码&quot;&gt;&lt;/a&gt;通过行为参数化传递代码&lt;/h2&gt;&lt;p&gt;作用：软件原则DRY（Don’t repeat yourself,不
    
    </summary>
    
      <category term="Java" scheme="https://caixueyuan.github.io/categories/Java/"/>
    
    
      <category term="Java8" scheme="https://caixueyuan.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>考试</title>
    <link href="https://caixueyuan.github.io/2020/05/12/%E8%80%83%E8%AF%95/"/>
    <id>https://caixueyuan.github.io/2020/05/12/考试/</id>
    <published>2020-05-12T15:37:04.000Z</published>
    <updated>2020-05-14T16:01:21.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-05-12"><a href="#2020-05-12" class="headerlink" title="2020/05/12"></a>2020/05/12</h2><p><strong>错题一</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        x+=<span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"x="</span>+Test.x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        x = x/<span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果：运行正确，结果为0</span></div></pre></td></tr></table></figure>
<p><strong>错题二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</div><div class="line">    Y y = <span class="keyword">new</span> Y();<span class="comment">//1</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">X</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"X"</span>);<span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Y</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"Y"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">X</span></span>&#123;</div><div class="line">    Y y = <span class="keyword">new</span> Y();<span class="comment">//3</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"Z"</span>);<span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> Test();</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//YXYZ</span></div></pre></td></tr></table></figure>
<p><strong>错题三</strong>：instanceof运算符能够用来判断一个对象是否为：一个类的实例，一个实现指定接口的类的实例，一个子类的实例</p>
<p><strong>错题四</strong>：equals()和hashcode()的关系：</p>
<p>equals()相等的两个对象，他们的hashcode肯定相等，</p>
<p>hashcode()相等的两个对象，他们的equals()不一定相等</p>
<p>在hashmap中，key值是不可能重复的，由HashCode和equals方法共同判断key值是否相等，如果两个对象的hashcode相同，也不能够说明key值相等</p>
<p>错误五：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Parent test = <span class="keyword">null</span>;<span class="comment">//会正确地加载静态方法</span></div><div class="line">        test.hello();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//能够正确运行，返回hello</span></div></pre></td></tr></table></figure>
<p>错误六：</p>
<p><img src="image-20200513002308980.png" alt="image-20200513002308980"></p>
<p>Class类在java.lang包中</p>
<p>动态代理技术可以动态创建一个代理对象，反射不行</p>
<p>反射访问私有成员时，Field调用setAccessible可解除访问符限制</p>
<p>CGLIB可以实现字符码修改，反射不能够实现字节码修改</p>
<p>反射会动态创建额外对象，比如每个成员方法只有一个Method对象作为root，他不会直接暴露给用户，调用的时候会返回一个Method的包装类</p>
<p>反射带来的效率问题主要是动态解析类，JVM无法对反射代码进行优化</p>
<p>错题七：</p>
<p><img src="image-20200513002225647.png" alt="image-20200513002225647"></p>
<p><img src="image-20200513002141998.png" alt="image-20200513002141998"></p>
<h2 id="2020-05-13"><a href="#2020-05-13" class="headerlink" title="2020/05/13"></a>2020/05/13</h2><p><strong>错误一</strong>：变量的第一个字母不能够是数字，可以是下划线</p>
<p><strong>错误二</strong>：InputStreamReader可用来处理Unicode，BufferedReader,Writer和PipedInputStream都不能够处理Unicode</p>
<p><strong>错误三</strong>：</p>
<p><img src="image-20200514000131825.png" alt="image-20200514000131825"></p>
<p><strong>错误四：</strong></p>
<p><img src="image-20200514000324218.png" alt="image-20200514000324218"></p>
<p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。</p>
<p><strong>错误五</strong>：</p>
<p>HashTable，ConcurrentHashMap是线程安全的，其他的Map都不是线程安全的。</p>
<p><strong>错误六</strong>：</p>
<p><strong>抽象类</strong></p>
<p><img src="image-20200514000920753.png" alt="image-20200514000920753"></p>
<p>接口中可以由default,static方法。</p>
<p>特点:</p>
<p>1.抽象类中可以构造方法</p>
<p>2.抽象类中可以存在普通属性，方法，静态属性和方法。</p>
<p>3.抽象类中可以存在抽象方法。</p>
<p>4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</p>
<p>5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。</p>
<p><strong>接口</strong></p>
<p>1.在接口中只有方法的声明，没有方法体。</p>
<p>2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上</p>
<p>public static final </p>
<p>3.在接口中的方法，永远都被public来修饰。</p>
<p>4.接口中没有构造方法，也不能实例化接口的对象。</p>
<p>5.接口可以实现多继承</p>
<p>6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法</p>
<p>7.则实现类定义为抽象类。</p>
<p><strong>错误六</strong>：</p>
<p><img src="image-20200514001436984.png" alt="image-20200514001436984"></p>
<p>静态方法不能访问非静态变量，A和C错；</p>
<p>抽象类中的抽象方法不能有方法体，B错；</p>
<p>一个类中有多个类声明时，只能有一个public类，D错</p>
<h2 id="2020-05-14"><a href="#2020-05-14" class="headerlink" title="2020/05/14"></a>2020/05/14</h2><p><strong>错误一</strong>：JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public。接口中方法默认是 abstract public,所以在接口只写函数声明是符合语法规则<strong>。但是</strong>变量默认是用public final static 修饰的，意思它是静态常量，常量不管在接口中还是类中必须在声明时初始化，必须在声明时并给出初始化。接口中只有常量定义，没有变量声明。**</p>
<p><strong>错误二</strong>：</p>
<p>java的访问权限有public、protected、private和default的，default不能修饰变量</p>
<p><strong>错误三：</strong></p>
<p>堆区：只存放类对象，线程共享；</p>
<p>方法区：又叫静态存储区，存放class文件和静态数据，线程共享;</p>
<p>栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2020-05-12&quot;&gt;&lt;a href=&quot;#2020-05-12&quot; class=&quot;headerlink&quot; title=&quot;2020/05/12&quot;&gt;&lt;/a&gt;2020/05/12&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;错题一&lt;/strong&gt;：&lt;/p&gt;
&lt;figure clas
    
    </summary>
    
      <category term="编程考试" scheme="https://caixueyuan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%80%83%E8%AF%95/"/>
    
    
      <category term="考试" scheme="https://caixueyuan.github.io/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>脚本和shell</title>
    <link href="https://caixueyuan.github.io/2019/11/12/shell%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2019/11/12/shell基础知识/</id>
    <published>2019-11-12T15:27:49.000Z</published>
    <updated>2019-12-15T15:19:13.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell基础知识"><a href="#shell基础知识" class="headerlink" title="shell基础知识"></a>shell基础知识</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//管道</div><div class="line">cut -d: -f7 &lt; /etc/passwd | sort -u</div><div class="line">//只有当/tmp/t2被成功送入到打印队列后才会删除/tmp/t2</div><div class="line">lpr /tmp/t2 &amp;&amp; rm /tmp/t2</div><div class="line">//只有当第一条命令执行失败才会执行第二条语句</div><div class="line">cp --preserve --recursive /etc/* /spare/backup || echo "Did not make backup"</div><div class="line">//用户环境变量</div><div class="line">bash ~/.profile</div><div class="line">bash ~/.bash_profile</div><div class="line">//将输出的语句进行执行</div><div class="line">find / -type f -name "*.log" 2&gt;/dev/null | grep -v boot.log | while read fname;do echo mv $fname $&#123;fname&#125;;done;|bash -x</div></pre></td></tr></table></figure>
<h2 id="引导和关机"><a href="#引导和关机" class="headerlink" title="引导和关机"></a>引导和关机</h2><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><ol>
<li>从MRB读取引导加载程序</li>
<li>加载并初始化内核</li>
<li>检测和配置设备</li>
<li>创建内核线程</li>
<li>系统管理员干预</li>
<li>执行系统启动脚本</li>
</ol>
<p>mount -o rw, remount /：重新挂载根目录</p>
<p><code>/etc/init.d/</code>:能够启动或者停止各个服务。当主脚本把系统引入到一个新的运行级别时，它不是直接在<code>/etc/init/d</code>目录下寻找，而是查找<code>/etc/rc**level**.d</code>目录下</p>
<p>这些目录的运行脚本都是软链接到/etc/init.d目录下的脚本，当init从低运行级向高运行级过渡时，它按照数字递增的顺序，带start参数运行所有以S开头的脚本。当init从高运行级向低运行级别过渡时，它按照数字递增的顺序，带Stop参数运行所有以K开头的脚本</p>
<h3 id="访问控制和超级权限"><a href="#访问控制和超级权限" class="headerlink" title="访问控制和超级权限"></a>访问控制和超级权限</h3><p><code>/etc/passwd</code>：记录用户的个数</p>
<p><code>/etc/group</code>:记录用户组的个数</p>
<p>bash在登陆模式启动要读~/.bash_profile，在非登录模式则读取~/.bashrc</p>
<p><code>/etc/sudoers</code>:这个文件列出了授权使用sudo的人以及允许他们在每台主机上运行的命令。如果提供给sudo的命令运行运行，那么sudo就提示输入这个用户自己的口令并执行命令。可以通过visudo来编辑该文件</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>Unix和Linux都没有提供新进程去运行某个特定程序的系统调用，现有进程必须克隆自身去创建一个新进程，克隆出的进程能够把它正在运行的那个程序替换成另外一个不同的程序</p>
<p><code>kill pid</code>:请求彻底终止某次执行。它期待接受该信号的进程清除自身的状态并退出。但是该命令不能够保证进程会被杀死。因为TERM信号可能会被捕获/封锁或者忽略。</p>
<p><strong>设置nice值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nice -n 5 ~/bin/longtask</div><div class="line">sudo renice -5 8829</div><div class="line">sudo renice 5 -u boggs</div></pre></td></tr></table></figure>
<p><strong>ps命令使用</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps aux</div><div class="line">ps lax #能够显示父进程，谦让值字段以及进程正在等待的资源(WCHAN)</div><div class="line">find /home -size +1M -print0 | xargs -0 ls -l</div></pre></td></tr></table></figure>
<p>/proc目录下的进程信息文件</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd</td>
<td>进程正在执行的命令或者程序</td>
</tr>
<tr>
<td>cmdline</td>
<td>进程的完整命令行</td>
</tr>
<tr>
<td>cwd</td>
<td>链到进程当前目录的符号链接</td>
</tr>
<tr>
<td>environ</td>
<td>进程的环境变量</td>
</tr>
<tr>
<td>statm</td>
<td>内存使用情况的信息</td>
</tr>
<tr>
<td>exe</td>
<td>链到正被执行的文件的符号链接</td>
</tr>
<tr>
<td>stat</td>
<td>进程的总体状态信息</td>
</tr>
<tr>
<td>fd</td>
<td>子目录，其中包含链到每个打开文件的描述符的链接</td>
</tr>
<tr>
<td>maps</td>
<td>内存映射信息（共享段/库）</td>
</tr>
<tr>
<td>root</td>
<td>链到进程的根目录的符号链接</td>
</tr>
<tr>
<td>stat</td>
<td>进程的总体状态信息（ps最擅长解析这些信息）</td>
</tr>
</tbody>
</table>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mount /dev/hda4 /users</div><div class="line"><span class="meta">#</span><span class="bash"> 输出正在使用该文件系统上的某个文件或者目录的每个进程的PID</span></div><div class="line">fuser -c /usr</div></pre></td></tr></table></figure>
<p>挂载在某个特定系统上的文件系统清单保存在/etc/fstab文件、/etc/vfstab(Solaris)文件。当系统引导时，包含在这个文件中的信息让这些文件系统先被检查(fsck)再自动挂载到系统中</p>
<p><strong>umount</strong>命令用来卸载文件系统，在大多数系统上，不能够卸载处于“busy”状态的文件系统。umount -f命令能够强制卸载一个处于忙状态的文件系统。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>f,o</td>
<td>进程有一个为了读或者写而打开的文件</td>
</tr>
<tr>
<td>c</td>
<td>进程的当前目录在这个文件系统中</td>
</tr>
<tr>
<td>e,t</td>
<td>进程目前在执行一个文件</td>
</tr>
<tr>
<td>r</td>
<td>进程的根目录在这个文件系统中</td>
</tr>
<tr>
<td>m,s</td>
<td>进程已经映射了一个文件或者共享库</td>
</tr>
</tbody>
</table>
<p><img src="image-20191126000328683.png" alt="image-20191126000328683"></p>
<p><img src="image-20191126000407140.png" alt="image-20191126000407140"></p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>文件有以下几种类型：普通文件，目录，字符设备文件，块设备文件，本地域套接字，有名管道，符号链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln old ../new#硬链接</div><div class="line">ls -s old ../new#软连接</div></pre></td></tr></table></figure>
<p>硬链接和软链接的区别：硬链接时直接引用，而符号链接是通过名称来引用的。</p>
<p>主设备号告诉内核该文件访问哪个驱动程序，次设备号告诉驱动程序对哪个物理单元寻址。</p>
<p>字符设备文件让与之相关的驱动程序做它们自己的输入和输出缓冲。块设备文件由处理块数据的I/O的驱动程序使用，并要求内核为之缓冲。</p>
<p>setuid和setgid：让执行该命令的用户能够以该命令所有者的权限来执行。</p>
<p>粘滞位（/tmp）：所有的用户能够在该目录下拥有所有的权限，能够在该目录下任意创建文件，修改和删除文件，但是呢，别的用户不能够动到别人的文件</p>
<p>umask：分配默认的权限。默认的umask值是022，它不允许属组和其他用户有写入权限。</p>
<h2 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h2><p>/etc/passwd:用户信息</p>
<p>/etc/shadow:用户密码</p>
<p>linux中口令加密算法及其长度限制 位置：/etc/login.defs</p>
<p>如果把/etc/login.defs中的DEFAULT_HOME设为no，那么就会禁止没有主目录的用户登录。</p>
<p>可以通过chsh命令来改变自己的shell，chfn来修改使用LDAP或者其他目录服务管理登录信息。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>文件名</th>
<th>设置环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>bash</td>
<td>.bashrc     .bash_profile</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>sh</td>
<td>.profile</td>
<td>设置搜索路径/终端类型和环境</td>
</tr>
<tr>
<td>vim</td>
<td>.vimrc       .excr</td>
<td>设置vim编辑器的选项</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo useradd -c "caixueyuan" -d /home/caixueyuan -g caixueyuan -G student -m -s /bin/sh caixueyuan</div><div class="line">userdel caixueyuan#删除用户</div><div class="line">usermod -L user#锁住用户</div><div class="line">usermod -U user#解锁用户</div></pre></td></tr></table></figure>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> -T选项从硬盘的高速缓存中读取信息，并且指示总线上的数据传输率，跟物理硬盘介质的吞吐量有关</span></div><div class="line"><span class="meta">#</span><span class="bash"> -t 从物理盘片读数据</span></div><div class="line">sudo hdparm -Tt /dev/sda</div></pre></td></tr></table></figure>
<p>Linux的LVM配置过程依次为以下不同的阶段：</p>
<ol>
<li><p>创建和初始化物理卷</p>
</li>
<li><p>把物理卷加入到一个卷组中</p>
</li>
<li><p>在卷组中创建逻辑卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">   #</span><span class="bash">创建物理卷</span></div><div class="line">   sudo pvcreate /dev/md0</div><div class="line"><span class="meta">   #</span><span class="bash">创建卷组</span></div><div class="line">   sudo vgcreate DEMO /dev/md0</div><div class="line"><span class="meta">   #</span><span class="bash">创建逻辑卷</span></div><div class="line">   sudo lvcreate -L 100G -n web1 DEMO</div><div class="line"><span class="meta">   #</span><span class="bash">创建文件系统</span></div><div class="line">   sudo mkfs /dev/DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">挂载</span></div><div class="line">   sudo mkdir /mnt/web1</div><div class="line">   sudo mount /dev/DEMO/web1 /mnt/web1</div><div class="line"><span class="meta">   #</span><span class="bash">创建快照（创建快照最好跟数据一样大)</span></div><div class="line">   sudo lvcreate -L 100G -s -n web1-snap DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">给逻辑卷增加空间</span></div><div class="line">   sudo  umount /mnt/web1</div><div class="line">   sudo lvchange -an DEMO/web1</div><div class="line">   sudo lvresize -L +10G DEMo/web1</div><div class="line">   sudo lvchange -ay DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">改变文件系统的大小</span></div><div class="line">   sudo e2fsck -f /dev/DEMO/web1</div><div class="line">   sudo resize2fs /dev/DEMO/web1</div><div class="line"><span class="meta">   #</span><span class="bash">将ext2文件系统转为ext4文件系统</span></div><div class="line">tune2fs -j /dev/hda4</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>   <strong>mkfs</strong>：格式化文件系统</p>
<p>   <strong>fsck</strong>：检查和修复文件系统</p>
<p>   <strong>mount</strong>：挂载文件系统</p>
<p>   <strong>df</strong>:核对一个文件系统的大小</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">挂载硬盘上所有本地的ext4文件系统</span></div><div class="line">sudo mount -at ext4、</div><div class="line"><span class="meta">#</span><span class="bash"> 查看交互分区的设置</span></div><div class="line">sudo swapon -s</div></pre></td></tr></table></figure>
<p>   周期性进程</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">配置方法</span></div><div class="line">55 23 * * 0-3,6 /staff/trent/bin/checkservers</div><div class="line">30 2 * * 1 (cd /user/joe/project; make)</div><div class="line"><span class="meta">#</span><span class="bash"> 用filename来替换任何以前版本的crontab文件</span></div><div class="line">crontab filename</div><div class="line"><span class="meta">#</span><span class="bash"> 编辑文件</span></div><div class="line">crontab -e filename</div><div class="line"><span class="meta">#</span><span class="bash"> cron.deny和cron.allow指定哪些用户可以提交crontab文件</span></div><div class="line"><span class="meta">#</span><span class="bash">删除core文件</span></div><div class="line">find / -xdev -type f '(' -name core -o name 'core.[0-9]*' ')' -atime +7 -exec rm -f &#123;&#125; ';'</div><div class="line">find . ! -name  . ! -name lost+found -type d -mtime +3 -exec /bin/rm -rf &#123;&#125; ';'</div></pre></td></tr></table></figure>
<p>   系统的crontab在/etc/crontab文件中和/etc/cron.d目录中。</p>
<p>   在/etc/cron.daily中的脚本每天运行一次，在/etc/cron.weekly中的脚本每周运行一次。</p>
<h2 id="软件安装和管理"><a href="#软件安装和管理" class="headerlink" title="软件安装和管理"></a>软件安装和管理</h2><h3 id="高级软件包管理系统"><a href="#高级软件包管理系统" class="headerlink" title="高级软件包管理系统"></a>高级软件包管理系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rpm -i#安装</div><div class="line">rpm -U #更新</div><div class="line">rpm -e #卸载</div><div class="line">rpm -q #查询</div><div class="line">rpm -qa #显示系统已经安装的软件包的完整清单</div><div class="line">rpm --query --whatrequires openssh#在尝试升级之前判断出会有其他软件包依赖OpenSSH</div><div class="line">dpkg -l | grep package #判断某个软件是否安装的方便途径</div><div class="line">sudo git rm --cached mtab #在当前的库影像里删除mtab文件</div></pre></td></tr></table></figure>
<ol>
<li>apt-get 最重要的配置文件是/etc/apt/source.list，它告诉apt-get 到哪里去找它的软件包。规定了软件包的类型，指向一个文件/CD-ROM/HTTP服务器或者FTP服务器的URL，组件可能的清单。</li>
<li>apt-mirror在/etc/apt/里放了一个叫做mirror.list的文件，在默认情况下，mirror.list包括了正在使用的Ubuntu版本的所有库。</li>
<li>apt-get dist-upgrade会下载并安装已经在本地机器上安装过的任何软件包的新版本</li>
<li>默认返回yes来使用-yes选项</li>
<li>apt-get –download-only自动下载任何改动过的软件包，但是不安装</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;shell基础知识&quot;&gt;&lt;a href=&quot;#shell基础知识&quot; class=&quot;headerlink&quot; title=&quot;shell基础知识&quot;&gt;&lt;/a&gt;shell基础知识&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="操作系统" scheme="https://caixueyuan.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux系统管理技术手册" scheme="https://caixueyuan.github.io/tags/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准模板库</title>
    <link href="https://caixueyuan.github.io/2019/10/25/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <id>https://caixueyuan.github.io/2019/10/25/C-标准模板库/</id>
    <published>2019-10-24T16:24:38.000Z</published>
    <updated>2019-11-07T16:24:50.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string类和标准模板库"><a href="#string类和标准模板库" class="headerlink" title="string类和标准模板库"></a>string类和标准模板库</h2><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> info[<span class="number">100</span>];</div><div class="line"><span class="built_in">cin</span> &gt;&gt; info;</div><div class="line"><span class="built_in">cin</span>.getline(info,<span class="number">100</span>);</div><div class="line"><span class="built_in">cin</span>.get(info,<span class="number">100</span>);</div><div class="line"><span class="built_in">cin</span>.getline(info,<span class="string">":"</span>);</div><div class="line"><span class="built_in">string</span> stuff;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; stuff;</div><div class="line">getline(<span class="built_in">cin</span>,stuff);</div><div class="line">getline(stuff,<span class="string">":"</span>);</div></pre></td></tr></table></figure>
<p>string对象的最大允许长度，由常量string::npos指定，这通常是最大的unsigned int值</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>shared_ptr</strong>:创建智能更高的指针，跟踪引用特定对象的智能指针数，引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用delete。</p>
<p><strong>auto_ptr</strong>：建立所有权概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。</p>
<p><strong>unique_ptr</strong>:如果出现了浅拷贝的赋值方式下，会在编译的过程中报错误</p>
<p>能够使用auto_ptr的地方最好使用unique_ptr，能够在编译的过程中设别浅拷贝风险。</p>
<p>unique_ptr智能指针有数组和非数组的方式</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="title">class</span> <span class="title">TooBig2</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span>:T cutoff;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    TooBig2(<span class="keyword">const</span> T &amp; t):cutoff(t)&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>&#123;<span class="keyword">return</span> tooBig&lt;T&gt;(v,cutoff)&#125;<span class="comment">//函数对象</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;class T&gt;</div><div class="line"><span class="keyword">bool</span> tooBig(<span class="keyword">const</span> T &amp; val,<span class="keyword">const</span> T &amp; lim)&#123;<span class="keyword">return</span> val&gt;lim;&#125;</div><div class="line"></div><div class="line">TooBig2&lt;<span class="keyword">int</span>&gt; tB100(<span class="number">100</span>);</div><div class="line"><span class="keyword">int</span> x;<span class="built_in">cin</span> &gt;&gt; x;</div><div class="line"><span class="keyword">if</span>(tB100(x))<span class="comment">//same as if (tooBig(x,100))</span></div><div class="line"><span class="comment">//调用tB100(x)相当于调用tooBig(x,100),但两个参数的函数转换为单参数的函数对象，其中第二个参数被用于构建函数对象，简而言之，类函数符TooBig2时一个函数适配器，使得函数能够满足不同的接口</span></div></pre></td></tr></table></figure>
<p>复制构造函数和移动构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//复制构造函数</span></div><div class="line">Useless &amp; Useless:<span class="keyword">operator</span>=(<span class="keyword">const</span> Useless &amp; f)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;f)</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span>[] pc;</div><div class="line">    n = f.n;</div><div class="line">    pc = <span class="keyword">new</span> <span class="keyword">char</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        pc[i]=f.pc[<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//移动构造函数</span></div><div class="line">Useless &amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp; f)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;f)</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">delete</span>[] pc;</div><div class="line">    n = f.n;</div><div class="line">    pc = f.pc;</div><div class="line">    f.n = <span class="number">0</span>;</div><div class="line">    f.pc = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以使用std::move来强制调用移动构造函数</span></div><div class="line">Useless four = <span class="built_in">std</span>::move(one);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string类和标准模板库&quot;&gt;&lt;a href=&quot;#string类和标准模板库&quot; class=&quot;headerlink&quot; title=&quot;string类和标准模板库&quot;&gt;&lt;/a&gt;string类和标准模板库&lt;/h2&gt;&lt;h3 id=&quot;string类&quot;&gt;&lt;a href=&quot;#st
    
    </summary>
    
      <category term="C++,学习笔记" scheme="https://caixueyuan.github.io/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://caixueyuan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>powershell学习笔记</title>
    <link href="https://caixueyuan.github.io/2019/09/08/powershell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2019/09/08/powershell学习笔记/</id>
    <published>2019-09-08T04:41:58.000Z</published>
    <updated>2019-10-21T14:41:36.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="powershell交互式"><a href="#powershell交互式" class="headerlink" title="powershell交互式"></a>powershell交互式</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查询别名所指的真实cmdlet命令。</span></div><div class="line"><span class="built_in">Get-Alias</span> -name ls</div><div class="line"><span class="comment"># 查看所有以Remove打头的cmdlet命令的别名</span></div><div class="line">ls alias: | where &#123;<span class="variable">$_</span>.Definition.Startswith(<span class="string">"Remove"</span>)&#125;</div><div class="line"><span class="comment"># 设置别名</span></div><div class="line"><span class="built_in">Set-Alias</span> -Name edit -Value notepad</div><div class="line"><span class="comment"># 显示别名</span></div><div class="line">echo <span class="variable">$alias:edit</span></div><div class="line"><span class="comment">#删除别名</span></div><div class="line">del-Alias alias:edit</div><div class="line"><span class="comment">#保存别名</span></div><div class="line"><span class="built_in">Import-Alias</span> alias.ps1</div><div class="line"><span class="comment">#导入别名</span></div><div class="line"><span class="built_in">Export-Alias</span> -force alias.ps1</div><div class="line"><span class="comment">#使用函数</span></div><div class="line"><span class="keyword">function</span> test-conn</div><div class="line">&#123;</div><div class="line"><span class="built_in">Test-Connection</span> -Count <span class="number">2</span> -ComputerName <span class="variable">$args</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Set-Alias</span> tc test-conn</div><div class="line">tc <span class="number">127.0</span>.<span class="number">0.1</span></div><div class="line"><span class="comment"># 获取文件的内容</span></div><div class="line"><span class="built_in">Get-Content</span> test.ps1</div></pre></td></tr></table></figure>
<p>powershell解析命令的顺序</p>
<ol>
<li>别名</li>
<li>函数</li>
<li>cmdlets，内置命令</li>
<li>外部的ps1文件</li>
<li>外部的普通文件</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建只读变量</span></div><div class="line"><span class="built_in">New-Variable</span> num -Value <span class="number">100</span> -Force -Option readonly</div><div class="line"><span class="comment">#删除变量</span></div><div class="line">del Variable:num -Force</div><div class="line"><span class="comment">#声明常量</span></div><div class="line"><span class="built_in">new-variable</span> num -Value <span class="string">"strong"</span> -Option constant</div><div class="line"><span class="comment">#查看变量表述</span></div><div class="line"><span class="built_in">new-variable</span> name -Value <span class="string">"me"</span> -Description <span class="string">"This is my name"</span></div></pre></td></tr></table></figure>
<h3 id="特殊变量说明"><a href="#特殊变量说明" class="headerlink" title="特殊变量说明"></a>特殊变量说明</h3><table>
<thead>
<tr>
<th>$$</th>
<th>包含会话所收到的最后一行的最后一个令牌</th>
</tr>
</thead>
<tbody>
<tr>
<td>$?</td>
<td>包含最后一个操作的执行状态</td>
</tr>
<tr>
<td>$^</td>
<td>包含会话所收到的最后一行的第一个令牌</td>
</tr>
<tr>
<td>$_</td>
<td>包含管道对象中的当前对象</td>
</tr>
<tr>
<td>$Args</td>
<td>包含由未声明参数或传递给函数，脚本或脚本块的参数值组成的数组</td>
</tr>
<tr>
<td>$LastExitCode</td>
<td>包含运行的最后一个基于windows的程序的退出代码</td>
</tr>
</tbody>
</table>
<p><strong>环境变量</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查找环境变量</span></div><div class="line">ls env:</div><div class="line"><span class="comment"># 创建新的环境变量</span></div><div class="line"><span class="variable">$env:mytest</span> = <span class="string">"This is my test"</span></div><div class="line"><span class="comment"># 对当前用户设置环境变量，重新打开powershell仍然有效</span></div><div class="line">[environment]::SetEnvironmentvariable(<span class="string">"Path"</span>, <span class="string">";c:\powershellscript"</span>, <span class="string">"User"</span>)</div><div class="line">[environment]::GetEnvironmentvariable(<span class="string">"Path"</span>, <span class="string">"User"</span>)</div></pre></td></tr></table></figure>
<p><strong>更改变量的可见性</strong>：在运行脚本时使用一个原点和空格，powershell不会给脚本创建自己的变量作用域，它会共享当前控制台的作用域。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><table>
<thead>
<tr>
<th>变量</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td>$global</td>
<td>全局变量，在所有的作用域中有效</td>
</tr>
<tr>
<td>$script</td>
<td>脚本变量，只会在脚本内部有效，包括脚本中的函数，一旦脚本运行结束，就会被回收</td>
</tr>
<tr>
<td>$private</td>
<td>只在当前作用域有效</td>
</tr>
<tr>
<td>$local</td>
<td>默认变量，在当前作用域有效，其他作用域只对它有只读权限</td>
</tr>
</tbody>
</table>
<p>$private限制的变量不能够再$global修改，不但不能够修改，还会删除当前的值</p>
<p>$local修饰的变量可以通过$global在函数内部更改</p>
<p><strong>变量类型</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义强类型变量</span></div><div class="line">[byte]<span class="variable">$b</span>=<span class="number">101</span></div><div class="line">[ XML ]<span class="variable">$xml</span>=(<span class="built_in">Get-Content</span> .LogoTestConfig.xml)</div><div class="line"><span class="comment"># 修改变量的属性</span></div><div class="line">(<span class="built_in">Get-Variable</span> str).Description=<span class="string">"变量的描述已经改变"</span></div><div class="line"><span class="built_in">Get-Variable</span> str | <span class="built_in">format-table</span> Name,Description</div><div class="line"><span class="built_in">Set-Variable</span> var -Option <span class="string">"ReadOnly"</span></div><div class="line">(<span class="built_in">Get-Variable</span> var).Options</div><div class="line"><span class="comment"># Attributes属性</span></div><div class="line"><span class="variable">$var</span>=<span class="string">"限制变量"</span></div><div class="line"><span class="variable">$condition</span>= <span class="built_in">New-Object</span> System.Management.Automation.ValidateLengthAttribute -ArgumentList <span class="number">2</span>,<span class="number">5</span></div><div class="line">(<span class="built_in">Get-Variable</span> var).Attributes.Add(<span class="variable">$condition</span>)</div></pre></td></tr></table></figure>
<p>Attributes[System.Management.Automation.PSVariableAttributeCollection]属性，如果这个Attributes为空，可以给这个变量存放任何 类型的数据，Powershell会自己选择合适的类型。一旦这个Attributes属性确定下来，就不能随意存放数据了</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 判断变量的类型</span></div><div class="line"><span class="variable">$ip</span> -is [array]</div><div class="line"><span class="variable">$ip</span>.ToCharArray() -is [array]</div><div class="line">ipconfig | <span class="built_in">Select-String</span> <span class="string">"IP"</span></div><div class="line"><span class="comment"># 创建空数组</span></div><div class="line"><span class="variable">$a</span>=@()</div><div class="line"><span class="comment"># 创建一个元素的数组</span></div><div class="line"><span class="variable">$a</span>=,<span class="string">"moss"</span></div><div class="line"><span class="comment">#访问数组</span></div><div class="line"><span class="variable">$result</span>[result.count(<span class="number">0</span>-<span class="number">1</span>)]</div><div class="line"><span class="comment">#逆序输出数组</span></div><div class="line"><span class="variable">$books</span>[(<span class="variable">$books</span>.count)..<span class="number">0</span>]</div><div class="line"><span class="comment">#添加元素</span></div><div class="line"><span class="variable">$books</span>+=<span class="string">"元素4"</span></div><div class="line"><span class="comment">#复制数组</span></div><div class="line"><span class="variable">$chsBak</span>=<span class="variable">$chs</span> <span class="comment">#浅复制</span></div><div class="line"><span class="variable">$chsBak</span>=<span class="variable">$chs</span>.Clone() <span class="comment">#深复制</span></div><div class="line"><span class="comment">#查看和验证变量的数据类型</span></div><div class="line"><span class="variable">$result</span>.gettype().name</div><div class="line"><span class="comment">#int类型的最大值</span></div><div class="line">([int32]::MaxValue)</div><div class="line"><span class="comment">#强类型数组</span></div><div class="line">[int[]] <span class="variable">$nums</span>=@()</div><div class="line"><span class="comment">#哈希表</span></div><div class="line"><span class="variable">$str</span>=@&#123;Name=<span class="string">"小明"</span>;Age=<span class="string">"12"</span>&#125;</div><div class="line"><span class="variable">$str</span>.Keys</div><div class="line"><span class="variable">$str</span>.Values</div><div class="line"><span class="variable">$str</span>.Remove(<span class="string">"Name"</span>)</div></pre></td></tr></table></figure>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><img src="管道.png" alt="1567933553288"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#遍历C盘的所有文件</span></div><div class="line">Dir C: -recurse</div><div class="line"><span class="comment">#以脚本块作为属性</span></div><div class="line">ls | <span class="built_in">Format-Table</span> Name,&#123; [int](<span class="variable">$_</span>.Length/<span class="number">1</span>kb) &#125;</div><div class="line"><span class="variable">$column</span> = @&#123;Expression=&#123; [int](<span class="variable">$_</span>.Length/<span class="number">1</span>KB) &#125;; Label=<span class="string">"KB"</span> &#125;</div><div class="line">Dir | <span class="built_in">Format-Table</span> Name, <span class="variable">$column</span></div><div class="line">ls | <span class="built_in">Format-Table</span> -AutoSize</div><div class="line"><span class="comment">#排序</span></div><div class="line">ls | <span class="built_in">Sort-Object</span> Length -Descending</div><div class="line">Dir | <span class="built_in">Sort-Object</span> @&#123;expression=<span class="string">"Length"</span>;Descending=<span class="literal">$true</span>&#125;,@&#123;ex</div><div class="line">pression=<span class="string">"Name"</span>;Ascending=<span class="literal">$true</span>&#125;</div><div class="line"><span class="comment">#分组</span></div><div class="line">ls | <span class="built_in">Group-Object</span> Extension <span class="comment">#按照扩展名进行分组</span></div><div class="line">ls | <span class="built_in">Group-Object</span> &#123;<span class="variable">$_</span>.name.SubString(<span class="number">0</span>,<span class="number">1</span>).toUpper()&#125; <span class="comment">#按照首字母来排序</span></div><div class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Group-Object</span> Company -NoElement <span class="comment">#根据当前应用程序的发布者分组</span></div><div class="line"><span class="built_in">Get-service</span> | <span class="built_in">Select-Object</span> -First <span class="number">1</span> | <span class="built_in">format-list</span> *</div><div class="line"><span class="built_in">Get-service</span> | <span class="built_in">Select-Object</span> -First <span class="number">1</span> | <span class="built_in">Get-Member</span> -MemberType</div><div class="line"><span class="built_in">get-service</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">"Running"</span>&#125;</div><div class="line"><span class="comment"># 流出最后修改的5个文件</span></div><div class="line">Dir | <span class="built_in">Select-Object</span> -ExcludeProperty <span class="string">"*N*"</span> -First <span class="number">5</span></div><div class="line"><span class="comment">#统计和计算</span></div><div class="line">ls | measure length -Average -Sum -Maximum -Minimum</div></pre></td></tr></table></figure>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建对象</span></div><div class="line"><span class="variable">$pocketknife</span>=<span class="built_in">New-Object</span> object</div><div class="line"><span class="comment"># 并向对象逐个增加属性</span></div><div class="line"><span class="built_in">Add-Member</span> -InputObject <span class="variable">$pocketknife</span> -Name Color -Value <span class="string">"Red"</span> -MemberType NoteProperty</div><div class="line"><span class="variable">$pocketknife</span> | <span class="built_in">Add-Member</span> NoteProperty Blades <span class="number">3</span></div><div class="line"><span class="built_in">Add-Member</span> -memberType ScriptMethod <span class="nomarkup">-In</span> <span class="variable">$pocketknife</span> -name cut -Value &#123; <span class="string">"I'm whittling now"</span> &#125;</div><div class="line"><span class="variable">$pocketknife</span> | <span class="built_in">Add-Member</span> ScriptMethod corkscrew &#123; <span class="string">"Pop! Cheers!"</span> &#125;</div><div class="line"><span class="comment">#调用方法时一定要加上原括号，方法不会执行，但是可以返回方法的基本信息</span></div><div class="line"><span class="variable">$pocketknife</span>.cut()</div><div class="line"><span class="comment"># 获取枚举变量的值</span></div><div class="line">[System.Enum]::GetNames([System.ConsoleColor])</div><div class="line"><span class="comment"># 查看所有属性，返回成员详细信息，如果只显示属性可以使用参数memberType为"Porperty"</span></div><div class="line"><span class="variable">$host</span> | <span class="built_in">Get-Member</span> -memberType property</div><div class="line"><span class="comment"># 列出一个对象的所有方法</span></div><div class="line"><span class="variable">$Host</span> | <span class="built_in">Get-Member</span> -MemberType Method</div><div class="line"><span class="variable">$Host</span>.UI.RawUI | <span class="built_in">Get-Member</span> -me method | where &#123;<span class="variable">$_</span>.Name <span class="nomarkup">-notlike</span> <span class="string">'*_*'</span>&#125;</div><div class="line"><span class="comment">#列出静态方法</span></div><div class="line">[System.DateTime] | <span class="built_in">Get-Member</span> -static -memberType *Method</div><div class="line"><span class="comment"># 调用静态方法</span></div><div class="line">[System.DateTime]::Parse(<span class="string">"2012-10-13 23:42:55"</span>)</div><div class="line">[String].GetConstructors() | <span class="keyword">foreach</span> &#123;<span class="variable">$_</span>.tostring()&#125;</div></pre></td></tr></table></figure>
<p>MemberType包括</p>
<p><strong>AliasProperty</strong>：另外一个属性的别名<br><strong>CodeProperty</strong>：通过静态的.Net方法返回属性的内容<br><strong>Property</strong>：真正的属性<br><strong>NoteProperty</strong>：随后增加的属性<br><strong>ScriptProperty</strong>：通过脚本执行返回一个属性的值<br><strong>ParameterizedProperty</strong>：需要传递参数的属性</p>
<h2 id="循环和判断"><a href="#循环和判断" class="headerlink" title="循环和判断"></a>循环和判断</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取进程名称为notepad的进程</span></div><div class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.Name <span class="nomarkup">-eq</span> <span class="string">"notepad"</span>&#125;</div><div class="line"><span class="comment"># switch使用方式</span></div><div class="line"><span class="keyword">switch</span>(<span class="variable">$value</span>)</div><div class="line">&#123;</div><div class="line">    <span class="number">1</span> &#123;<span class="string">"Beijing"</span>&#125;</div><div class="line">    <span class="number">2</span> &#123;<span class="string">"Shanghai"</span>&#125;</div><div class="line">    <span class="number">3</span> &#123;<span class="string">"Tianjin"</span>&#125;</div><div class="line">    <span class="number">4</span> &#123;<span class="string">"Chongqing"</span>&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">#foreach-object方法</span></div><div class="line"><span class="built_in">Get-WmiObject</span> Win32_Service | <span class="built_in">ForEach-Object</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="variable">$_</span>.ProcessId <span class="nomarkup">-gt</span> <span class="number">3000</span>)</div><div class="line">    &#123; <span class="string">"&#123;0&#125;(&#123;1&#125;)"</span> -f <span class="variable">$_</span>.DisplayName,<span class="variable">$_</span>.ProcessID&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 对管道结果逐个处理</span></div><div class="line"><span class="keyword">foreach</span>(<span class="variable">$file</span> <span class="keyword">in</span> dir c:\windows)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="variable">$file</span>.Length <span class="nomarkup">-gt</span> <span class="number">1</span>mb)</div><div class="line">    &#123;</div><div class="line">        <span class="variable">$File</span>.Name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment"># 逐行读取文件</span></div><div class="line"><span class="keyword">for</span>(<span class="variable">$file</span>=[IO.File]::OpenText(<span class="string">"c:autoexec.bat"</span>) ; !(<span class="variable">$file</span>.EndOfStream);<span class="variable">$line</span>=<span class="variable">$file</span>.ReadLine() )</div><div class="line">&#123;</div><div class="line">    <span class="variable">$line</span>;</div><div class="line">&#125;</div><div class="line"><span class="variable">$file</span>.Close()</div><div class="line"><span class="comment">#函数</span></div><div class="line"><span class="keyword">Function</span> FuncName （args[]）</div><div class="line">&#123;</div><div class="line">      code;</div><div class="line">&#125;</div><div class="line">del <span class="keyword">function</span>:funcName</div><div class="line"><span class="comment"># 定义输入参数类型</span></div><div class="line"><span class="keyword">function</span> subtract([int]<span class="variable">$value1</span>=<span class="number">0</span>,[int]<span class="variable">$value2</span>=<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#从这里开始隐藏所有的错误信息</span></div><div class="line"><span class="variable">$ErrorActionPreference</span>=<span class="string">"SilentlyContinue"</span> <span class="comment"># 关闭错误输出</span></div><div class="line"><span class="variable">$ErrorActionPreference</span>=<span class="string">"Continue"</span> <span class="comment">#开启错误输出</span></div><div class="line"><span class="comment"># 管道</span></div><div class="line"><span class="variable">$input</span> <span class="comment">#管道输入</span></div><div class="line"><span class="variable">$args</span> <span class="comment">#参数输入</span></div></pre></td></tr></table></figure>
<h2 id="powershell脚本"><a href="#powershell脚本" class="headerlink" title="powershell脚本"></a>powershell脚本</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取和更改脚本执行策略</span></div><div class="line"><span class="built_in">Get-ExecutionPolicy</span></div><div class="line"><span class="built_in">Set-ExecutionPolicy</span> UnRestricted</div></pre></td></tr></table></figure>
<p><strong>Unrestricted:</strong>权限最高，可以不受限制执行任何脚本。<br><strong>Default:</strong>为Powershell默认的策略：Restricted，不允许任何脚本执行。<br><strong>AllSigned：</strong>所有脚本都必须经过签名才能在运行。<br><strong>RemoteSigned：</strong>本地脚本无限制，但是对来自网络的脚本必须经过签名。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 给脚本的参数绑定数据类型，绑定帮助信息，如果脚本缺少参数，或者输入的参数类型不正确，就会报错	</span></div><div class="line"><span class="keyword">param</span>(</div><div class="line">[string]<span class="variable">$Name</span>=$(<span class="keyword">throw</span> <span class="string">"Parameter missing: -name Name"</span>) ,</div><div class="line">[int]<span class="variable">$Age</span>=$(<span class="keyword">throw</span> <span class="string">"Parameter missing: -age x as number"</span>)</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="string">"Name= <span class="variable">$Name</span>"</span></div><div class="line"><span class="string">"Age=<span class="variable">$Age</span>"</span></div></pre></td></tr></table></figure>
<p>在Powershell脚本的处理中，绝大多数情况下遇到的都是集合，一旦上一条命令产生一个中间结果，下一条命令就对这个中间结果及时处理，及时释放资源。这样可以节省内存，也减少了用户的等待时间。在处理大量数据时，尤其值得推荐。高速流模式的管道定义包括三部分：begin,process,end。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">Write-Host</span> <span class="string">"管道脚本环境初始化"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">process</span></div><div class="line">&#123;</div><div class="line">    <span class="variable">$ele</span>=<span class="variable">$_</span></div><div class="line">    <span class="keyword">if</span>(<span class="variable">$_</span>.Extension <span class="nomarkup">-ne</span> <span class="string">""</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">switch</span>(<span class="variable">$_</span>.Extension.tolower())</div><div class="line">        &#123;</div><div class="line">            <span class="string">".ps1"</span> &#123;<span class="string">"脚本文件："</span>+ <span class="variable">$ele</span>.name&#125;</div><div class="line">            <span class="string">".txt"</span> &#123;<span class="string">"文本文件："</span>+ <span class="variable">$ele</span>.Name&#125;</div><div class="line">            <span class="string">".gz"</span>  &#123;<span class="string">"压缩文件："</span>+ <span class="variable">$ele</span>.Name&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">end</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">Write-Host</span> <span class="string">"管道脚本环境恢复"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件查找操作</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 支持正则表达式</span></div><div class="line">Dir <span class="variable">$home</span> -include [a-f]*.ps1 -recurse</div><div class="line"><span class="comment"># 具体为当你的过滤条件没有正则表达式时，使用-filter，可以显著提高效率。</span></div><div class="line">Dir <span class="variable">$home</span> -recurse | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.length <span class="nomarkup">-gt</span> <span class="number">100</span>MB &#125;</div><div class="line"><span class="comment"># 获取目录下的文件 Get-Childitem dir</span></div><div class="line"><span class="comment"># 获取文件 get-item</span></div></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$CurrentyDir</span> = <span class="built_in">Split-Path</span> -Parent <span class="variable">$MyInvocation</span>.MyCommand.Definition;</div><div class="line"><span class="variable">$parentDir</span> = (<span class="built_in">get-item</span> <span class="variable">$CurrentyDir</span> ).parent.FullName</div><div class="line">echo <span class="variable">$parentDir</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;powershell交互式&quot;&gt;&lt;a href=&quot;#powershell交互式&quot; class=&quot;headerlink&quot; title=&quot;powershell交互式&quot;&gt;&lt;/a&gt;powershell交互式&lt;/h2&gt;&lt;h3 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; cla
    
    </summary>
    
      <category term="shell学习笔记" scheme="https://caixueyuan.github.io/categories/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="shell" scheme="https://caixueyuan.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>C++高级知识</title>
    <link href="https://caixueyuan.github.io/2019/09/04/C-%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2019/09/04/C-高级知识/</id>
    <published>2019-09-03T16:03:59.000Z</published>
    <updated>2019-10-23T16:28:45.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p><strong>概念解析</strong></p>
<p>1，隐式实例化:声明一个或者多个对象，指出所需要的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;T1,T2&gt;</span></div><div class="line">&#123;</div><div class="line">	T1 t1;</div><div class="line">	T2 t2;</div><div class="line">&#125;</div><div class="line">ArrayTP&lt;<span class="keyword">int</span>,<span class="number">100</span>&gt; stuff;<span class="comment">//隐式实例化</span></div></pre></td></tr></table></figure>
<p>2，显式实例化：当使用关键字template并指出所需类型来声明类是，将生成类声明的显性实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span>&lt;string,100&gt;;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，没有创建或提及类对象，但是编译器将生成类声明</p>
<p>3，显式具体化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedArray</span></span></div><div class="line">&#123;  </div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">SortedArray</span>&lt;const char *&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//显式具体化</span></div><div class="line">&#125;;</div><div class="line">SortedArray&lt;<span class="keyword">int</span>&gt; scores;<span class="comment">//使用第一个</span></div><div class="line">SortedArray&lt;con <span class="keyword">char</span> *&gt; detes;<span class="comment">//使用第二个</span></div></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">marm</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">//标志marm不抛出任何错误</span></div><div class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)<span class="keyword">int</span>;<span class="comment">//如果出现分配内存失败不会报错误，而是返回空指针</span></div></pre></td></tr></table></figure>
<p>引发异常时总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。基类引用可以执行派生类对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类模板&quot;&gt;&lt;a href=&quot;#类模板&quot; class=&quot;headerlink&quot; title=&quot;类模板&quot;&gt;&lt;/a&gt;类模板&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，隐式实例化:声明一个或者多个对象，指出所需要的类型&lt;/p&gt;
&lt;figu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="https://caixueyuan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类的使用</title>
    <link href="https://caixueyuan.github.io/2019/08/08/C-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2019/08/08/C-类的使用/</id>
    <published>2019-08-08T15:22:58.000Z</published>
    <updated>2019-08-11T16:57:58.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h2><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p><img src="调用复制构造函数.png" alt="1565278116357"></p>
<p>复制构造函数是要通过复制类来实现新建类。</p>
<p><strong>默认的复制构造函数是浅复制，也就是只复制字面性变量，不复制指针类型，所以这里一定要注意一种错误，就是容易导致多个变量析构同一块内存导致报错误。</strong></p>
<p><img src="复制构造函数.png" alt="1565277907579"></p>
<p>上图为深复制，也就是对于指针类型所指定的对象也能够实现复制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> StringBad temp)</span></span>;<span class="comment">//这样的传值函数也是使用传值，也就是要变成</span></div><div class="line">StringBad input;</div><div class="line">show(input);<span class="comment">//void show()&#123; StringBad temp = input;&#125;调用了复制构造函数</span></div></pre></td></tr></table></figure>
<h3 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">"message"</span>)</span></span>;</div><div class="line">StringBad knot;</div><div class="line">knot = headline1;<span class="comment">//这里使用的是赋值构造函数，因为对于knot已经进行初始化，已经有一块内存啦，只是将headline1的内容赋值给knot内存而已</span></div><div class="line">StringBad metto = knot;<span class="comment">//对于这里，metto本身是没有内存的，所以这个时候需要初始化一块内存出来，所以这里使用的是复制构造函数，复制一块内存来构造对象</span></div><div class="line">StringBad &amp; StringBad::<span class="keyword">operator</span>=(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个引用，赋值构造函数</span></div><div class="line">StringBad::StringBad(<span class="keyword">const</span> StringBad &amp;);<span class="comment">//返回一个对象，是复制构造函数</span></div></pre></td></tr></table></figure>
<p><strong>复制构造函数</strong>：返回一个对象，也就是一块内存</p>
<p><strong>赋值构造函数</strong>：返回一个引用，并没有多出一块内存，只是将旧内存赋值给新内存而已</p>
<h3 id="使用复制构造函数和赋值析构函数的时机"><a href="#使用复制构造函数和赋值析构函数的时机" class="headerlink" title="使用复制构造函数和赋值析构函数的时机"></a>使用复制构造函数和赋值析构函数的时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Star sirius;</div><div class="line">Star copy = sirius;<span class="comment">//复制构造函数</span></div><div class="line">Star assignment;</div><div class="line">assignment = sirius;<span class="comment">//赋值构造函数</span></div></pre></td></tr></table></figure>
<p><code>Star copy = sirius;</code>这里是由于类没有被初始化，所以需要new出来一个对象，这个时候需要调用复制构造函数</p>
<p><code>assignment = sirius;</code>这里是因为类已经被初始化，内存空间已经存在，只是将其他对象的值复制到当前对象中，所以这个时候调用的是赋值构造函数</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>如果要把临时对象返回，要返回对象而不是引用或者指针。因为临时对象会被析构</li>
<li>new和delete对应，new[] 和 delete[]，一定要注意，delete[] 是delete多对象，包含了char * temp = “abc”这种情况</li>
</ol>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><h3 id="派生类的调用"><a href="#派生类的调用" class="headerlink" title="派生类的调用"></a>派生类的调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tabtenn1.h -- a table-tennis base class</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="comment">// simple base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> firstname;</div><div class="line">    <span class="built_in">string</span> lastname;</div><div class="line">    <span class="keyword">bool</span> hasTable;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TableTennisPlayer (<span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// simple derived class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    RatedPlayer (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> <span class="built_in">string</span> &amp; fn = <span class="string">"none"</span>,</div><div class="line">                 <span class="keyword">const</span> <span class="built_in">string</span> &amp; ln = <span class="string">"none"</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</div><div class="line">    RatedPlayer(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123;rating = r;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">TableTennisPlayer parent;</div><div class="line">parent.Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer son;</div><div class="line">son.Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//对于引用和指针都是一样的情况，只会根据静态类型来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">RatedPlayer *son1 = <span class="keyword">new</span> RatedPlayer();</div><div class="line">son1-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div><div class="line"></div><div class="line"><span class="comment">//如果对于父类的Name函数的定义为virtual void Name() const;会根据类的动态类型（实际类型）来调用函数</span></div><div class="line">TableTennisPlayer *parent = <span class="keyword">new</span> TableTennisPlayer();</div><div class="line">TableTennisPlayer *son = <span class="keyword">new</span> RatedPlayer();</div><div class="line">parent-&gt;Name();<span class="comment">//调用父类的Name()函数</span></div><div class="line">son-&gt;Name();<span class="comment">//调用子类的Name()函数</span></div></pre></td></tr></table></figure>
<ol>
<li><strong>如果是对象的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果是引用或者指针的话，那么将根据对象的声明类型来调用函数</strong></li>
<li><strong>如果使用virtual的话，将根据指针或者引用所对应的实际类型来调用函数</strong></li>
</ol>
<h3 id="继承中基类和派生类："><a href="#继承中基类和派生类：" class="headerlink" title="继承中基类和派生类："></a>继承中基类和派生类：</h3><p>构造函数不能够为虚函数，而析构函数应是虚函数，除非类不能够做基类。基类要保证基类中的成员变量能够被正常析构，派生类也要保证派生类中的成员变量能够被正常析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * base1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Base()&#123;<span class="keyword">delete</span>[] base1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * derived1;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    ~Derived()&#123;<span class="keyword">delete</span>[] derived1;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//基类要保证基类的成员变量被析构，派生类要保证派生类中的成员变量被析构</span></div></pre></td></tr></table></figure>
<p>在派生类中定义类的话，要确定是使用父类还是子类的函数，通过作用域来进行获取。</p>
<p>最好要对类数据成员采用私有访问控制private，不要使用保护控制控制protected，同时通过基类方法使得派生类能够访问到基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//最好使用这一种</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> base1;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBase1</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> base1;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>友元函数并非是类的成员函数，不能够被继承</strong></p>
<h3 id="什么样的成员变量要被析构掉"><a href="#什么样的成员变量要被析构掉" class="headerlink" title="什么样的成员变量要被析构掉"></a>什么样的成员变量要被析构掉</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span> * label;</div><div class="line">    <span class="keyword">char</span> message[<span class="number">100</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>成员变量label是指针，其对象是被new出来的，指针所指的对象是在堆中，需要被析构掉</p>
<p>成员变量message是数组，其对象不是被new出来的，对象所存在的内存空间是在栈中，不需要被析构，可以被C++自动析构掉。</p>
<h3 id="派生类的使用"><a href="#派生类的使用" class="headerlink" title="派生类的使用"></a>派生类的使用</h3><p><strong>当初始化列表包含多个项目时，这些项目的初始化顺序时跟类的声明顺序保持一致，而不是在初始化列表中的顺序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> m_a;</div><div class="line">    <span class="keyword">int</span> m_b;</div><div class="line">    <span class="keyword">int</span> m_c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Base(<span class="keyword">int</span> a,<span class="keyword">int</span> c,<span class="keyword">int</span> b):m_c(c),m_b(b),m_a(a)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用using来重新定义访问权限</strong></p>
<p>在访问基类的成员函数时，我们需要使用<code>std::valarray&lt;double&gt;::min()</code>来调用基类的成员函数的，但是如果我们使用了using来将基类的成员函数引入到派生类中，这样我们可以像使用派生类的成员函数一样使用基类的成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="keyword">operator</span>[];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用using的方式将基类的成员函数引入到当前类中，这样就能够像使用当前类的成语函数一样去使用基类的成员函数</p>
<h3 id="类的静态成员变量或者静态成语函数"><a href="#类的静态成员变量或者静态成语函数" class="headerlink" title="类的静态成员变量或者静态成语函数"></a>类的静态成员变量或者静态成语函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> Base::a = <span class="number">1</span>;<span class="comment">//正确，初始化类的静态成员变量的时候不需要考虑访问权限</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; Base::a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//错误，访问静态成员变量的时候还是要考虑访问权限的</span></div></pre></td></tr></table></figure>
<ol>
<li>不能通过类名来调用类的非静态成员函数</li>
<li>类的对象能够使用静态成员函数和非静态成员函数</li>
<li>静态成员函数不能够引用非静态成员函数</li>
<li>类的非静态成员函数可以调用静态成员函数</li>
</ol>
<p><strong>原因：</strong></p>
<p>首先，类的静态函数是属于类的，类在没有初始化的时候就应该有的，所以类的静态函数不能够引用类的非静态成员函数，因为在类未初始化之前还没有非静态成员函数，如果调用非静态成员就会报错</p>
<p>类的非静态成员函数在调用时，这时类的静态成员函数早已经可用啦，所以能够调用</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&#123;</span>&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;<span class="comment">//会报错误</span></div><div class="line"></div><div class="line"><span class="comment">//使用虚继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span><span class="keyword">public</span> Singer,<span class="keyword">public</span> Waiter&#123;&#125;</div><div class="line"><span class="comment">//构造函数</span></div><div class="line">SingerWaiter::SingerWaiter(<span class="keyword">const</span> Worker &amp;wt):Worker(wt),Singer(wt),Waiter(wt)&#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>报错误的原因</strong>：</p>
<p>如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例，也就是说从Singer和Waiter两个基类中继承了两个Worker，多个基类实例都是问题</p>
<p><strong>采用虚继承</strong>：</p>
<p>有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数</p>
<p>通过优先规则来解决二义性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类和动态内存分配&quot;&gt;&lt;a href=&quot;#类和动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;类和动态内存分配&quot;&gt;&lt;/a&gt;类和动态内存分配&lt;/h2&gt;&lt;h3 id=&quot;复制构造函数&quot;&gt;&lt;a href=&quot;#复制构造函数&quot; class=&quot;headerli
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础命令</title>
    <link href="https://caixueyuan.github.io/2019/08/06/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://caixueyuan.github.io/2019/08/06/Linux基础命令/</id>
    <published>2019-08-05T16:23:23.000Z</published>
    <updated>2019-08-29T16:58:49.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux用户管理"><a href="#linux用户管理" class="headerlink" title="linux用户管理"></a>linux用户管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">新增用户</span></div><div class="line">useradd -m cxy -d /home/cxy -g group -u uid</div><div class="line"><span class="meta">#</span><span class="bash">修改用户的根目录</span></div><div class="line">usermod -d /home/cxy_new -m cxy</div><div class="line"><span class="meta">#</span><span class="bash">锁住用户</span></div><div class="line">usermod -L cxy</div><div class="line"><span class="meta">#</span><span class="bash">解锁用户</span></div><div class="line">usermod -U cxy</div><div class="line"><span class="meta">#</span><span class="bash">删除用户</span></div><div class="line">userdel cxy</div><div class="line"><span class="meta">#</span><span class="bash">添加用户组</span></div><div class="line">groupadd group1</div><div class="line"><span class="meta">#</span><span class="bash">删除用户组</span></div><div class="line">groupdel group1</div><div class="line"><span class="meta">#</span><span class="bash">查看用户的详细信息</span></div><div class="line">w</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash">查看定时任务后台程序是否启动</span></div><div class="line">systemctl | grep cron</div><div class="line">systemctl | grep crond</div><div class="line"><span class="meta">#</span><span class="bash">将定时任务加入到前台程序中</span></div><div class="line">crontab job1.cron</div><div class="line"><span class="meta">#</span><span class="bash">查看程序中的定时任务</span></div><div class="line">crontab -l</div><div class="line"><span class="meta">#</span><span class="bash">查看程序中的定时任务</span></div><div class="line">crontab -r</div><div class="line"><span class="meta">#</span><span class="bash">只能够有一个定时任务</span></div></pre></td></tr></table></figure>
<h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看目录下所有问题，包括隐藏文件</span></div><div class="line">ls -la</div><div class="line"><span class="meta">#</span><span class="bash">加上-n参数可以显示每行的行数</span></div><div class="line">cat -n file.log</div><div class="line"><span class="meta">#</span><span class="bash">查看文件的头20行</span></div><div class="line">head -n 20 file.log</div><div class="line"><span class="meta">#</span><span class="bash">查看文件的尾20行</span></div><div class="line">tail -n 20 file.log</div><div class="line"><span class="meta">#</span><span class="bash">动态查看文件的尾部10行</span></div><div class="line">tail -f file.log</div><div class="line"><span class="meta">#</span><span class="bash">将window文件转换为linux文件</span></div><div class="line">dos2unix file.log</div><div class="line"><span class="meta">#</span><span class="bash">创建目录</span></div><div class="line">mkdir -p /opt/oss/caixueyuan</div></pre></td></tr></table></figure>
<h3 id="文件和目录的权限"><a href="#文件和目录的权限" class="headerlink" title="文件和目录的权限"></a>文件和目录的权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">设置文件为隐藏文件</span></div><div class="line">chattr +a a.log</div><div class="line"><span class="meta">#</span><span class="bash">设置文件为非隐藏文件</span></div><div class="line">chattr -a a.log</div><div class="line"><span class="meta">#</span><span class="bash">设置SUID权限，这样普通用户可以使用root的身份来执行这个命令</span></div><div class="line">chmod u+s filename</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">which</span>用于从系统的PATH变量所定义的目录中查找可执行文件的绝对路径</span></div><div class="line">which filename</div><div class="line"><span class="meta">#</span><span class="bash">whereis用于从系统的PATH变量所定义的目录中查找二进制文件和man文件</span></div><div class="line">whereis filename</div><div class="line"><span class="meta">#</span><span class="bash">指定解压后的位置</span></div><div class="line">tar -zxvf boot.tgz -C /tmp</div></pre></td></tr></table></figure>
<p><strong>find命令</strong></p>
<p><img src="find.png" alt="1565195424826"></p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统包括</p>
<ol>
<li>超级块：文件系统的总体信息，是文件系统的核心，有多个超级块，以防止由于磁盘出现坏块导致全部文件系统无法使用</li>
<li>inode：存储所有与文件有关的元数据，也就是文件所有者，权限等属性数据以及指向的数据块</li>
<li>数据块：真实存放文件数据的部分</li>
<li>目录块：包括文件名和文件在目录中的位置，并包括文件的inode信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">进行磁盘划分</span></div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span><span class="bash">格式化磁盘,</span></div><div class="line">mkfs -t ext3 /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">将DEVICE挂载到DEVICE_POINT上</span></div><div class="line">mount DEVICE DEVICE_POINT</div><div class="line">mount /dev/sdb1 newDirectory</div><div class="line"><span class="meta">#</span><span class="bash">查看可用空间</span></div><div class="line">df -h | grep sdb1</div><div class="line"><span class="meta">#</span><span class="bash">设置启动自动挂载/etc/fstab</span></div><div class="line">echo "/dev/sdb1 /root/newDisk ext3 default 0 0" &gt;&gt; /etc/fstab</div><div class="line"><span class="meta">#</span><span class="bash">检查修复磁盘出现逻辑错误，要保证磁盘为未挂载的状态</span></div><div class="line">fsck -t ext4 /dev/sda8</div><div class="line"><span class="meta">#</span><span class="bash">卸载磁盘</span></div><div class="line">unmount /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">检查磁盘的物理坏道</span></div><div class="line">badblocks -v /dev/sdb1</div></pre></td></tr></table></figure>
<p>将一块磁盘挂载到操作系统的步骤：先对磁盘进行划分，将磁盘格式化，刷进去文件系统，然后将磁盘挂载到操作系统中，然后将挂载操作设置为开机自启动</p>
<h3 id="逻辑卷（Logic-Volume-Manager）"><a href="#逻辑卷（Logic-Volume-Manager）" class="headerlink" title="逻辑卷（Logic Volume Manager）"></a>逻辑卷（Logic Volume Manager）</h3><p><strong>LVM</strong>是介于硬盘裸设备和文件系统的中间层</p>
<ol>
<li><strong>物理卷（Physical Volumn,PV)</strong>：物理磁盘分区，比如/dev/sdb1</li>
<li><strong>卷组（Volumn Group,VG)</strong>:PV的集合</li>
<li><strong>逻辑卷（Logic Volume,LV)</strong>:PV中划出来的一块逻辑磁盘</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">创建物理卷pvcreate,pvdisplay</span></div><div class="line">fdisk -l</div><div class="line">fdisk /dev/sdb  n</div><div class="line"><span class="meta">#</span><span class="bash">设置物理卷的Id为8e</span></div><div class="line">fdisk /dev/sdb</div><div class="line"><span class="meta">#</span><span class="bash">现在已经有磁盘，从磁盘创建出物理卷</span></div><div class="line">pvcreate /dev/sdb1</div><div class="line"><span class="meta">#</span><span class="bash">将逻辑卷组成一个物理卷组</span></div><div class="line">vgcreate First_LV /dev/sdb1 /dev/sdb2</div><div class="line"><span class="meta">#</span><span class="bash">扩展物理卷组，加入一个新的物理卷</span></div><div class="line">pvextend First_LV /dev/sdb3</div><div class="line"><span class="meta">#</span><span class="bash">创建逻辑卷lvcreate</span></div><div class="line">lvcreate -L 100M -n sdb First_VG</div><div class="line"><span class="meta">#</span><span class="bash">创建文件系统</span></div><div class="line">mkfs -t ext4 /dev/First_LV/First_VG</div><div class="line"><span class="meta">#</span><span class="bash">进行挂载</span></div><div class="line">mount /dev/First_LV/First_VG /root/cxy</div></pre></td></tr></table></figure>
<p><img src="修改分区代码.png" alt="1565714641249"></p>
<h3 id="硬链接和软连接"><a href="#硬链接和软连接" class="headerlink" title="硬链接和软连接"></a>硬链接和软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看文件的说明</span></div><div class="line">ls -li</div><div class="line"><span class="meta">#</span><span class="bash">创建硬链接</span></div><div class="line">ln file.txt file.hard_txt</div><div class="line"><span class="meta">#</span><span class="bash">创建软连接</span></div><div class="line">ln -s file.txt file.soft_txt</div></pre></td></tr></table></figure>
<p><img src="硬链接.png" alt="1565885043739"></p>
<p>该详细信息中的第三列中的<strong>2</strong>的意思为源文件的关联个数，也就是该文件所包含的硬链接的个数</p>
<p><strong>硬链接</strong>:通过索引节点来链接，一个文件可以有多个文件名，多个文件名指向同一个inode是可以的</p>
<p><strong>软连接</strong>：是一个包含了另外一个文件路径名的文件，可以指向任意文件或者目录，可以跨不同的文件系统</p>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><p>固定大小的缓存，缓存的大小为4KByte。符号为”|”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/init.d | more</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">grep [-ivnc] <span class="string">'需要匹配的字符'</span> 文件名</span></div><div class="line"><span class="meta">#</span><span class="bash">-i不区分大小写</span></div><div class="line"><span class="meta">#</span><span class="bash">-v反向查找</span></div><div class="line"><span class="meta">#</span><span class="bash">-n查找并获取行号</span></div><div class="line"><span class="meta">#</span><span class="bash">-c统计需要匹配的字符的个数</span></div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">sort [-ntkr] 文件名</span></div><div class="line"><span class="meta">#</span><span class="bash">-n按照数字来排列，而不是按照字符，默认是按照字符</span></div><div class="line"><span class="meta">#</span><span class="bash">-t指定分隔符grep -t <span class="string">":"</span> -k 2 file.txt</span></div><div class="line"><span class="meta">#</span><span class="bash">-k指定是按照第几列来排序</span></div><div class="line"><span class="meta">#</span><span class="bash">-r反向排序</span></div><div class="line">grep -t ":" -k 2 file.txt</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">uniq [-ic]</span></div><div class="line"><span class="meta">#</span><span class="bash">-i忽略大小写</span></div><div class="line"><span class="meta">#</span><span class="bash">-c统计不同字符的个数</span></div><div class="line">cat file.txt | sort | uniq -c</div></pre></td></tr></table></figure>
<p>使用uniq一般情况下都是跟sort进行使用，因为uniq只会比较跟相邻位置的字符是否相同</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">cut -f指定的列 -d <span class="string">'分隔符'</span></span></div><div class="line"><span class="meta">#</span><span class="bash">查看file.txt文件，以:为分隔符，获取第1，6和7列</span></div><div class="line">cat file.txt | cut -f1,6-7 -d ':'</div><div class="line"><span class="meta">#</span><span class="bash">查看file.txt文件，获取第1-5个字符和第7-10个字符</span></div><div class="line">cat file.txt | cut -c1-5,7-10</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">tr命令使用</span></div><div class="line"><span class="meta">#</span><span class="bash">小写转为大小</span></div><div class="line">cat file.txt | tr '[a-z]' '[A-Z]'</div><div class="line"><span class="meta">#</span><span class="bash">删除字符:</span></div><div class="line">cat file.txt | tr -d ':'</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">paste合并文件</span></div><div class="line"><span class="meta">#</span><span class="bash">将1.txt和2.txt文件按照行进行合并，中间用tab分割</span></div><div class="line">paste 1.txt 2.txt</div><div class="line">paste 1.txt 2.txt -d :</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">split分割文件</span></div><div class="line"><span class="meta">#</span><span class="bash">以500行为一个文件进行分割</span></div><div class="line">split -l 500 big.txt small_file_</div><div class="line"><span class="meta">#</span><span class="bash">以大小进行划分</span></div><div class="line">split -b 64M big.bin small_file_</div></pre></td></tr></table></figure>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">查看和设置网络网卡</span></div><div class="line">ifconfig</div><div class="line"><span class="meta">#</span><span class="bash">启停网卡</span></div><div class="line">ifup eth0</div><div class="line">ifdown eth0</div><div class="line">ifconfig eth0 down</div><div class="line">ifconfig eth0 up</div><div class="line"><span class="meta">#</span><span class="bash">重启网络服务</span></div><div class="line">service network restart</div><div class="line"><span class="meta">#</span><span class="bash">查看系统当前的路由</span></div><div class="line">route -n</div><div class="line"><span class="meta">#</span><span class="bash">traceroute查看请求所经过的路由器的路径</span></div><div class="line">traceroute 14.215.177.38</div></pre></td></tr></table></figure>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">ps </span></div><div class="line"><span class="meta">#</span><span class="bash">-A 列出所有的进程</span></div><div class="line"><span class="meta">#</span><span class="bash">-a 列出不和本终端有关的所有进程</span></div><div class="line"><span class="meta">#</span><span class="bash">-aux显示所有其他包含其他使用者的进程</span></div><div class="line"><span class="meta">#</span><span class="bash">RSS 显示进程占用的内存的大小</span></div><div class="line"><span class="meta">#</span><span class="bash">VSZ 显示进程占用的虚拟内存的大小</span></div><div class="line"><span class="meta">#</span><span class="bash">查看进程号</span></div><div class="line">pidof Nemgr</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">kill</span></span></div><div class="line">kill -9 1001#强制停止进程，并没有释放内存</div><div class="line">kill -15 1001#使进程正常退出</div><div class="line"><span class="meta">#</span><span class="bash">lsof 查看进程打开的文件</span></div><div class="line">lsof -p pid</div><div class="line">lsof -i:22</div><div class="line"><span class="meta">#</span><span class="bash">nice，renice修改进程的优先级</span></div><div class="line">nice -n -10 ./run.sh</div><div class="line">renice -10 -p pid</div></pre></td></tr></table></figure>
<p><img src="top.png" alt="1566142036437"></p>
<p><img src="top1.png" alt="1566142284292"></p>
<h2 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h2><p><img src="/rpm.png" alt="1566144649678"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">rpm安装软件</span></div><div class="line">rpm -ivh packege.rpm</div><div class="line"><span class="meta">#</span><span class="bash">安装软件包，并重新定义安装路径</span></div><div class="line">rpm -ivh --relocate /=/usr/local/package_name package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">升级软件包</span></div><div class="line">rpm -Uvh package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">删除软件</span></div><div class="line">rpm -e package_name --nodeps</div><div class="line"><span class="meta">#</span><span class="bash">查看系统中所有已经安装的包</span></div><div class="line">rpm -qa</div><div class="line"><span class="meta">#</span><span class="bash">查看某个包的依赖关系</span></div><div class="line">rpm -qpR package_name-version.rpm</div><div class="line"><span class="meta">#</span><span class="bash">yum安装操作</span></div><div class="line">yum install package</div><div class="line"><span class="meta">#</span><span class="bash">更新系统中所有需要更新的包</span></div><div class="line">yum update</div><div class="line"><span class="meta">#</span><span class="bash">查找操作</span></div><div class="line">yum list</div><div class="line">yum list installed</div><div class="line">yum info package</div><div class="line"><span class="meta">#</span><span class="bash">删除操作</span></div><div class="line">yum remove package</div><div class="line"><span class="meta">#</span><span class="bash">清除操作</span></div><div class="line">yum clean</div><div class="line">yum clean all &amp;&amp; yum makecache</div></pre></td></tr></table></figure>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shift+$</td>
<td>到当前行的末尾</td>
</tr>
<tr>
<td>u</td>
<td>撤销操作</td>
</tr>
<tr>
<td>:n</td>
<td>跳转到第n行</td>
</tr>
<tr>
<td>p</td>
<td>黏贴</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做操作</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
</tbody>
</table>
<p><img src="替换用法.png" alt="1566146582848"></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li>“.”：除换行符之外的任意一个字符</li>
<li>*:用来匹配前一个字符0次或者任意多次，.*用来匹配任意长度的不包含换行的字符</li>
<li>{n,m}:重复匹配前一个字符n-m次</li>
<li>^或$:开始和结束的标识</li>
<li>[]:用来匹配方括号内出现的任一个字符</li>
<li>\：转义字符</li>
<li>\&lt;和\&gt;:用于界定单词的左边界和右边界，比如\bhelloy用来匹配以hello开头的单词</li>
<li>\d:用来匹配数字</li>
<li>\b:匹配单词的边界</li>
<li>\B:匹配非单词的边界</li>
<li>\w:匹配数字，字母和下划线，”\W”：\w的取反</li>
<li>\s:匹配任何空白字符，”\S”：匹配任何非空白字符</li>
</ol>
<p><strong>通配符</strong>：</p>
<ol>
<li>?:用来匹配一个字符</li>
<li>{}:用来匹配所有括号内包含的以逗号隔开的字符</li>
<li>^或者!:用来取反</li>
</ol>
<p><strong>POSIX字符</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">[:alnum:]	文本数字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:alpha:]	文字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:digit:]	数字字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:graph:]	非空字符（非空格，控制字符）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:lower:]	小写字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:ctrl:]	控制字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:<span class="built_in">print</span>:]	非空字符（包括空格）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:punct:]	标点符号</span></div><div class="line"><span class="meta">#</span><span class="bash">[:space:]	所有空白字符（新行，空行，制表符）</span></div><div class="line"><span class="meta">#</span><span class="bash">[:upper:]	大写字符</span></div><div class="line"><span class="meta">#</span><span class="bash">[:xdigit:]	十六进制数字（0-9,a<span class="_">-f</span>,A-F）</span></div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">echo "helloworld" | grep "hello\B"#helloworld</div><div class="line">echo "helloworld" | grep "hello\b"#返回空值</div><div class="line">^0[0-9]\&#123;2,3\&#125;( |-)[0-9]\&#123;8\&#125; = ^0[0-9]\&#123;2,3\&#125;[\ \-][0-9]\&#123;8\&#125;#这两种是等价的</div><div class="line">grep -ivc "good" a.log#查找不包含good的行数</div><div class="line">grep -c '^$' a.log#匹配空行</div></pre></td></tr></table></figure>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed<strong>是对于每行进行处理的</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">语句1等价与语句2</span></div><div class="line">sed -e 's/hello/HELLO/g;s/abc/ABC/g' a.txt</div><div class="line">sed -e 's/hello/HELLO/g' -e "s/abc/ABC/g" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">在原文件中删除最后一行</span></div><div class="line">sed -i "$d" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">删除所有的空行</span></div><div class="line">sed "/^$/d" a.txt</div><div class="line"><span class="meta">#</span><span class="bash">将每一行以this开头的this替换成that</span></div><div class="line">sed 's/^this/that/' a.log</div><div class="line"><span class="meta">#</span><span class="bash">将每一行的1，2,3转换成A,B,C</span></div><div class="line">sed 'y/123/ABC' a.log</div><div class="line"><span class="meta">#</span><span class="bash">使用i的话，在第2行的上一行插入Insert，第2行插入后变成第3行</span></div><div class="line"><span class="meta">#</span><span class="bash">使用a的话，在第2行的后一行插入Insert，也就是在第三行新增一行插入Insert</span></div><div class="line">sed "2 i Insert" a.log</div><div class="line"><span class="meta">#</span><span class="bash">在空行的后面加上另外一个文件的内容</span></div><div class="line">sed '/^$/r /etc/passwd' Sed.txt</div><div class="line"><span class="meta">#</span><span class="bash">打印实际处理的行</span></div><div class="line">sed -n 's/the/THE/p' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">将sed的结果重定向到output文件中</span></div><div class="line">sed -n '1,2 w output' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">指定需要做的操作</span></div><div class="line">sed -f Sed.rules a.txt</div></pre></td></tr></table></figure>
<p><img src="sed1.png" alt="1566406358092"></p>
<p><img src="sed2.png" alt="1566406376244"></p>
<p><img src="sed3.png" alt="1566406401384"></p>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>作用：是对每一列进行处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk -F . '&#123;print $1,$2&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取每一列的列数</span></div><div class="line">awk -F . '&#123;print NF&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取倒数第二列的值</span></div><div class="line">awk -F . '&#123;print $(NF-1)&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取第一列的第6个字符到最后</span></div><div class="line">awk -F . '&#123;print substr($1,6)&#125;' a.txt</div><div class="line"><span class="meta">#</span><span class="bash">获取每一列的长度</span></div><div class="line">awk '&#123;print length&#125;' a.txt</div></pre></td></tr></table></figure>
<h2 id="shell编程概述"><a href="#shell编程概述" class="headerlink" title="shell编程概述"></a>shell编程概述</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">type cd #判断命令是不是内置命令</div><div class="line">alias myShutdown='shutdown -h now'#设置命令的别名</div><div class="line">unalias myShutdown #取消别名</div><div class="line">jobs #查看暂停的任务</div><div class="line">bg 1 #将任务放在后台运行</div><div class="line">fg 1 #将任务放在前台运行</div><div class="line">declare -i num=1 #定义变量num的类型为整形</div><div class="line">declare -r readonly=1 #定义变量readonly为只读</div><div class="line">declare -a arr='&#123;([0]='a' [1]='b' [2]='c''')&#125;' #定义变量</div><div class="line">declare -F #显示脚本定义的函数</div><div class="line">declare -f #显示脚本定义的函数体</div><div class="line">break n #跳出n层循环</div><div class="line">continue n #continue2层循环</div><div class="line">eval $cmd #将所跟的参数作为shell的输入，并执行产生的命令</div><div class="line">find ./ -name *.sh -exec ls -l &#123;&#125; \;</div><div class="line">export value=1 #当前shell和子shell能够获取得到变量</div><div class="line">pwd -P #显示真实路径，而不是软连接命令</div><div class="line">local #局部变量，只能够在函数内声明和使用</div><div class="line">read n #从控制台获取变量</div><div class="line">ulimit -n 4094 #设置打开的文件的最大个数</div><div class="line">cat /etc/security/limits.conf #设置打开文件的最大个数等限制</div></pre></td></tr></table></figure>
<p><img src="输入参数1.png" alt="1566578135477"></p>
<p><img src="输入参数2.png" alt="1566578169261"></p>
<h2 id="shell基础编程"><a href="#shell基础编程" class="headerlink" title="shell基础编程"></a>shell基础编程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">echo $EUID #获取用户的UID</div><div class="line">echo $FUNCNAME #获取函数的名字</div><div class="line">echo $HISTFILE #获取输入历史记录中的文件</div><div class="line">echo $HISTFILESIZE #存储历史记录的文件的最大条数</div><div class="line">echo $HOSTNAME #主机的名字</div><div class="line">echo $HOSTTYPE #显示是x86还是ARM</div><div class="line">echo $MACHTYPE #显示主机的GNU标识</div><div class="line">echo $LANG #显示当前环境的语言环境</div><div class="line">echo $PWD #显示当前路径</div><div class="line">echo $OLDPWD #显示上一个路径</div><div class="line">echo $PATH #显示环境变量</div></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">unset name #取消变量</div><div class="line"><span class="meta">$</span><span class="bash">@  $* <span class="comment">#位置参数 </span></span></div><div class="line">declare -a Array;#声明索引数组</div><div class="line">echo $&#123;#Array[@]&#125; #获取索引元素的长度</div><div class="line">Conn=($&#123;Array[@]&#125; $&#123;Array[@]&#125;) #连接数组</div><div class="line">Conn=($&#123;Array[@]/helloworld/helloworld2&#125;) #将数组中的元素中有helloworld替换成helloworld2</div><div class="line">unset Conn[1] #取消数组中第1个元素</div><div class="line">readonly RO=100 #只读变量，不能够修改</div></pre></td></tr></table></figure>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><strong>部分引用</strong>：双引号，在双引号里面，$，反引号，转义符这3中特殊字符依然会被解析成特殊意义</li>
<li><strong>全引用</strong>：单引号中的任何字符都是作为普通字符</li>
<li><strong>命令替换</strong>：将命令的标准输出作为值赋给某个变量。反引号等价于$()</li>
</ol>
<p>$[]和$(())类似，可用于简单的算术运算。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo $[1+1] #输出2</div><div class="line">expr 2 \* 2 #输出4</div><div class="line">declare -i J #声明整数</div></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ol>
<li>*:任意长度的字符串，不包含点号和斜线号</li>
<li>?:匹配单个字符</li>
<li>[]:匹配其中的任意一个字符。*和？在[]中则变成了普通字符，没有通配的功效</li>
</ol>
<p><img src="变量扩展.png" alt="1566838063691"></p>
<p><img src="位置参数.png" alt="1566838175259"></p>
<h2 id="测试和判断"><a href="#测试和判断" class="headerlink" title="测试和判断"></a>测试和判断</h2><p>测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">判断文件是否存在</span></div><div class="line">if [ ! -e filename ]; then</div><div class="line">	echo "the $filename is not exists"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">判断字符串是否相等</span></div><div class="line">if [ "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "the $str1 is big"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">判断数字是否相等</span></div><div class="line">if [ "$num1" -lt "$num2" ]; then</div><div class="line">	echo "the $num1 is small"</div><div class="line">fi</div><div class="line">if [ "$num1" -lt "$num2"] &amp;&amp; [ "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "right"</div><div class="line">fi</div><div class="line">if [ "$num1" -lt "$num2" -a "$str1" \&gt; "$str2" ]; then</div><div class="line">	echo "right"</div><div class="line">fi</div><div class="line">if [ -e $filename ]; then</div><div class="line">	echo "$filename is exists"</div><div class="line">else</div><div class="line">	echo "$filename is not exists"</div><div class="line">fi</div><div class="line">if [ "$num1" \&lt; 60 ]; then</div><div class="line">	echo "不及格"</div><div class="line">elif [ "$num1" \&lt; 80 ]; then</div><div class="line">	echo "良好"</div><div class="line">else</div><div class="line">	echo "优秀"</div><div class="line">fi</div><div class="line">OS=`uname -s`</div><div class="line">case "$OS" in </div><div class="line">FreeBSD) echo "This is FreeBSD"</div><div class="line">*) echo "This is linux"</div><div class="line">esac</div><div class="line"><span class="meta">#</span><span class="bash">输入值</span></div><div class="line">read -p "input " input</div></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">计算1-100的和</span></div><div class="line">declare -i num</div><div class="line">for i in `seq 1 100`</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 1 2 100) 计算奇数的和</span></div><div class="line">do</div><div class="line">	sum+=i</div><div class="line">done</div><div class="line">echo sum</div><div class="line"><span class="meta">#</span><span class="bash">遍历输入参数</span></div><div class="line">for VARIABLE in $@</div><div class="line">do</div><div class="line">	echo "$VARIABLE"</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash">计算1-100</span></div><div class="line">declare -i result</div><div class="line">for ((i=1;i&lt;=100;i++))</div><div class="line">do</div><div class="line">	result+=i</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>循环</span></div><div class="line">sum01=0</div><div class="line">sum02=0</div><div class="line">i=1</div><div class="line">j=1</div><div class="line">while [[ $i -le 100 ]]</div><div class="line">do</div><div class="line">	let "sum01+=i"</div><div class="line">	let "j=i%2"</div><div class="line">	if [ "$j" -ne 0 ]; then</div><div class="line">		let "sum02+=i"</div><div class="line">	fi</div><div class="line">	let "i++"</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="keyword">while</span>例子</span></div><div class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></div><div class="line">while read LINE</div><div class="line">do</div><div class="line">	NAME=`echo $LINE|awk '&#123;print $1&#125;'`</div><div class="line">	echo "$NAME"</div><div class="line">done &lt; student_info.txt</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash">!/bin/bash</span></div><div class="line">cat student_info.txt | while read LINE</div><div class="line">do</div><div class="line">	NAME=`echo $LINE|awk '&#123;print $1&#125;'`</div><div class="line">	echo "$NAME"</div><div class="line">done </div><div class="line"><span class="meta">#</span><span class="bash">until</span></div><div class="line">until [[ $i -gt 100 ]]</div><div class="line">do</div><div class="line">	echo -n $i #不换行</div><div class="line">done</div><div class="line"><span class="meta">#</span><span class="bash"><span class="built_in">break</span>和<span class="built_in">continue</span></span></div><div class="line">continue n #继续嵌套循环的嵌套数</div><div class="line">continue #继续当前循环</div></pre></td></tr></table></figure>
<p><img src="select.png" alt="1566924776979"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">返回值</span></div><div class="line">function func1()&#123;</div><div class="line">do</div><div class="line">	if [ -f $1 ]; then</div><div class="line">		return 0</div><div class="line">	else</div><div class="line">		return 1</div><div class="line">	fi</div><div class="line">done</div><div class="line">&#125;</div><div class="line">func1</div><div class="line">if [ $? -eq 0 ]; then</div><div class="line">	echo "the file $1 is exists"</div><div class="line">else</div><div class="line">	echo "the file $1 is not exists"</div><div class="line">fi</div><div class="line"><span class="meta">#</span><span class="bash">有输入值和<span class="built_in">shift</span>(列表每次推移1个元素)<span class="built_in">shift</span> 2(列表每次推移2个元素)</span></div><div class="line">function func2()&#123;</div><div class="line">until [ $# -eq 0 ]</div><div class="line">do</div><div class="line">	echo "the parameter \$1 is $1,the parameter size is $#"</div><div class="line">	shift</div><div class="line">done</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span><span class="bash">递归函数</span></div><div class="line">function factorial01()&#123;</div><div class="line">	local NUMBER=$1</div><div class="line">	if [ $NUMBER -le 0 ]; then</div><div class="line">		RES=1</div><div class="line">	else</div><div class="line">		factorial01 $((NUMBER-1))</div><div class="line">		TEMP=$RES</div><div class="line">		NUMBER=$NUMBER</div><div class="line">		RES=$((TEMP*NUMBER))</div><div class="line">	fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><img src="重定向.png" alt="1567096570598"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/passwd 2&gt;error.txt 1&gt;right.txt</div><div class="line"><span class="meta">#</span><span class="bash">标识重定向</span></div><div class="line">ls -l /etc/passwd &gt; stdout.txt 2&gt;&amp;1</div><div class="line">ls -l /etc/ &gt; stdout.txt 2&gt;/dev/null</div></pre></td></tr></table></figure>
<h3 id="使用exec"><a href="#使用exec" class="headerlink" title="使用exec"></a>使用exec</h3><p><img src="exec.png" alt="1567097045597"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">指定文件标识符</span></div><div class="line">exec 3&lt;fruit01.txt</div><div class="line">sort &lt;&amp;3</div><div class="line"><span class="meta">#</span><span class="bash">关闭文件标识符</span></div><div class="line">exec 3&lt;&amp;-</div><div class="line"><span class="meta">#</span><span class="bash">将<span class="built_in">exec</span>的输出重定向到终端中</span></div><div class="line">exec &gt;/dev/tty</div><div class="line"><span class="meta">#</span><span class="bash">&lt;&lt; END当输入END的时候，输入结束，这里是区分大小写的</span></div><div class="line">sort &lt;&lt; END</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;linux用户管理&quot;&gt;&lt;a href=&quot;#linux用户管理&quot; class=&quot;headerlink&quot; title=&quot;linux用户管理&quot;&gt;&lt;/a&gt;linux用户管理&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,命令" scheme="https://caixueyuan.github.io/tags/linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++PrimePlus第9章</title>
    <link href="https://caixueyuan.github.io/2019/08/04/C-PrimePlus%E7%AC%AC10%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/08/04/C-PrimePlus第10章/</id>
    <published>2019-08-04T03:29:08.000Z</published>
    <updated>2019-08-08T15:22:27.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><h3 id="include的使用"><a href="#include的使用" class="headerlink" title="#include的使用"></a>#include的使用</h3><ol>
<li><p><code>#include&lt;iostream&gt;</code>如果文件包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找</p>
</li>
<li><p><code>#include&quot;stdio.h&quot;</code> 如果文件是包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录，如果没有的话，则在标准位置中查找</p>
</li>
<li><p>在编码的过程中，不要使用#include一个CPP代码，会导致多重定义</p>
</li>
<li><p>尽量使用这种方式来定义头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CORRORDIN_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> CORRORDIN_H_</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h3><p><strong>概念</strong>：</p>
<ol>
<li>定义是有分配存储空间的，只能够定义一次<code>int a;</code></li>
<li>声明是引用声明，不用给变量分配存储空间，可以多次被引用<code>a=1;</code></li>
</ol>
<h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>主要分为两种：</p>
<ol>
<li>外部链接性：不只是当前文件可以使用，其他别的文件也可以引用声明到</li>
<li>内部链接性：一般都是静态变量，只能够在当前文件中使用，其他别的文件不能够引用声明到</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> external = <span class="number">10</span>;<span class="comment">//外部链接性，在当前文件中定义，其他文件如果要使用该变量，必须加上extern int external;进行引用声明</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> inside = <span class="number">11</span>;<span class="comment">//内部链接性，因为是内部链接性，只在当前的文件中起作用，不用担心跟其他文件的全局变量冲突</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count;<span class="comment">//局部变量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count1;<span class="comment">//作用域还是在该代码块中，但是呢，每次运行该代码块该变量都会一致存在，跟全局变量没啥子区别，就是声明作用域小了一些</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_number=<span class="number">0</span>;<span class="comment">//内部链接性，由const定义的变量都不是外部链接性</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> const_number1=<span class="number">10</span>;<span class="comment">//如果想使用外部链接性的const变量的话，就要加上extern进行定义。但是呢，一般情况下，如果想使用外部链接性的const变量，可以将变量定义在头文件中，然后使用#include"header.h"将变量加入到该文件中比较好</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//函数默认是外部链接性，其他文件默认就可以引用到</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//static修饰的函数为内部链接性，只能够在本文件中使用</span></div></pre></td></tr></table></figure>
<h3 id="语句链接性："><a href="#语句链接性：" class="headerlink" title="语句链接性："></a>语句链接性：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C语句获取函数描述符号去查找函数</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//使用C++语句获取函数描述符号去查找函数</span></div></pre></td></tr></table></figure>
<h3 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//这种是using编译指令</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//使用using声明</span></div><div class="line"><span class="keyword">namespace</span> MEF= <span class="built_in">std</span>;<span class="comment">//有些时候可以使用名称空间别名的方式来缩短名称空间</span></div></pre></td></tr></table></figure>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p><strong>const和mutable</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></div><div class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;<span class="comment">//可以修改，不受const的限制</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">"abc"</span>,<span class="number">1</span>&#125;;</div><div class="line">veep.name = <span class="string">""</span>;<span class="comment">//错误，不能够修改</span></div><div class="line">veep.accesses = <span class="number">1</span>;<span class="comment">//可以修改</span></div></pre></td></tr></table></figure>
<p><strong>函数搜索顺序</strong>：</p>
<p>首先是本文件，然后才是程序员编写的其他的文件，然后再是库函数。所以有些时候可以使用覆盖的方式来覆盖库函数来实现比库函数更多的功能。</p>
<p><strong>const函数</strong>：</p>
<p>void stock::show() const一般在不修改类的成员变量的时候都要将函数声明为const，这样可以起到保护类的成员变量的作用</p>
<h2 id="类的声明和使用"><a href="#类的声明和使用" class="headerlink" title="类的声明和使用"></a>类的声明和使用</h2><h3 id="作用域为类的常量的方法"><a href="#作用域为类的常量的方法" class="headerlink" title="作用域为类的常量的方法"></a>作用域为类的常量的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是错误的，因为声明只是描述对象形式，并没有创建对象，所以在创建对象之前，并没有用于存储对象的空间，而const int Months = 12;在运行的时候就需要空间进行存储空间，所以这种的对象声明是错误</p>
<p><strong>解决方法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span>&#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用这种方法声明枚举的时候并不会创建类数据成员，所有对象都不包含枚举，Months只是一个符号名称，在声明的时候不需要空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    <span class="keyword">double</span> consts[Months];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该变量将于其他静态静态变量一样，在运行的时候存放在文件中</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>A = B <em> 1.0;//可以使用成员函数来调用 `A = B.operator</em>(1.0)`</p>
<p>A = 1.0 * B;//由于1在前面，不能够使用成员函数的方式来实现，所以只能够使用非成员函数的方式来使用<code>A = operator&lt;&lt;(1.0,B)</code></p>
<p><strong>友元函数的好处</strong>：本身不是成员函数，而是一个普通函数，不属于类，而又能够跟成员函数一样访问类的内部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MyTime.h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME3_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> hours;</div><div class="line">    <span class="keyword">int</span> minutes;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Time();</div><div class="line">    Time(<span class="keyword">int</span> h, <span class="keyword">int</span> m = <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</div><div class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</div><div class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)</div><div class="line">        &#123; <span class="keyword">return</span> t * m; &#125;   <span class="comment">// inline definition</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//MyTime.cpp</span></div><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Time &amp; t)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">" minutes"</span>;</div><div class="line">    <span class="keyword">return</span> os; </div><div class="line">&#125;<span class="comment">//返回一个引用，重载运算符，第一个参数不是该成员</span></div></pre></td></tr></table></figure>
<h3 id="隐形转换和显性转换"><a href="#隐形转换和显性转换" class="headerlink" title="隐形转换和显性转换"></a>隐形转换和显性转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONEWT_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STONEWT_H_</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stonewt</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span> &#123;Lbs_per_stn = <span class="number">14</span>&#125;;      <span class="comment">// pounds per stone</span></div><div class="line">    <span class="keyword">int</span> stone;                    <span class="comment">// whole stones</span></div><div class="line">    <span class="keyword">double</span> pds_left;              <span class="comment">// fractional pounds</span></div><div class="line">    <span class="keyword">double</span> pounds;                <span class="comment">// entire weight in pounds</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Stonewt(<span class="keyword">double</span> lbs);          <span class="comment">// constructor for double pounds</span></div><div class="line">    Stonewt(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs); <span class="comment">// constructor for stone, lbs</span></div><div class="line">    Stonewt();                    <span class="comment">// default constructor</span></div><div class="line">    ~Stonewt();</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in pounds format</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>;        <span class="comment">// show weight in stone format</span></div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">Stonewt myCat;</div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//OK，类的隐形转换</span></div><div class="line"><span class="comment">//如果使用explicit来禁止隐形转换的话，也就是用explicit Stonewt(double lbs);的话</span></div><div class="line">myCat = <span class="number">19.6</span>;<span class="comment">//错误，因为禁止了隐形转换</span></div><div class="line">myCat = (Stonewt) <span class="number">19.6</span>;<span class="comment">//OK,因为是显性转换</span></div></pre></td></tr></table></figure>
<p><strong>转换函数</strong>：就是将之前的Stonewt转换为double类型等。如<code>operator int() const</code>或者<code>operator double() const</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stonewt <span class="title">wolfe</span><span class="params">(<span class="number">285.7</span>)</span></span>;</div><div class="line"><span class="keyword">double</span> host = <span class="keyword">double</span>(wolfe);<span class="comment">//将wolfe转换为double类型</span></div><div class="line"><span class="keyword">double</span> host = wolfe;<span class="comment">//显性</span></div><div class="line"><span class="keyword">double</span> host = (<span class="keyword">double</span>) wolfe;<span class="comment">//显性</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>：最好少用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存模型和名称空间&quot;&gt;&lt;a href=&quot;#内存模型和名称空间&quot; class=&quot;headerlink&quot; title=&quot;内存模型和名称空间&quot;&gt;&lt;/a&gt;内存模型和名称空间&lt;/h2&gt;&lt;h3 id=&quot;include的使用&quot;&gt;&lt;a href=&quot;#include的使用&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime Plus第9章</title>
    <link href="https://caixueyuan.github.io/2019/07/31/C-Prime-Plus%E7%AC%AC9%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/31/C-Prime-Plus第9章/</id>
    <published>2019-07-30T16:02:06.000Z</published>
    <updated>2019-07-30T16:25:28.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>重载</strong>：</p>
<ol>
<li>重载不区分const和非const变量</li>
<li>重载不区分引用和非引用</li>
<li>重载不区分返回值</li>
</ol>
<p><strong>模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>;<span class="comment">//常规模板</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> Swap&lt;job&gt;(job&amp; a,job&amp; b);<span class="comment">//具体化</span></div></pre></td></tr></table></figure>
<p>具体函数优于具体化，优于常规模板</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重载&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重载不区分const和非const变量&lt;/li&gt;
&lt;li&gt;重载不区分引用
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C语句编译与链接</title>
    <link href="https://caixueyuan.github.io/2019/07/25/C%E8%AF%AD%E5%8F%A5%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>https://caixueyuan.github.io/2019/07/25/C语句编译与链接/</id>
    <published>2019-07-25T15:17:34.000Z</published>
    <updated>2019-07-30T16:01:06.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="运行库.png" alt="1564068683784"></p>
<p><strong>操作系统应用程序编程接口</strong>：应用程序的接口的提供者是运行库（Runtime Library），运行库使用操作系统提供的系统调用接口。</p>
<p><strong>直接使用物理内存的坏处</strong>：</p>
<ol>
<li>地址空间不连续</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
</ol>
<p><strong>使用虚拟地址</strong>：</p>
<p><img src="虚拟地址.png" alt="1564069609677"></p>
<p>程序只能够访问到虚拟地址，不感知物理地址，一个程序可以分为好多段，好多页，页分为虚拟页，物理页和磁盘页。程序访问的是虚拟地址，如果虚拟地址映射的物理页不在物理内存中，会出现缺页中断，由操作系统进行接管，来处理缺页中断，所以呢，程序并不感知物理地址。</p>
<p>用户线程和内核线程并不总是一对一，又可能是多对一或者是多对多。</p>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p><img src="编译链接过程.png" alt="1564071456112"></p>
<p>预处理（processing)，编译（Compilation），汇编（Assembled），链接（Linking）</p>
<p><strong>预编译</strong>：</p>
<ol>
<li>展开所有的宏定义”#define”</li>
<li>处理所有条件预编译指令,”#if”,”#ifdef”,”elif”,”#else”,”#endif”</li>
<li>处理”#include”预编译指令，递归地将包含的文件插入到该编译指令的位置</li>
<li>删除所有的注释</li>
<li>添加行号和文件名标识</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E main.c -o main.i</div></pre></td></tr></table></figure>
<p><strong>编译</strong>：</p>
<p>将预编译之后的代码进行编译，得到汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -s main.i -o main.s</div></pre></td></tr></table></figure>
<p><strong>汇编</strong>：</p>
<p>将汇编代码转换为机器指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c main.s -o main.o</div></pre></td></tr></table></figure>
<p><strong>链接</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o -L /usr/lib/gcc/i486-linux-gnu/4.1.3 -L /usr/lib/ -L /lib hello.o --start-group -lgcc -l gcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o /usr/lib/crtn/o</div></pre></td></tr></table></figure>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><img src="编译过程.png" alt="1564147367310"></p>
<ol>
<li><strong>词法</strong>：lex程序，将源代码的字符序列分割成一系列的记号</li>
<li><strong>语法分析</strong>：根据记号进行分析，产生语法树</li>
<li><strong>语义分析</strong>：分为静态语义和动态语义，对语法树中进行标识</li>
<li><strong>中间代码生成</strong>：将语法树转为中间代码。中间代码使得编译器可以被分为前端和后端，前端可以负责产生机器无关的中间代码，后端将中间代码转换为目标机器代码。<strong>三地址码</strong>：就是对于中间代码，操作都是三个地址+一个操作</li>
<li><strong>目标代码生成与优化</strong>：通过代码生成器来生成目标机器代码</li>
</ol>
<h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p><strong>符号</strong>：用来表示一个地址，这个地址可以是一个子程序的起始地址，也可以是变量的起始地址。    </p>
<p>链接的主要内容是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正常链接好，“程序员人工调整地址”，包括地址和空间分配，符号决议和重定位。</p>
<p><strong>静态链接</strong>：每次函数调用都必须确切知道函数的地址，但是由于每个模块都是单独编译的，在编译器编译的时候并不知道函数的地址，所以等到链接的时候由链接器将这些指令的目标地址来修正，得到函数的地址。对于全局变量和定义在其他文件的变量也是一样的道理。</p>
<p><strong>重定位</strong>：给程序中每个引用到其他文件的地址打补丁，让他们引用到正确的绝对地址。、</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>可重定位文件</strong>（relocatable file)：包含代码和数据，可以被用来链接成可执行文件和共享目标文件。包括静态链接文件</li>
<li>可执行文件（executable file）：可执行文件</li>
<li>共享目标文件（Shared Object File）：包含代码和数据，有两个作用：跟可重定位文件生成新的可执行文件，或者可以与可执行文件结合来运行程序</li>
<li>核心转储文件（core dump file):core文件</li>
</ol>
<h3 id="目标文件格式-1"><a href="#目标文件格式-1" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><ol>
<li><strong>文件头</strong>:描述整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接以及入口地址，目标硬件和目标操作系统等信息，还包括一个段表，描述我呢见中各个段在文件中的偏移位置及段的属性</li>
<li><strong>text段</strong>：机器代码（在内存都是只读）</li>
<li><strong>data段</strong>：已初始化的全局变量和局部变量</li>
<li><strong>bss段</strong>：未初始化的全局变量和局部静态变量</li>
</ol>
<h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test.c</div><div class="line">objdump -h test.o</div><div class="line">size test.o</div></pre></td></tr></table></figure>
<p><img src="编译目标文件.png" alt="1564155339409"></p>
<p><img src="编译内存段.png" alt="1564155384053"></p>
<ol>
<li><p><strong>代码段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -s -d test.o</div></pre></td></tr></table></figure>
</li>
<li><p><strong>数据段和只读数据段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -x -s -d test.o</div></pre></td></tr></table></figure>
<p>.rodata为只读数据段，存储程序中的只读变量和字符串变量</p>
</li>
<li><p><strong>BSS段</strong></p>
<p>未初始化的变量</p>
</li>
</ol>
<p>其他小技巧：</p>
<p><strong>分析mp3等其他文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objcopy -I binary -O elf32-i386 -B i386 image.jpg image.o</div><div class="line">objdump -ht image.o</div></pre></td></tr></table></figure>
<p><strong>自定义段</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(<span class="string">"FOO"</span>)))<span class="keyword">int</span> global = <span class="number">42</span>;<span class="comment">//变量将放在FOO段中</span></div></pre></td></tr></table></figure>
<h3 id="ELF文件结构描述"><a href="#ELF文件结构描述" class="headerlink" title="ELF文件结构描述"></a>ELF文件结构描述</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">readelf -<span class="keyword">h</span> <span class="keyword">test</span>.o<span class="comment">//查看文件头</span></div><div class="line">readelf -S <span class="keyword">test</span>.o<span class="comment">//查看段表</span></div></pre></td></tr></table></figure>
<ol>
<li>.rel.text:重定位表</li>
<li>.shstrtab:字符串表</li>
</ol>
<h3 id="链接的接口：符号"><a href="#链接的接口：符号" class="headerlink" title="链接的接口：符号"></a>链接的接口：符号</h3><p>定义C++宏，只有在C++程序中才能够进行编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>*,<span class="keyword">int</span>,<span class="keyword">size_t</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><p><strong>强符号</strong>：默认函数和初始化的全局变量</p>
<p><strong>弱符号</strong>：未初始化的全局变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;<span class="comment">//啥都不是</span></div><div class="line"><span class="keyword">int</span> weak;<span class="comment">//弱符号</span></div><div class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;<span class="comment">//强符号</span></div><div class="line">__attribute__((weak)) weak2=<span class="number">2</span><span class="comment">//弱符号</span></div></pre></td></tr></table></figure>
<p><strong>强引用</strong>：对外部目标文件的符号引用在目标文件被最终链接到可执行文件时，要被正确决议，如果没有找到错误，要报编译错误</p>
<p><strong>弱引用</strong>：如果符号没有被定义不报错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__attribute__((weakref)) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(foo)</div><div class="line">		foo();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gcc中生成调试段：加上-g</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;运行库.png&quot; alt=&quot;1564068683784&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统应用程
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux,C++" scheme="https://caixueyuan.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>C++程序概述</title>
    <link href="https://caixueyuan.github.io/2019/07/23/C-%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/23/C-程序概述/</id>
    <published>2019-07-22T16:21:59.000Z</published>
    <updated>2019-07-22T16:41:16.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h2><p><img src="冯诺依曼式" alt="img"></p>
<p>上面为冯诺依曼式计算机</p>
<p>指令执行的过程：</p>
<p>（1） 程序计数器PC将指令的地址发送给地址寄存器AR</p>
<p>（2）地址寄存器到响应的存储单元中将指令取出放入指令寄存器</p>
<p>（3） 指令寄存器将指令交给指令译码器ID进行译码，经过分析这条指令的操作数是一个地址</p>
<p>（4）控制器将指令中的地址传回地址寄存器AR</p>
<p>（6）在控制器的协调下，到相应的存储器中取出数据，将其送到运算器的缓冲寄存器DR</p>
<p>（7）缓冲寄存器将数据送到算数逻辑单元ALU</p>
<p>（8）操作控制器发送一个加一操作的信号给算数逻辑单元ALU</p>
<p>（9）ALU完成运算，并将运算结果放回到累加器中</p>
<p>详情请见：<a href="https://blog.csdn.net/chenkaibsw/article/details/78315931" target="_blank" rel="external">冯诺依曼式计算机</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可执行程序&quot;&gt;&lt;a href=&quot;#可执行程序&quot; class=&quot;headerlink&quot; title=&quot;可执行程序&quot;&gt;&lt;/a&gt;可执行程序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;冯诺依曼式&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面为冯诺依曼式计算机&lt;/p&gt;
&lt;p&gt;指令执行
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="LinuxC++" scheme="https://caixueyuan.github.io/tags/LinuxC/"/>
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://caixueyuan.github.io/2019/07/21/C-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/07/21/C-基础/</id>
    <published>2019-07-21T15:17:43.000Z</published>
    <updated>2019-07-23T16:23:39.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p><strong>sizeof</strong>返回的是表达式结果类型的大小，而不是实际对象值的内存的大小</p>
<p><img src="1563722534600.png" alt="1563722534600"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>static_cast:任何具有明确定义的类型转换，主要不包含底层const，都可以使用static_cast.</li>
<li>const_cast:只能改变运算对象的底层const，将const对象转换为非const对象，没办法做类型转换</li>
<li>reinterpret_cast:为运算对象的位模式提供较低层次上的重新解析，不改变内容，只改变了表达的方式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span>* pc1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div><div class="line"><span class="keyword">int</span> *ip;</div><div class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);<span class="comment">//实际上pc存储的还是int类型的指针</span></div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="局部静态成员"><a href="#局部静态成员" class="headerlink" title="局部静态成员"></a>局部静态成员</h3><p><strong>局部静态成员</strong>：在程序执行路径第一次经过此对象定义语句的时候初始化，直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对其有影响</p>
<p><img src="1563811767670.png" alt="1563811767670"></p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配</p>
<p><strong>initializer_list</strong>:可变参数列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//expect和actual是string对象</span></div><div class="line"><span class="keyword">if</span>(expected != actual)</div><div class="line">    error_msg(&#123;<span class="string">"function"</span>,expected,actual&#125;);</div><div class="line"><span class="keyword">else</span></div><div class="line">    error_msg(&#123;<span class="string">"functionX"</span>,<span class="string">"OKAY"</span>&#125;);</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(ErrCode e,<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg() &lt;&lt; <span class="string">":"</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem:il)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a><strong>返回值</strong>：</h3><ol>
<li>不要返回局部对象的引用和指针。因为如果返回局部对象的引用时，由于函数运行结束之后局部对象会被析构，导致返回值为未知对象。</li>
<li>引用返回左值，返回值可以作为左值，如果返回的是引用的话</li>
</ol>
<p><strong>重载函数</strong>：</p>
<p>C++重载的是不区分顶层，区分底层</p>
<p>C++中名字查找发生在类型检查之前</p>
<p><img src="重载.png" alt="1563897046529"></p>
<p><strong>内联函数</strong>：内联函数只是向编译器发出的一个请求，编译器可以忽略这个请求。通常就是在每个调用点内联展开。</p>
<p><strong>constexpr函数</strong>：函数的返回值以及所有形参的类型都是字面值类型，而且函数体内必须有且只有一条return语句。constexpr为内联函数，不一定返回常量表达式。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>assert预处理宏：是预处理器，而不是编译器检查的。用来检查不可能的情况</p>
<p><strong>NDEBUG预处理变量</strong>：assert的行为依赖于这个预处理变量的状态，如果定义了这个预处理变量，就什么都不做。</p>
<p><img src="预处理1.png" alt="1563898004510"></p>
<p><img src="预处理2.png" alt="1563898033745"></p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool lengthCompare(const string &amp;,const string &amp;);</div><div class="line">bool (*pf)(const string&amp;,const string &amp;);</div><div class="line">pf = lengthCompare;</div><div class="line">pf = &amp;lengthCompare;</div><div class="line">bool b1 = pf("a","b");</div><div class="line">bool b2 = (*pf)("a","b");</div><div class="line"></div><div class="line">//声明函数指针</div><div class="line">int (*f1(int))(int*,int);</div><div class="line">auto f1(int) -&gt; int(*)(int*,int);</div><div class="line"></div><div class="line">//使用decltype简化书写函数返回类型的过程，第三个函数接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。</div><div class="line">string:size_type sumLength(const string&amp; ,const string &amp;);</div><div class="line">string:size_type largeLength(const string&amp;,const string &amp;);</div><div class="line">decltype (sumLength) *getLength(const string &amp;);//*表示返回指针类型</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表达式&quot;&gt;&lt;a href=&quot;#表达式&quot; class=&quot;headerlink&quot; title=&quot;表达式&quot;&gt;&lt;/a&gt;表达式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;sizeof&lt;/strong&gt;返回的是表达式结果类型的大小，而不是实际对象值的内存的大小&lt;/p&gt;
&lt;p&gt;&lt;img s
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ Prime第四章</title>
    <link href="https://caixueyuan.github.io/2019/07/18/C-Prime%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://caixueyuan.github.io/2019/07/18/C-Prime第四章/</id>
    <published>2019-07-17T16:08:00.000Z</published>
    <updated>2019-07-17T16:53:22.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><ol>
<li>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</li>
<li>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</li>
</ol>
<h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><ol>
<li><strong>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</strong></li>
<li><strong>变量能且只能够定义一次，而可以被多次声明</strong></li>
</ol>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ol>
<li><strong>引用:</strong>引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</li>
<li><strong>引用必须被初始化</strong></li>
<li><strong>如果想要在多个文件之间共享</strong>const对象，必须在变量的定义之前添加extern关键字。</li>
</ol>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line"></div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>：auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line"></div><div class="line">​    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"></div><div class="line">​    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line"></div><div class="line">​    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptr[<span class="number">10</span>];<span class="comment">//10个整形数组的指针</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (*ptr)[<span class="number">10</span>] = &amp;ptr;<span class="comment">//一个指针指向有10个元素的数组</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> (&amp;ptr)[<span class="number">10</span>] = ptr;<span class="comment">//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<h2 id="C语句风格的数组"><a href="#C语句风格的数组" class="headerlink" title="C语句风格的数组:"></a>C语句风格的数组:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure>
<p>这样可以创建一个数组（将数组转换为vector）</p>
<p><img src="1563380478962.png" alt="1563380478962"></p>
<p>使用别名来代替类型</p>
<p><img src="使用别名来代替类型.png" alt="使用别名来代替类型"></p>
<p>第一行和第二行是等价的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/li&gt;
&lt;li&gt;初始化不是赋值，
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记(变量和基础类型)</title>
    <link href="https://caixueyuan.github.io/2019/07/08/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2019/07/08/C-学习笔记/</id>
    <published>2019-07-08T15:37:50.000Z</published>
    <updated>2019-07-17T15:52:13.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><blockquote>
<p>不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）</p>
<p>初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代</p>
</blockquote>
<h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>声明使得名字为程序所知，一个文件如果想要使用到别处定义的名字则必须包含对那个名字的声明，而定义负责创建与名字关联的实体（变量声明规定了变量的类型和名字，而定义还申请存储空间，也可能创建与名字关联的实体</p>
<p><strong>变量能且只能够定义一次，而可以被多次声明</strong></p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>引用</strong>：引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。引用的对象必须是一个对象，不能够是一个字面量</p>
<p><strong>引用必须被初始化</strong></p>
<p>如果想要在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i2 = i;</div><div class="line">r2 = <span class="number">1</span><span class="comment">//错误</span></div></pre></td></tr></table></figure>
<p>注意：</p>
<p><strong>常量引用仅是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个变量未做限定</strong></p>
<p><strong>指向常量的指针也没有规定其所指的对象必须是一个对象，仅仅要求不能够通过该指针改变对象的值</strong></p>
<p><strong>概念</strong>：常量表达式：值不会改变并且在编译过程就能够得到计算结果的表达式</p>
<p><strong>auto</strong>:auto一般会忽略顶层const，保留底层const</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H<span class="comment">//当且仅当变量未定义时为真</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H<span class="comment">//将一个名字作为预处理变量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//结束定义</span></span></div></pre></td></tr></table></figure>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">int</span> *<span class="built_in">ptr</span>[<span class="number">10</span>]<span class="comment">;//10个整形数组的指针</span></div><div class="line"><span class="built_in">int</span> (*<span class="built_in">ptr</span>)[<span class="number">10</span>] = &amp;<span class="built_in">ptr</span><span class="comment">;//一个指针指向有10个元素的数组</span></div><div class="line"><span class="built_in">int</span> (&amp;<span class="built_in">ptr</span>)[<span class="number">10</span>] = <span class="built_in">ptr</span><span class="comment">;//一个引用，引用了有10个元素的数组</span></div></pre></td></tr></table></figure>
<p><em>C语句风格的数组</em>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2) &lt; <span class="number">0</span>)<span class="comment">//比较两个数组的大小</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内置类型&quot;&gt;&lt;a href=&quot;#基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;基本内置类型&quot;&gt;&lt;/a&gt;基本内置类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;不要混用带符号类型和无符号类型（能不用无符号整数的可以不用）&lt;/p&gt;
&lt;p&gt;初始化
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++学习笔记" scheme="https://caixueyuan.github.io/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>linux设备驱动程序</title>
    <link href="https://caixueyuan.github.io/2019/05/29/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://caixueyuan.github.io/2019/05/29/linux设备驱动程序/</id>
    <published>2019-05-29T15:58:36.000Z</published>
    <updated>2019-06-09T16:11:16.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h2><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E6%80%BB%E7%BA%BF.gif" alt="总线"></p>
<p>两条高速总线用于在内存芯片上来回传送数据：前端总线将CPU连接到RAM控制器上，而后端总线将CPU连接到外部硬件的高速缓存上。</p>
<p>主机上的桥将系统总线和前端总线连接在一起。</p>
<p>任何设备只能够连接到一条总线上。</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/PC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.gif" alt="IO体系结构"></p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E4%B8%93%E7%94%A8IO%E7%AB%AF%E5%8F%A3.gif" alt="专用接口"></p>
<p>I/O端口有两种方式：既可以使用为独立的I/O地址空间，又可以被映射到物理地址空间，这样就可以通过内存来访问I/O端口啦。不过一般情况下，都是作为独立的I/O地址空间。</p>
<p>一般情况下，I/O有四个汇编指令，分别为in、out、ins、outs</p>
<p>对于I/O端口，有特殊的数据结构来对应（resource），主要的作用是唯一性地指定I/O地址空间，让地址不重复</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。在相反方向上，它检测设备状态的变化，并对起状态寄存器作用的I/O端口进行相应的更新。（也就是说将值转换为数据，并监控I/O状态)</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><blockquote>
<ul>
<li><p>对从I/O接口收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作。</p>
</li>
<li><p>对从设备接收到的电信号进行转换和适当的解释，并修改（通过I/O接口）状态寄存器的值。</p>
</li>
</ul>
</blockquote>
<h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs文件系统的目标是展现设备驱动程序模型组件间的层次关系，允许用户态应用程序访问内核内部数据结构的一种文件系统</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.PNG" alt="sysfs文件系统"></p>
<p><code>sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用；sysfs把连接在系统上的设备和总线组织成为一个分级的文件，它们可以由用户空间存取，向用户空间导出内核的数据结构以及它们的属性</code></p>
<p><img src="https://blog.csdn.net/zqixiao_09/article/details/50864489" alt="详细信息"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O体系结构&quot;&gt;&lt;a href=&quot;#I-O体系结构&quot; class=&quot;headerlink&quot; title=&quot;I/O体系结构&quot;&gt;&lt;/a&gt;I/O体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caixue
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>锁和进程间通讯</title>
    <link href="https://caixueyuan.github.io/2019/05/26/%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2019/05/26/锁和进程间通讯/</id>
    <published>2019-05-26T04:20:46.000Z</published>
    <updated>2019-05-26T13:09:30.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<ul>
<li><p>临界区：访问和操作共享数据的代码段</p>
</li>
<li><p>竞态条件：当有多个线程同时进入临界区时，执行结果取决于线程的执行顺序。也就是说多个线程如果不受控制的话，那么产生的结果不一定是我们想要的</p>
</li>
</ul>
</blockquote>
<h2 id="内核锁"><a href="#内核锁" class="headerlink" title="内核锁"></a>内核锁</h2><p>锁是有开销的，内核锁的关键的开销在于CPU访问内存的时间，正常情况下CPU都是访问寄存器，寄存器的速度更快</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>概念：该操作在执行完成前不会允许被打断，是最小的执行单元。</p>
<p>原子类型定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter; &#125; <span class="keyword">atomic_t</span>;</div></pre></td></tr></table></figure>
<p>volatile修饰字段告诉gcc不要对该类型的数据做优化处理，对它的访问都是对内存的访问，而不是对寄存器的访问。 </p>
<p>用处：常用于引用计数</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源。一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。</p>
<p>用处：作为互斥量使用</p>
<h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><p>读写信号量的访问规则：</p>
<p>1，读写信号量同时拥有的读者数不受限制，也就说可以有任意多个读者同时拥有一个读写信号量。</p>
<p>2,如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则，读者必须被挂起直到写者释放该信号量。</p>
<p>3，如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者将被挂起，直到没有任何访问者。 </p>
<p>因此，写者是排他性的，独占性的。 </p>
<p>读写信号量有两种实现，一种是通用的，不依赖于硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现。</p>
<p>用处：适用于读多写少的环境下</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁和互斥锁的区别在于自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁</p>
<p>信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（_trylock的变种能够在中断上下文使用），而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共巷资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。 </p>
<h3 id="大内核锁-BKL–Big-Kernel-Lock"><a href="#大内核锁-BKL–Big-Kernel-Lock" class="headerlink" title="大内核锁(BKL–Big Kernel Lock)"></a>大内核锁(BKL–Big Kernel Lock)</h3><p>大内核锁本质上也是自旋锁，但是它又不同于自旋锁，自旋锁是不可以递归获得锁的，因为那样会导致死锁。但大内核锁可以递归获得锁。大内核锁用于保护整个内核，而自旋锁用于保护非常特定的某一共享资源。进程保持大内核锁时可以发生调度，具体实现是：在执行schedule时，schedule将检查进程是否拥有大内核锁，如果有，它将被释放，以致于其它的进程能够获得该锁，而当轮到该进程运行时，再让它重新获得大内核锁。注意在保持自旋锁期间是不允许发生调度的。 </p>
<p>需要特别指出，整个内核只有一个大内核锁，其实不难理解，内核只有一个，而大内核锁是保护整个内核的，当然有且只有一个就足够了。 </p>
<h3 id="读写锁（rwlock"><a href="#读写锁（rwlock" class="headerlink" title="读写锁（rwlock)"></a>读写锁（rwlock)</h3><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。<br>在读写锁保持期间也是抢占失效的。<br>读写锁访问规则:</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。<br>如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<h3 id="大读者锁-brlock-Big-Reader-Lock"><a href="#大读者锁-brlock-Big-Reader-Lock" class="headerlink" title="大读者锁(brlock-Big Reader Lock)"></a>大读者锁(brlock-Big Reader Lock)</h3><p>大读者锁的实现机制是：每一个大读者锁在所有CPU上都有一个本地读者写者锁，一个读者仅需要获得本地CPU的读者锁，而写者必须获得所有CPU上的锁。</p>
<h3 id="RCU-Read-Copy-Update"><a href="#RCU-Read-Copy-Update" class="headerlink" title="RCU(Read-Copy Update)"></a>RCU(Read-Copy Update)</h3><p>对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。 </p>
<p>参考链接：</p>
<h2 id="进程间通讯（IPC）"><a href="#进程间通讯（IPC）" class="headerlink" title="进程间通讯（IPC）"></a>进程间通讯（IPC）</h2><p>每个地址都有自己的虚拟空间，虚拟空间互不可见，进程间通讯需要通过内核，内核开辟出一块缓冲空间，进程A将数据从用户空间复制到内核空间，进程B将数据从内核缓冲区复制到用户空间来完成进程间通讯</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种特殊文件，满足先进先出的原则，不能够随机读取，在建立管道之前要保证发送方和接收方的进程存在</p>
<p>匿名管道和有名管道总结：<br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号生命周期和处理流程<br>（1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br>（2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br>（3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列特点总结：<br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。<br>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥</p>
<p>信号量与互斥量之间的区别：<br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p>
<p>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<h3 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h3><p>详细信息请见：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="external">进程间通讯</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;临界区：访问和操作共享数据的代码段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;竞态条件：当有多个线程同时
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="https://caixueyuan.github.io/2019/05/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://caixueyuan.github.io/2019/05/19/Linux进程管理/</id>
    <published>2019-05-19T14:31:59.000Z</published>
    <updated>2019-05-26T04:22:59.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h3 id="进程优先级-1"><a href="#进程优先级-1" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程可以分为实时线程和普通线程，一般情况下咱们运行的微服务的进程都是普通线程。<br>实时进程的优先级大于普通线程，在CPU调度中优先执行，采用先进先出的原则进行调度；<br>普通线程的优先级：影响进程的优先级有两个值：动态优先级（PRI）和静态优先级（NI），静态优先级可以影响进程的优先级。<br>使用ps -l的方式进行查询</p>
<p>NICE有40个优先级，以-20（最高优先级）到19（最低优先级），默认有限级为0,<br>使用renice能够改变进程的优先级，只有root用户才能够提高进程的优先级，而普通用户只能够减低进程的优先级<br>使用的命令如下：</p>
<blockquote>
<ul>
<li>nice -n 6 sh bash.sh</li>
<li>renice +3 1234(PID)</li>
</ul>
</blockquote>
<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><p>进程还分为前台进程和后台进程，前台进程负责跟用户进行交互，使用以下两个命令能够进行前后台切换</p>
<blockquote>
<ul>
<li>fg 将后台转变成前台</li>
<li><p>bg 将前台转变成后台</p>
</li>
<li><p>nohup 用户注销不影响进程运行</p>
</li>
<li>ps -j –forest 查询进程树的结构</li>
</ul>
</blockquote>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><p><img src="https://img-blog.csdn.net/20180227113851124" alt="进程生命周期"><br>进程有这几个状态：</p>
<blockquote>
<ul>
<li>运行状态：进程正在CPU上运行</li>
<li>等待状态：进程已经准备好啦，等待CPU进行调度，获取CPU片段时间</li>
<li>终止状态：进程已经运行完啦，通过return/_exit/exit进行返回</li>
<li>睡眠状态：进程因为某些原因（主要有两种：IO缺页问题导致需要进行IO退出CPU运行，或者是周期性的CPU调度）导致进程CPU片段时间被抢占，进入睡眠状态</li>
</ul>
</blockquote>
<h2 id="数据结构task-struct"><a href="#数据结构task-struct" class="headerlink" title="数据结构task_struct"></a>数据结构task_struct</h2><p>包含了进程运行的所有信息，其实比较重要的变量：</p>
<blockquote>
<ul>
<li><code>volatile long state</code>代表进程的状态</li>
<li><code>pid_t pid;  pid_t tgid;</code>进程的唯一标识PID</li>
<li><code>void *stack;</code>进程的内核栈</li>
</ul>
</blockquote>
<p>具体的参考链接：<br><a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="external">Linux进程描述符task_struct结构体详解</a></p>
<h2 id="进程关系："><a href="#进程关系：" class="headerlink" title="进程关系："></a>进程关系：</h2><h3 id="进程组的概念"><a href="#进程组的概念" class="headerlink" title="进程组的概念"></a>进程组的概念</h3><p>每个进程都属于一个进程组，进程组有一个进程组领导进程。<br>比如这个（这三个进程为一个进程组，进程组领导进程为第一个进程bash进程）<br><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="进程组"></p>
<h3 id="会话-session"><a href="#会话-session" class="headerlink" title="会话 (session)"></a>会话 (session)</h3><p>将进程分为前台进程和后台进程，通过fg和pg进行切换</p>
<p>参考链接：<a href="https://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="external">Linux进程关系</a></p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>进程都是通过父进程创建子进程的方式来创建进程的。主要有三种方式：fork，vfork和clone</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork是最常用的方式，一般情况下我们都是使用这种方式来创建进程</p>
<p><code>重要</code>:<br>开始的时候，父进程和子进程都是共用一份可执行文件，堆栈等，物理地址和逻辑地址都是一致的，父进程和子进程共享页帧而不是复制页帧，并且页帧是被保护的。</p>
<p>当父进程A或子进程B任何一方对这些已共享的物理页面执行写操作时,都会产生页面出错异常(page_fault int14)中断,此时CPU会执行系统提供的异常处理函数do_wp_page()来解决这个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。如果是父进程创建的页帧，只对父进程可见可读可写。如果是子进程创建的页，只对父进程可见可读可写。</p>
<p>do_wp_page()会对这块导致写入异常中断的物理页面进行取消共享操作,为写进程复制一新的物理页面,使父进程A和子进程B各自拥有一块内容相同的物理页面.最后,从异常处理函数中返回时,CPU就会重新执行刚才导致异常的写入操作指令,使进程继续执行下去.</p>
<p>这个过程结束之后，虚拟地址依然是不变的，只是虚拟地址映射到物理地址的映射变化，物理地址是变化的，但是虚拟地址不变</p>
<p>子进程和父进程的执行顺序不能够确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">    child = fork( );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(child &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is father, his count is: %d (%p), his pid is: %d\n"</span>, count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">caixueyuan@caixueyuan-PC:~/Desktop/process$ ./fork </div><div class="line">This <span class="keyword">is</span> father, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">1</span> (<span class="number">0</span>x7ffeff294758), <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11495</span></div><div class="line">This <span class="keyword">is</span> son, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">2</span> (<span class="number">0</span>x7ffeff294758). <span class="built_in">and</span> <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11496</span></div></pre></td></tr></table></figure></p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork跟fork最大的区别就是vfork没有采用写时复制这一块，子进程从开始到结束都是使用父进程的虚拟地址和物理空间，如果子进程要修改数据，修改的也是父进程的数据<br><code>重要</code>:这里要特别注意：子进程退出不能够使用return的方式，因为子进程退出和父进程退出是一样的，会导致重复退出而报错。最好也不要使用exit(0)这种方式，稍后会进行解释。</p>
<p>vfork的用处：一般是用来创建不修改父进程的数据的子进程（一般咱们是用来通过创建子进程来执行另外一个程序，不会修改到原程序的堆，数据等）</p>
<p>vfork创建的进程都是子进程先执行，等子进程使用execve或者_exit退出之后才会继续运行父进程</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">   <span class="comment">// child = vfork( );</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Before create son, the father's count is:%d\n"</span>, count);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>((child = vfork())&lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After son, This is father, his count is: %d (%p), his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Before create son, <span class="keyword">the</span> father's <span class="built_in">count</span> <span class="keyword">is</span>:<span class="number">1</span></div><div class="line">This <span class="keyword">is</span> son, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">2</span> (<span class="number">0x7ffe4b965058</span>). <span class="keyword">and</span> his pid <span class="keyword">is</span>: <span class="number">12998</span></div><div class="line">After son, This <span class="keyword">is</span> father, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">3</span> (<span class="number">0x7ffe4b965058</span>), his pid <span class="keyword">is</span>: <span class="number">12997</span></div></pre></td></tr></table></figure></p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone是libc中的函数，不是系统调用，一般是用来创建线程的，可以通过clone的方式来创建以上fork或者vfork的方式的创建进程</p>
<p>参考链接：<a href="https://blog.csdn.net/gatieme/article/details/51417488" target="_blank" rel="external">Linux中fork，vfork和clone详解（区别与联系）</a></p>
<h2 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h2><p>进程的退出有两种：</p>
<blockquote>
<ul>
<li>正常退出（return,exit(0),_exit(0))</li>
<li>非正常退出（调用abort(),通过信号的方式（kill -9))</li>
</ul>
</blockquote>
<p>正常退出的方式要注意exit和_exit的区别，有可能造成很隐蔽的错误</p>
<blockquote>
<p>_exit是系统调用，直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构<br>exit不是系统调用，是libc中的接口，包含了_exit的操作，按ATEXIT注册时相反的顺序调用所有由它注册的函数，同时还能够刷一下IO，这样可以保证写文件的缓冲等能够刷到文件或者控制台中。</p>
</blockquote>
<p>之所有不推荐在vfork的方式下使用exit(0)的方式，就是怕exit需要刷IO，需要调用终止处理程序，可能会对进程中的内容造成破坏，给父进程造成不确定性</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA.png" alt="进程退出"></p>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><h3 id="进程的分类（略）"><a href="#进程的分类（略）" class="headerlink" title="进程的分类（略）"></a>进程的分类（略）</h3><p>实时进程：对于实时进程，采用先进先出的方式进行，优先级高于普通进程，会快速响应<br>普通进程：CFS调度。实现尽可能公平的分配CPU资源。一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU，另一种是通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要</p>
<h3 id="进程的上下文切换（略）"><a href="#进程的上下文切换（略）" class="headerlink" title="进程的上下文切换（略）"></a>进程的上下文切换（略）</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程优先级&quot;&gt;&lt;a href=&quot;#进程优先级&quot; class=&quot;headerlink&quot; title=&quot;进程优先级&quot;&gt;&lt;/a&gt;进程优先级&lt;/h2&gt;&lt;h3 id=&quot;进程优先级-1&quot;&gt;&lt;a href=&quot;#进程优先级-1&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux和C++基础</title>
    <link href="https://caixueyuan.github.io/2019/05/04/linux%E5%92%8CC-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/05/04/linux和C-基础/</id>
    <published>2019-05-04T14:45:45.000Z</published>
    <updated>2019-05-04T15:22:38.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第7章-编译"><a href="#第7章-编译" class="headerlink" title="第7章 编译"></a>第7章 编译</h2><h3 id="编译的阶段"><a href="#编译的阶段" class="headerlink" title="编译的阶段"></a>编译的阶段</h3><blockquote>
<ul>
<li>源代码</li>
<li><p>预处理：字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名<figure class="highlight plain"><figcaption><span>-o main.i -E main.c gcc -o hello.i -E hello.c```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 编译：将预处理之后的完整的代码进行编译，变成汇编代码```gcc -S main.i hello.i</div></pre></td></tr></table></figure></p>
</li>
<li><p>汇编：将汇编代码翻译成机器代码，变成二进制文件。<figure class="highlight plain"><figcaption><span>-c main.s hello.s```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 链接：链接程序形成可执行目标文件```gcc -o hello main.o hello.o</div></pre></td></tr></table></figure></p>
</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第7章-编译&quot;&gt;&lt;a href=&quot;#第7章-编译&quot; class=&quot;headerlink&quot; title=&quot;第7章 编译&quot;&gt;&lt;/a&gt;第7章 编译&lt;/h2&gt;&lt;h3 id=&quot;编译的阶段&quot;&gt;&lt;a href=&quot;#编译的阶段&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/categories/linux-C/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2019/02/14/hello-world/"/>
    <id>https://caixueyuan.github.io/2019/02/14/hello-world/</id>
    <published>2019-02-13T16:10:35.276Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
