<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2019-05-29T16:35:49.991Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux设备驱动程序</title>
    <link href="https://caixueyuan.github.io/2019/05/29/linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://caixueyuan.github.io/2019/05/29/linux设备驱动程序/</id>
    <published>2019-05-29T15:58:36.000Z</published>
    <updated>2019-05-29T16:35:49.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h2><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E6%80%BB%E7%BA%BF.gif" alt="总线"></p>
<p>两条高速总线用于在内存芯片上来回传送数据：前端总线将CPU连接到RAM控制器上，而后端总线将CPU连接到外部硬件的高速缓存上。</p>
<p>主机上的桥将系统总线和前端总线连接在一起。</p>
<p>任何设备只能够连接到一条总线上。</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/PC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.gif" alt="IO体系结构"></p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E4%B8%93%E7%94%A8IO%E7%AB%AF%E5%8F%A3.gif" alt="专用接口"></p>
<p>I/O端口有两种方式：既可以使用为独立的I/O地址空间，又可以被映射到物理地址空间，这样就可以通过内存来访问I/O端口啦。不过一般情况下，都是作为独立的I/O地址空间。</p>
<p>一般情况下，I/O有四个汇编指令，分别为in、out、ins、outs</p>
<p>对于I/O端口，有特殊的数据结构来对应（resource），主要的作用是唯一性地指定I/O地址空间，让地址不重复</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。在相反方向上，它检测设备状态的变化，并对起状态寄存器作用的I/O端口进行相应的更新。（也就是说将值转换为数据，并监控I/O状态)</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><blockquote>
<ul>
<li><p>对从I/O接口收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作。</p>
</li>
<li><p>对从设备接收到的电信号进行转换和适当的解释，并修改（通过I/O接口）状态寄存器的值。</p>
</li>
</ul>
</blockquote>
<h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs文件系统的目标是展现设备驱动程序模型组件间的层次关系，允许用户态应用程序访问内核内部数据结构的一种文件系统</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.PNG" alt="sysfs文件系统"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O体系结构&quot;&gt;&lt;a href=&quot;#I-O体系结构&quot; class=&quot;headerlink&quot; title=&quot;I/O体系结构&quot;&gt;&lt;/a&gt;I/O体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caixue
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>锁和进程间通讯</title>
    <link href="https://caixueyuan.github.io/2019/05/26/%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2019/05/26/锁和进程间通讯/</id>
    <published>2019-05-26T04:20:46.000Z</published>
    <updated>2019-05-26T13:09:30.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<ul>
<li><p>临界区：访问和操作共享数据的代码段</p>
</li>
<li><p>竞态条件：当有多个线程同时进入临界区时，执行结果取决于线程的执行顺序。也就是说多个线程如果不受控制的话，那么产生的结果不一定是我们想要的</p>
</li>
</ul>
</blockquote>
<h2 id="内核锁"><a href="#内核锁" class="headerlink" title="内核锁"></a>内核锁</h2><p>锁是有开销的，内核锁的关键的开销在于CPU访问内存的时间，正常情况下CPU都是访问寄存器，寄存器的速度更快</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>概念：该操作在执行完成前不会允许被打断，是最小的执行单元。</p>
<p>原子类型定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter; &#125; <span class="keyword">atomic_t</span>;</div></pre></td></tr></table></figure>
<p>volatile修饰字段告诉gcc不要对该类型的数据做优化处理，对它的访问都是对内存的访问，而不是对寄存器的访问。 </p>
<p>用处：常用于引用计数</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量在创建时需要设置一个初始值，表示同时可以有几个任务可以访问该信号量保护的共享资源，初始值为1就变成互斥锁（Mutex），即同时只能有一个任务可以访问信号量保护的共享资源。一个任务要想访问共享资源，首先必须得到信号量，获取信号量的操作将把信号量的值减1，若当前信号量的值为负数，表明无法获得信号量，该任务必须挂起在该信号量的等待队列等待该信号量可用；若当前信号量的值为非负数，表示可以获得信号量，因而可以立刻访问被该信号量保护的共享资源。当任务访问完被信号量保护的共享资源后，必须释放信号量，释放信号量通过把信号量的值加1实现，如果信号量的值为非正数，表明有任务等待当前信号量，因此它也唤醒所有等待该信号量的任务。</p>
<p>用处：作为互斥量使用</p>
<h3 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h3><p>读写信号量的访问规则：</p>
<p>1，读写信号量同时拥有的读者数不受限制，也就说可以有任意多个读者同时拥有一个读写信号量。</p>
<p>2,如果一个读写信号量当前没有被写者拥有并且也没有写者等待读者释放信号量，那么任何读者都可以成功获得该读写信号量；否则，读者必须被挂起直到写者释放该信号量。</p>
<p>3，如果一个读写信号量当前没有被读者或写者拥有并且也没有写者等待该信号量，那么一个写者可以成功获得该读写信号量，否则写者将被挂起，直到没有任何访问者。 </p>
<p>因此，写者是排他性的，独占性的。 </p>
<p>读写信号量有两种实现，一种是通用的，不依赖于硬件架构，因此，增加新的架构不需要重新实现它，但缺点是性能低，获得和释放读写信号量的开销大；另一种是架构相关的，因此性能高，获取和释放读写信号量的开销小，但增加新的架构需要重新实现。在内核配置时，可以通过选项去控制使用哪一种实现。</p>
<p>用处：适用于读多写少的环境下</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁和互斥锁的区别在于自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁</p>
<p>信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（_trylock的变种能够在中断上下文使用），而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共巷资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。 </p>
<h3 id="大内核锁-BKL–Big-Kernel-Lock"><a href="#大内核锁-BKL–Big-Kernel-Lock" class="headerlink" title="大内核锁(BKL–Big Kernel Lock)"></a>大内核锁(BKL–Big Kernel Lock)</h3><p>大内核锁本质上也是自旋锁，但是它又不同于自旋锁，自旋锁是不可以递归获得锁的，因为那样会导致死锁。但大内核锁可以递归获得锁。大内核锁用于保护整个内核，而自旋锁用于保护非常特定的某一共享资源。进程保持大内核锁时可以发生调度，具体实现是：在执行schedule时，schedule将检查进程是否拥有大内核锁，如果有，它将被释放，以致于其它的进程能够获得该锁，而当轮到该进程运行时，再让它重新获得大内核锁。注意在保持自旋锁期间是不允许发生调度的。 </p>
<p>需要特别指出，整个内核只有一个大内核锁，其实不难理解，内核只有一个，而大内核锁是保护整个内核的，当然有且只有一个就足够了。 </p>
<h3 id="读写锁（rwlock"><a href="#读写锁（rwlock" class="headerlink" title="读写锁（rwlock)"></a>读写锁（rwlock)</h3><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。<br>在读写锁保持期间也是抢占失效的。<br>读写锁访问规则:</p>
<p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。<br>如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<h3 id="大读者锁-brlock-Big-Reader-Lock"><a href="#大读者锁-brlock-Big-Reader-Lock" class="headerlink" title="大读者锁(brlock-Big Reader Lock)"></a>大读者锁(brlock-Big Reader Lock)</h3><p>大读者锁的实现机制是：每一个大读者锁在所有CPU上都有一个本地读者写者锁，一个读者仅需要获得本地CPU的读者锁，而写者必须获得所有CPU上的锁。</p>
<h3 id="RCU-Read-Copy-Update"><a href="#RCU-Read-Copy-Update" class="headerlink" title="RCU(Read-Copy Update)"></a>RCU(Read-Copy Update)</h3><p>对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。 </p>
<p>参考链接：</p>
<h2 id="进程间通讯（IPC）"><a href="#进程间通讯（IPC）" class="headerlink" title="进程间通讯（IPC）"></a>进程间通讯（IPC）</h2><p>每个地址都有自己的虚拟空间，虚拟空间互不可见，进程间通讯需要通过内核，内核开辟出一块缓冲空间，进程A将数据从用户空间复制到内核空间，进程B将数据从内核缓冲区复制到用户空间来完成进程间通讯</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种特殊文件，满足先进先出的原则，不能够随机读取，在建立管道之前要保证发送方和接收方的进程存在</p>
<p>匿名管道和有名管道总结：<br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号生命周期和处理流程<br>（1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br>（2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br>（3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列特点总结：<br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。<br>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥</p>
<p>信号量与互斥量之间的区别：<br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p>
<p>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
<h3 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h3><p>详细信息请见：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="external">进程间通讯</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;临界区：访问和操作共享数据的代码段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;竞态条件：当有多个线程同时
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="https://caixueyuan.github.io/2019/05/19/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://caixueyuan.github.io/2019/05/19/Linux进程管理/</id>
    <published>2019-05-19T14:31:59.000Z</published>
    <updated>2019-05-26T04:22:59.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h3 id="进程优先级-1"><a href="#进程优先级-1" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>进程可以分为实时线程和普通线程，一般情况下咱们运行的微服务的进程都是普通线程。<br>实时进程的优先级大于普通线程，在CPU调度中优先执行，采用先进先出的原则进行调度；<br>普通线程的优先级：影响进程的优先级有两个值：动态优先级（PRI）和静态优先级（NI），静态优先级可以影响进程的优先级。<br>使用ps -l的方式进行查询</p>
<p>NICE有40个优先级，以-20（最高优先级）到19（最低优先级），默认有限级为0,<br>使用renice能够改变进程的优先级，只有root用户才能够提高进程的优先级，而普通用户只能够减低进程的优先级<br>使用的命令如下：</p>
<blockquote>
<ul>
<li>nice -n 6 sh bash.sh</li>
<li>renice +3 1234(PID)</li>
</ul>
</blockquote>
<h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><p>进程还分为前台进程和后台进程，前台进程负责跟用户进行交互，使用以下两个命令能够进行前后台切换</p>
<blockquote>
<ul>
<li>fg 将后台转变成前台</li>
<li><p>bg 将前台转变成后台</p>
</li>
<li><p>nohup 用户注销不影响进程运行</p>
</li>
<li>ps -j –forest 查询进程树的结构</li>
</ul>
</blockquote>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><p><img src="https://img-blog.csdn.net/20180227113851124" alt="进程生命周期"><br>进程有这几个状态：</p>
<blockquote>
<ul>
<li>运行状态：进程正在CPU上运行</li>
<li>等待状态：进程已经准备好啦，等待CPU进行调度，获取CPU片段时间</li>
<li>终止状态：进程已经运行完啦，通过return/_exit/exit进行返回</li>
<li>睡眠状态：进程因为某些原因（主要有两种：IO缺页问题导致需要进行IO退出CPU运行，或者是周期性的CPU调度）导致进程CPU片段时间被抢占，进入睡眠状态</li>
</ul>
</blockquote>
<h2 id="数据结构task-struct"><a href="#数据结构task-struct" class="headerlink" title="数据结构task_struct"></a>数据结构task_struct</h2><p>包含了进程运行的所有信息，其实比较重要的变量：</p>
<blockquote>
<ul>
<li><code>volatile long state</code>代表进程的状态</li>
<li><code>pid_t pid;  pid_t tgid;</code>进程的唯一标识PID</li>
<li><code>void *stack;</code>进程的内核栈</li>
</ul>
</blockquote>
<p>具体的参考链接：<br><a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="external">Linux进程描述符task_struct结构体详解</a></p>
<h2 id="进程关系："><a href="#进程关系：" class="headerlink" title="进程关系："></a>进程关系：</h2><h3 id="进程组的概念"><a href="#进程组的概念" class="headerlink" title="进程组的概念"></a>进程组的概念</h3><p>每个进程都属于一个进程组，进程组有一个进程组领导进程。<br>比如这个（这三个进程为一个进程组，进程组领导进程为第一个进程bash进程）<br><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt="进程组"></p>
<h3 id="会话-session"><a href="#会话-session" class="headerlink" title="会话 (session)"></a>会话 (session)</h3><p>将进程分为前台进程和后台进程，通过fg和pg进行切换</p>
<p>参考链接：<a href="https://www.cnblogs.com/vamei/archive/2012/10/07/2713023.html" target="_blank" rel="external">Linux进程关系</a></p>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>进程都是通过父进程创建子进程的方式来创建进程的。主要有三种方式：fork，vfork和clone</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork是最常用的方式，一般情况下我们都是使用这种方式来创建进程</p>
<p><code>重要</code>:<br>开始的时候，父进程和子进程都是共用一份可执行文件，堆栈等，物理地址和逻辑地址都是一致的，父进程和子进程共享页帧而不是复制页帧，并且页帧是被保护的。</p>
<p>当父进程A或子进程B任何一方对这些已共享的物理页面执行写操作时,都会产生页面出错异常(page_fault int14)中断,此时CPU会执行系统提供的异常处理函数do_wp_page()来解决这个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。如果是父进程创建的页帧，只对父进程可见可读可写。如果是子进程创建的页，只对父进程可见可读可写。</p>
<p>do_wp_page()会对这块导致写入异常中断的物理页面进行取消共享操作,为写进程复制一新的物理页面,使父进程A和子进程B各自拥有一块内容相同的物理页面.最后,从异常处理函数中返回时,CPU就会重新执行刚才导致异常的写入操作指令,使进程继续执行下去.</p>
<p>这个过程结束之后，虚拟地址依然是不变的，只是虚拟地址映射到物理地址的映射变化，物理地址是变化的，但是虚拟地址不变</p>
<p>子进程和父进程的执行顺序不能够确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">    child = fork( );</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(child &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is father, his count is: %d (%p), his pid is: %d\n"</span>, count, &amp;count, getpid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">caixueyuan@caixueyuan-PC:~/Desktop/process$ ./fork </div><div class="line">This <span class="keyword">is</span> father, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">1</span> (<span class="number">0</span>x7ffeff294758), <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11495</span></div><div class="line">This <span class="keyword">is</span> son, <span class="keyword">his</span> <span class="built_in">count</span> i<span class="variable">s:</span> <span class="number">2</span> (<span class="number">0</span>x7ffeff294758). <span class="built_in">and</span> <span class="keyword">his</span> pid i<span class="variable">s:</span> <span class="number">11496</span></div></pre></td></tr></table></figure></p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork跟fork最大的区别就是vfork没有采用写时复制这一块，子进程从开始到结束都是使用父进程的虚拟地址和物理空间，如果子进程要修改数据，修改的也是父进程的数据<br><code>重要</code>:这里要特别注意：子进程退出不能够使用return的方式，因为子进程退出和父进程退出是一样的，会导致重复退出而报错。最好也不要使用exit(0)这种方式，稍后会进行解释。</p>
<p>vfork的用处：一般是用来创建不修改父进程的数据的子进程（一般咱们是用来通过创建子进程来执行另外一个程序，不会修改到原程序的堆，数据等）</p>
<p>vfork创建的进程都是子进程先执行，等子进程使用execve或者_exit退出之后才会继续运行父进程</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> child;</div><div class="line"></div><div class="line">   <span class="comment">// child = vfork( );</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Before create son, the father's count is:%d\n"</span>, count);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>((child = vfork())&lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error : "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child == <span class="number">0</span>)     <span class="comment">//  fork return 0 in the child process because child can get hid PID by getpid( )</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is son, his count is: %d (%p). and his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>                    <span class="comment">//  the PID of the child process is returned in the parent’s thread of execution</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After son, This is father, his count is: %d (%p), his pid is: %d\n"</span>, ++count, &amp;count, getpid());</div><div class="line">        _exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Before create son, <span class="keyword">the</span> father's <span class="built_in">count</span> <span class="keyword">is</span>:<span class="number">1</span></div><div class="line">This <span class="keyword">is</span> son, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">2</span> (<span class="number">0x7ffe4b965058</span>). <span class="keyword">and</span> his pid <span class="keyword">is</span>: <span class="number">12998</span></div><div class="line">After son, This <span class="keyword">is</span> father, his <span class="built_in">count</span> <span class="keyword">is</span>: <span class="number">3</span> (<span class="number">0x7ffe4b965058</span>), his pid <span class="keyword">is</span>: <span class="number">12997</span></div></pre></td></tr></table></figure></p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone是libc中的函数，不是系统调用，一般是用来创建线程的，可以通过clone的方式来创建以上fork或者vfork的方式的创建进程</p>
<p>参考链接：<a href="https://blog.csdn.net/gatieme/article/details/51417488" target="_blank" rel="external">Linux中fork，vfork和clone详解（区别与联系）</a></p>
<h2 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h2><p>进程的退出有两种：</p>
<blockquote>
<ul>
<li>正常退出（return,exit(0),_exit(0))</li>
<li>非正常退出（调用abort(),通过信号的方式（kill -9))</li>
</ul>
</blockquote>
<p>正常退出的方式要注意exit和_exit的区别，有可能造成很隐蔽的错误</p>
<blockquote>
<p>_exit是系统调用，直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构<br>exit不是系统调用，是libc中的接口，包含了_exit的操作，按ATEXIT注册时相反的顺序调用所有由它注册的函数，同时还能够刷一下IO，这样可以保证写文件的缓冲等能够刷到文件或者控制台中。</p>
</blockquote>
<p>之所有不推荐在vfork的方式下使用exit(0)的方式，就是怕exit需要刷IO，需要调用终止处理程序，可能会对进程中的内容造成破坏，给父进程造成不确定性</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/linux/base/%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA.png" alt="进程退出"></p>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><h3 id="进程的分类（略）"><a href="#进程的分类（略）" class="headerlink" title="进程的分类（略）"></a>进程的分类（略）</h3><p>实时进程：对于实时进程，采用先进先出的方式进行，优先级高于普通进程，会快速响应<br>普通进程：CFS调度。实现尽可能公平的分配CPU资源。一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU，另一种是通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要</p>
<h3 id="进程的上下文切换（略）"><a href="#进程的上下文切换（略）" class="headerlink" title="进程的上下文切换（略）"></a>进程的上下文切换（略）</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程优先级&quot;&gt;&lt;a href=&quot;#进程优先级&quot; class=&quot;headerlink&quot; title=&quot;进程优先级&quot;&gt;&lt;/a&gt;进程优先级&lt;/h2&gt;&lt;h3 id=&quot;进程优先级-1&quot;&gt;&lt;a href=&quot;#进程优先级-1&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="Linux" scheme="https://caixueyuan.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础知识" scheme="https://caixueyuan.github.io/tags/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux和C++基础</title>
    <link href="https://caixueyuan.github.io/2019/05/04/linux%E5%92%8CC-%E5%9F%BA%E7%A1%80/"/>
    <id>https://caixueyuan.github.io/2019/05/04/linux和C-基础/</id>
    <published>2019-05-04T14:45:45.000Z</published>
    <updated>2019-05-04T15:22:38.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第7章-编译"><a href="#第7章-编译" class="headerlink" title="第7章 编译"></a>第7章 编译</h2><h3 id="编译的阶段"><a href="#编译的阶段" class="headerlink" title="编译的阶段"></a>编译的阶段</h3><blockquote>
<ul>
<li>源代码</li>
<li><p>预处理：字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名<figure class="highlight plain"><figcaption><span>-o main.i -E main.c gcc -o hello.i -E hello.c```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 编译：将预处理之后的完整的代码进行编译，变成汇编代码```gcc -S main.i hello.i</div></pre></td></tr></table></figure></p>
</li>
<li><p>汇编：将汇编代码翻译成机器代码，变成二进制文件。<figure class="highlight plain"><figcaption><span>-c main.s hello.s```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; * 链接：链接程序形成可执行目标文件```gcc -o hello main.o hello.o</div></pre></td></tr></table></figure></p>
</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第7章-编译&quot;&gt;&lt;a href=&quot;#第7章-编译&quot; class=&quot;headerlink&quot; title=&quot;第7章 编译&quot;&gt;&lt;/a&gt;第7章 编译&lt;/h2&gt;&lt;h3 id=&quot;编译的阶段&quot;&gt;&lt;a href=&quot;#编译的阶段&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/categories/linux-C/"/>
    
    
      <category term="linux,C++" scheme="https://caixueyuan.github.io/tags/linux-C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2019/02/14/hello-world/"/>
    <id>https://caixueyuan.github.io/2019/02/14/hello-world/</id>
    <published>2019-02-13T16:10:35.276Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&#39;C++类&#39;</title>
    <link href="https://caixueyuan.github.io/2018/10/08/C-%E7%B1%BB/"/>
    <id>https://caixueyuan.github.io/2018/10/08/C-类/</id>
    <published>2018-10-08T15:36:33.000Z</published>
    <updated>2018-10-17T14:30:04.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类概念"><a href="#类概念" class="headerlink" title="类概念"></a>类概念</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> bookNo&#125;</div><div class="line">    Sales_data&amp; combine(<span class="keyword">const</span> Sales_data&amp;);</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>std::string isbn() const{return this-&gt;bookNo;}</code>this的目的总是指向这个对象，this是一个常量指针，不能够修改this中保存的地址。<br>const的作用是修改隐式this指针的类型，相当于const int i =1;中const的作用。<br>默认情况下，this的类型是指向类类型的非常量版本的常量指针。</p>
<p>C++编译顺序：首先编译成员的声明，然后才轮到成员函数体。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用class和struct定义唯一的区别是默认的访问权限，struct的默认权限是public，而class的默认权限是private</p>
<p>不管是在类内，还是在类外，都可以将函数转为内联函数。</p>
<p><strong>可变数据成员</strong>：mutable size_t access_cst;//任何成员函数，包括const函数在内都能够修改它的值。</p>
<p>返回*this的成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</div><div class="line">        <span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos,pos,<span class="keyword">char</span>)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">inline</span> Screen &amp;Screen::<span class="built_in">set</span>(<span class="keyword">char</span> c)</div><div class="line">&#123;</div><div class="line">    contents[cursor] = c;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//将this对象作为左值返回</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回引用的函数是左值的，意味这些函数返回的是对象本身而非对象的副本。<br><code>myScreen.move(4,0).set(&#39;#&#39;);</code>//返回的是对象的引用，所以可以这样使用<br>如果返回的是对象的话，也就是<code>inline Screen Screen::set(char c)</code>的话，那么<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Screen temp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);<span class="comment">//对返回值进行拷贝</span></div><div class="line">temp.<span class="built_in">set</span>(<span class="string">'#'</span>);<span class="comment">//不会修改myScreen的contents</span></div></pre></td></tr></table></figure></p>
<p>因此调用set只能改变临时副本，而不能修改myScreen的值</p>
<p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></div><div class="line">    <span class="comment">//Window_mgr的成员可以访问Screen类的私有成员</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//如果一个类指定了友元类，则友元类的成员函数可以访问次类包括非公有成员在内的所有成员</span></div></pre></td></tr></table></figure>
<p>友元关系不存在传递性<br>每个类负责控制自己的友元类或友元函数</p>
<p><strong>让成员函数作为友元</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line"></div><div class="line">    <span class="comment">//Window_mgr:clear必须在Screen类之前被声明</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);<span class="comment">//这样的话只有Window_mgr中的函数clear能够访问Screen中的非公有成员</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;, Screen &amp;)</span></span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">storeOn</span><span class="params">(<span class="built_in">std</span>::ostream &amp;,Screen &amp;)</span></span>;<span class="comment">//storeOn的中ostream版本能够访问Screen对象的私有部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类概念&quot;&gt;&lt;a href=&quot;#类概念&quot; class=&quot;headerlink&quot; title=&quot;类概念&quot;&gt;&lt;/a&gt;类概念&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++基础知识&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-基础知识/</id>
    <published>2018-09-23T13:10:59.000Z</published>
    <updated>2019-03-18T16:05:05.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>指针是“指向”另外一种类型的复合类型。和引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不相同点。</p>
<blockquote>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和靠背，而且在指针的生命周期内它可以先后指向几个不同的对象</li>
<li>指针无需在定义的时候赋初值</li>
<li>和其他内置对象类型一样，在块作用域中定义的指针如果没有被初始化，也将拥有一个不确定的值</li>
</ul>
</blockquote>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p><strong>case标签</strong>：switch…case中case标签必须是整形常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(deltype(s.size())index = <span class="number">0</span>;index!= s.size() &amp;&amp; !<span class="built_in">isspace</span>(s[index]);++index)&#123;</div><div class="line">    s[index]=<span class="built_in">toupper</span>(s[index]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误类型</p>
<blockquote>
<ul>
<li>exception最常见的问题</li>
<li>runtime_error只有在运行的时候才能够检测出来的问题</li>
<li>range_error运行时错误，生成的结果超过了有意义的值域范围</li>
<li>overflow_error:运行时错误：计算上溢</li>
<li>underflow_error:运行时错误：计算下溢</li>
<li>logic_error：程序逻辑错误</li>
<li>domain_error:逻辑错误：参数对应的结果不存在</li>
<li>invalid_argument:逻辑错误：无效参数</li>
<li>length_error：逻辑错误，试图创建一个超出该类型最大长度的对象</li>
<li>out_of_range：逻辑错误：使用一个超过有效范围的值</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> runtime_error(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(runtime_error err)&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;err.what()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数的返回值不能是数组类型或者函数类型，但可以是指向数组或函数的指针</strong></p>
<p><strong>局部静态对象</strong>：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> count_calls()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;<span class="comment">//调用结束后，这个值仍然有效</span></div><div class="line">    <span class="keyword">return</span> ++ctr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><p>分离式编译<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span></div><div class="line"><span class="keyword">CC</span> factMain.<span class="keyword">cc</span> <span class="keyword">fact</span>.<span class="keyword">cc</span> -o main</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CC -c factMain<span class="selector-class">.cc</span></div><div class="line">CC -c fact<span class="selector-class">.cc</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span></div><div class="line">CC factMain<span class="selector-class">.o</span> fact<span class="selector-class">.o</span> -o main</div></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>传值参数</strong>：</p>
<blockquote>
<ul>
<li>传基本类型</li>
<li>指针形参：指针也是值，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span></div><div class="line">&#123;</div><div class="line">    *ip = <span class="number">0</span>;<span class="comment">//改变指针ip所指对象的值</span></div><div class="line">    ip = <span class="number">0</span>;<span class="comment">//只改变了ip的局部拷贝，实参没有改变</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>传引用参数</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></div><div class="line">&#123;</div><div class="line">    i = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用引用的好处是：</p>
<blockquote>
<ul>
<li>使用引用避免拷贝</li>
<li>使用引用形参返回额外信息。</li>
</ul>
</blockquote>
<p>顶层和底层const<br><strong>顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;<span class="comment">//不能够修改p1的值，这是一个顶层const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;<span class="comment">//不能修改ci的值，这是一个顶层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;<span class="comment">//允许修改p2的值，这是一个底层的const</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针和引用&quot;&gt;&lt;a href=&quot;#指针和引用&quot; class=&quot;headerlink&quot; title=&quot;指针和引用&quot;&gt;&lt;/a&gt;指针和引用&lt;/h2&gt;&lt;p&gt;指针是“指向”另外一种类型的复合类型。和引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不相同
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>&#39;C++算术运算符&#39;</title>
    <link href="https://caixueyuan.github.io/2018/09/23/C-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://caixueyuan.github.io/2018/09/23/C-算术运算符/</id>
    <published>2018-09-23T09:25:11.000Z</published>
    <updated>2018-09-23T11:15:34.079Z</updated>
    
    <content type="html"><![CDATA[<p>##赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">while</span>((i=get_value()) != <span class="number">42</span>)&#123;</div><div class="line">    <span class="comment">//其他处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<blockquote>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1</li>
<li>对引用类型执行sizeof运算得到被引用对象所占的空间的大小</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得到的结果求和</li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz=<span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);<span class="comment">//得到ia元素的个数</span></div></pre></td></tr></table></figure>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p><strong>static_cast</strong>:作用域任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* p = &amp;d;<span class="comment">//正确：任何非常量对象的地址都能够存入void*</span></div><div class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);<span class="comment">//正确，将void*转换回初始的指针类型</span></div></pre></td></tr></table></figure></p>
<p><strong>const_cast</strong>:只能改变运算对象的底层const。能够将常量对象转换成非常量对象的行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</div><div class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##赋值运算符&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>指针与引用</title>
    <link href="https://caixueyuan.github.io/2018/09/11/%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://caixueyuan.github.io/2018/09/11/指针与引用/</id>
    <published>2018-09-11T14:07:02.000Z</published>
    <updated>2018-09-23T07:57:16.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。<br><code>int &amp;refVal4 = 10</code>这种引用类型不是一个对象。</p>
<p>指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象。其二,指针无需在定义时赋初值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//&amp;是取地址符，存放变量ival的地址，或者说p是指向变量ival的指针。</span></div><div class="line"><span class="comment">//第二条语句把p定义为一个指向int的指针，随后初始化p让其指向名为ival的int对象。</span></div><div class="line"><span class="keyword">int</span> *p;</div><div class="line">p = &amp;ival;</div></pre></td></tr></table></figure></p>
<p>在constexpr声明中，如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//p是一个指向整形常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;<span class="comment">//q是一个指向整数的常量指针</span></div></pre></td></tr></table></figure></p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</div><div class="line"><span class="keyword">using</span> SI= Sales_Item;</div></pre></td></tr></table></figure>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;<span class="comment">//sum的类型就是函数f的返回类型</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci =<span class="number">0</span>,&amp;cj = ci;</div><div class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;<span class="comment">//x的类型是const int</span></div><div class="line"><span class="keyword">decltype</span>(cj) y = x;<span class="comment">//y的类型是const int&amp;，y绑定到变量x</span></div><div class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//错误，引用不能够为空</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p = &amp;i;</div><div class="line"><span class="keyword">decltype</span>(*p) c;<span class="comment">//解引用指针可以得到指针所指定的对象，而且给这个对象赋值，因为结果是int&amp;</span></div></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>)<span class="comment">//v1有10个元素，每个元素的值都是0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;<span class="comment">//v2有1个元素，元素的值为0</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">10</span>,<span class="number">1</span>)<span class="comment">//v3有10个元素，每个元素的值都是1</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125;<span class="comment">//v4有2个元素，元素的值为10,1</span></div></pre></td></tr></table></figure>
<p>vector对象的下标对象运算符可用于访问已存在的元素,而不能够用于添加元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</div><div class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;</div><div class="line">    <span class="keyword">auto</span> it = s.begin();</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); it++)&#123;</div><div class="line">    *it = <span class="built_in">toupper</span>(*it);</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>迭代器类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读写类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">string</span>::iterator it2;</div><div class="line"><span class="comment">//只读类型</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</div><div class="line"><span class="built_in">string</span>::const_iterator it4;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</div><div class="line"><span class="keyword">auto</span> it1 = v.begin();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></div><div class="line"><span class="keyword">auto</span> it2 = cv.begin();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line"><span class="keyword">auto</span> it3 = v.cbegin();<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></div><div class="line">（*it).empty()等于it-&gt;empty()<span class="comment">//it为迭代器</span></div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义数组时一定要保证数组的个数为常量，定义数组时一定要定义数组的类型，不能够是使用auto<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> cnt = <span class="number">12</span>;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> cnt1 = <span class="number">12</span>;<span class="comment">//常量表达式</span></div><div class="line"><span class="built_in">string</span> bad[cnt];<span class="comment">//错误，cnt不是常量表达式</span></div></pre></td></tr></table></figure></p>
<p>字符数组的特殊性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span><span class="comment">//自动添加表示字符串结束的空字符</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Deniel"</span>;<span class="comment">//错误，没有空间可存放空字符</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：不能够将数组拷贝给其他数组作为初始值</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int (*Parray)[<span class="number">10</span>] = <span class="meta">&amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span></div><div class="line">int (<span class="meta">&amp;arrRef)[10] = arr;<span class="comment">//arrRef引用一个含有10个整数的数组</span></span></div></pre></td></tr></table></figure>
<p><strong>指针和数组</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>];</div><div class="line"><span class="built_in">string</span> *p2 = nums;<span class="comment">//等价于string *p = &amp;nums[0];</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(nums)</span></span>;<span class="comment">//ia2是一个整形指针，指向ia的第一个元素</span></div></pre></td></tr></table></figure></p>
<p>数组输出全部元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *e = &amp;arr[<span class="number">10</span>];<span class="comment">//arr有10个元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = &amp;arr;b!=e;b++)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数组的函数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</div><div class="line">int *pbeg = begin(arr);</div><div class="line">int *pend = end(arr);</div><div class="line">while(pbeg != pend &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</div><div class="line">    ++pbeg;</div></pre></td></tr></table></figure></p>
<p>只有同一相关对象的指针才能够比较，不相关对象的指针不能够进行比较。</p>
<h3 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;</div><div class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</div><div class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];<span class="comment">//把row绑定到ia的第二个4元素数组上</span></div><div class="line"><span class="comment">//把row定义为一个含有4个整数的数组的引用，然后将其绑定到ia的第2行。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;引用为对象起了另外一个名字，引用类型引用另外一种类型，引用类型的初始值必须是一个对象。&lt;br&gt;&lt;code&gt;int &amp;amp;refVal4 
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ string字符串</title>
    <link href="https://caixueyuan.github.io/2018/09/09/string%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://caixueyuan.github.io/2018/09/09/string字符串/</id>
    <published>2018-09-09T15:14:50.000Z</published>
    <updated>2018-09-23T07:57:20.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化有两种，直接初始化和拷贝初始化。<br>拷贝初始化<code>string a = &#39;abc&#39;</code><br>直接初始化<code>string a {&#39;abc&#39;}</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>C++语法中的字符串字面值并不是标准库中的string的对象。字符串字面量和string是不同的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> a = <span class="string">"abc"</span>;</div><div class="line"><span class="built_in">string</span> b = a+<span class="string">"def"</span>+<span class="string">"ghi"</span>;<span class="comment">//正确，(a+"def")+"ghi"</span></div><div class="line"><span class="built_in">string</span> c = <span class="string">"def"</span>+<span class="string">"ghi"</span>+a；<span class="comment">//错误，("def"+"ghi")+a</span></div></pre></td></tr></table></figure>
<p>C++能够改变字符串中的字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s &#123;<span class="string">"abc"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;temp : s)</div><div class="line">&#123;</div><div class="line">    temp = <span class="built_in">toupper</span>(temp);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将第一个词变成大写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//isspace()使用这些函数时需要添加头文件#include&lt;cctype&gt;</span></div><div class="line"><span class="built_in">string</span> s1&#123;<span class="string">"Hello World!!!"</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s1.size()) index = <span class="number">0</span>; index &lt; s1.size() &amp;&amp; !<span class="built_in">isspace</span>(s1[index]); index++)</div><div class="line">&#123;</div><div class="line">    s1[index] = <span class="built_in">toupper</span>(s1[index]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p><code>string::size_type n</code>用于访问字符串的下标</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h
    
    </summary>
    
      <category term="C++" scheme="https://caixueyuan.github.io/categories/C/"/>
    
    
      <category term="C++基础" scheme="https://caixueyuan.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL表</title>
    <link href="https://caixueyuan.github.io/2018/08/12/MySQL%E8%A1%A8/"/>
    <id>https://caixueyuan.github.io/2018/08/12/MySQL表/</id>
    <published>2018-08-12T15:36:07.000Z</published>
    <updated>2018-09-23T07:57:23.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h2><p><strong>索引组织表</strong>：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主键<br><code>_rowid</code>可以显示表的主键，只能够查看单个列为主键的情况，并且为非空唯一索引。</p>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p>表空间（tablespace)–&gt;端（segment)—&gt;区（extent)—&gt;页（page)—&gt;块（block)</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。所有的数据都存放在这个表空间中。如果弃用了参数innodb_file_per_table，则每张表内的数据可以单独存放在一个表空间中。</p>
<p>表空间只存放数据、索引和插入缓冲Bitmap页，其他的数据（如回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）还是存放在原来的共享表空间中。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>常见的段有数据段、索引段、回滚段。数据段为B+树的叶子节点，而索引段为B+树的非索引节点</p>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>由连续页组成的空间，在任何情况下每个区的大小都是1MB，在默认情况下页的大小为16KB，即一个区中一共有64个连续的页。<br>可以通过参数innodb_page_size来设置默认页的大小</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>页是InnoDB磁盘管理的最小单位，默认每个页的大小为16KB。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>InnoDB存储引擎是面向列的，数据都是按照行来进行存放的，最多允许存放16KB/2-200行的记录，也就是7992行</p>
<h2 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h2><p>使用<code>show table status like &#39;table_name&#39;</code>来查看当前表使用的行格式。</p>
<h3 id="Compact行记录格式"><a href="#Compact行记录格式" class="headerlink" title="Compact行记录格式"></a>Compact行记录格式</h3><p>MySQL5.0引入的，其设计的目的是高效地存储数据。<br>一个页中存放的行数据越多，其性能就越高。<br>在compact格式下，NULL值都不占用任何存储空间，不管是CHAR类型或者是VARCHAR类型</p>
<h3 id="Redundant行记录格式"><a href="#Redundant行记录格式" class="headerlink" title="Redundant行记录格式"></a>Redundant行记录格式</h3><p>MySQL5.0之前的。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>BLOB可以不将数据放在溢出页面中，而且即使是VARCHAR列数据类型，依然有可能被存放为行溢出数据。通过实际测试，VARCHAR的类型的最大长度为65532.VARCHAR类型最大支持65535字节。</p>
<p>MySQL官方手册中定义的65535长度是指所有的VARCHAR列的长度总和，如果列的长度总和超过了这个长度，依然无法创建。</p>
<p>InnoDB存储引擎的页为16KB，也就是16384字节，在一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中。但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。</p>
<p>一个页存放数据，如果为两条数据的话，那么每条的最大的阈值为8098.</p>
<h3 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h3><p>InnoDB1.0.x引入新的文件格式，Compressed和Dynamic<br>新的两种记录格式对于存放在BLOB中的数据采用完全的行溢出的方式。同时，存储在其中的行数据会以zlib的算法进行压缩，</p>
<h3 id="CHAR的行结构存储"><a href="#CHAR的行结构存储" class="headerlink" title="CHAR的行结构存储"></a>CHAR的行结构存储</h3><p>对于多字节字符编码的CHAR数据类型的存储，InnoDB存储引擎在内部将其视为变长字符类型，在变长长度列表中会记录CHAR数据类型的长度</p>
<p>CHAR(2)保存的是2个字符，不管是GBK，还是UTF-8，还是latin，都是2个字符，而不是2个字节。所以存储的字节是变化的。</p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>包括7个部分：</p>
<blockquote>
<ul>
<li>File Header(文件头)</li>
<li>Page Header(页头)</li>
<li>infimum和Supremum Records</li>
<li>User Records（用户记录，即行记录）</li>
<li>Free Space（空闲空间）</li>
<li>Page Directory（页目录）</li>
<li>File Trailer(文件结尾信息)</li>
</ul>
</blockquote>
<h2 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引组织表&quot;&gt;&lt;a href=&quot;#索引组织表&quot; class=&quot;headerlink&quot; title=&quot;索引组织表&quot;&gt;&lt;/a&gt;索引组织表&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引组织表&lt;/strong&gt;：在InnoDB存储引擎中，表都是根据主键顺序组织存放的，每个表都是有主
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件</title>
    <link href="https://caixueyuan.github.io/2018/08/12/MySQL%E6%96%87%E4%BB%B6/"/>
    <id>https://caixueyuan.github.io/2018/08/12/MySQL文件/</id>
    <published>2018-08-12T09:42:46.000Z</published>
    <updated>2018-08-12T16:14:08.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><p>告诉MySQL实例启动时在哪里，指定初始化参数，定义某些内存结构的大小</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_buffer%'</span>;显示查询参数</div><div class="line"><span class="keyword">set</span> read_buffer_size = <span class="number">100100</span>;//设置查询参数</div><div class="line"><span class="keyword">select</span> @@session.read_buffer_size;</div></pre></td></tr></table></figure>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>记录影响MySQL数据库的各种类型活动</p>
<blockquote>
<ul>
<li><strong>错误日志</strong>:对MySQL的启动、运动、关闭过程进行记录，<code>Show Variables like &#39;log_error&#39;</code></li>
<li><strong>查询日志</strong>：记录了所有对MySQL数据库请求的信息。</li>
<li><strong>二进制日志</strong>：记录对MySQL数据库执行更改的所有操作，不包括SELECT和SHOW等操作<code>SHOW MASTER STATUS</code></li>
<li><strong>套接字</strong>：在Unix域套接字</li>
<li>pid文件：将自己的进程ID写入到一个文件中</li>
<li>表结构定义文件：MySQL数据的存储是根据表进行的，每个表都有与之对应的文件</li>
<li>InnoDB存储引擎文件：</li>
</ul>
</blockquote>
<p><strong>表空间文件</strong>：将存储的数据按照表空间进行存放的设计，在默认配置下为10M，多个文件可以组成一个表空间。<br>重做日志文件：当实例或者介质失败时，重做日志文件就有用，用来恢复数据</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数文件&quot;&gt;&lt;a href=&quot;#参数文件&quot; class=&quot;headerlink&quot; title=&quot;参数文件&quot;&gt;&lt;/a&gt;参数文件&lt;/h2&gt;&lt;p&gt;告诉MySQL实例启动时在哪里，指定初始化参数，定义某些内存结构的大小&lt;/p&gt;
&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="https://caixueyuan.github.io/2018/08/12/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://caixueyuan.github.io/2018/08/12/InnoDB存储引擎/</id>
    <published>2018-08-12T08:12:23.000Z</published>
    <updated>2018-08-12T09:42:12.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p><strong>后台线程</strong>：负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据，将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态</p>
<h3 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h3><blockquote>
<ul>
<li>Master Thread<br>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲和UNDO页的回收</li>
<li><p>IO Thread<br>负责异步IO请求的回调</p>
</li>
<li><p>Purge Thread<br>在事务被提交后，所使用的undolog可能不需要，负责来回收已经使用并分配的undo页。</p>
</li>
<li><p>Page Cleaner Thread<br>将之前版本中脏页的刷新操作都放入到单独的线程中来完成，减轻Master Thread的工作和对于用户查询线程的阻塞。</p>
</li>
</ul>
</blockquote>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><blockquote>
<ul>
<li><p>缓冲池：使用CheckPoint的机制刷新内存页，缓存的数据包括：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息。</p>
</li>
<li><p>LRU List、Free List和Flush List</p>
</li>
<li><p>重做日志缓冲</p>
</li>
</ul>
</blockquote>
<h3 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h3><blockquote>
<ul>
<li><p>插入缓冲：<br><strong>Insert Buffer</strong>：当索引是辅助索引，索引不是唯一的<br><strong>Change Buffer</strong>：对DML操作（INSERT,DELETE,UPDATE)进行缓冲<br><strong>Merge Insert Buffer</strong>：合并插入缓存到磁盘中</p>
</li>
<li><p>两次写：两次写入提高效率</p>
</li>
<li>自适应哈希索引：提高查询的效率，比B+树的查找更快</li>
<li>异步IO：将多个IO合并为1个IO请求</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;InnoDB体系结构&quot;&gt;&lt;a href=&quot;#InnoDB体系结构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系结构&quot;&gt;&lt;/a&gt;InnoDB体系结构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;后台线程&lt;/strong&gt;：负责刷新内存池中的数据，保证缓冲
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 学习笔记（一）</title>
    <link href="https://caixueyuan.github.io/2018/08/06/MySQL-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://caixueyuan.github.io/2018/08/06/MySQL-学习笔记（一）/</id>
    <published>2018-08-06T15:38:46.000Z</published>
    <updated>2018-08-06T16:05:52.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库与实例"><a href="#数据库与实例" class="headerlink" title="数据库与实例"></a>数据库与实例</h2><blockquote>
<ul>
<li>数据库：物理操作系统文件或者其他文件类型的集合</li>
<li>实例: 应用程序，数据库程序真正操作与数据库文件</li>
</ul>
</blockquote>
<p><strong>注意</strong>：MySQL是一个单进程多线程的数据库，使用代码来查找<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> mysqld</div></pre></td></tr></table></figure></p>
<p>查看配置文件的位置，用mysql–help.</p>
<p>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合，数据库实例是应用程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义等等都是在数据库实例下进行的，应用程序只有通过数据库实例才能够与数据库打交道</p>
<p><img src="https://raw.githubusercontent.com/caixueyuan/caixueyuan.github.io-picture/master/sql/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="MySQL体系结构"></p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎对于MySQL来说是可插拔的</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>特点：支持事务，行级锁，支持外键，非锁定读（也就是说默认读取活动不会产生锁）<br>每张表的存储都是按照主键的顺序来存储的</p>
<h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>特点：不支持事务，表锁设计，支持全文索引，同时有一个大的不同就是只缓存索引文件而不缓存数据文件</p>
<p>可以使用<code>show engines</code>来显示所用的存储引擎</p>
<h2 id="链接MySQL的方式"><a href="#链接MySQL的方式" class="headerlink" title="链接MySQL的方式"></a>链接MySQL的方式</h2><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>这是默认的方式，<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">-h</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1</span> <span class="selector-tag">-u</span> <span class="selector-tag">dbuser</span> <span class="selector-tag">-p</span></div></pre></td></tr></table></figure></p>
<p>可以使用mysql数据库下的user表来查看用户的信息</p>
<h3 id="命名管道或者共享内存"><a href="#命名管道或者共享内存" class="headerlink" title="命名管道或者共享内存"></a>命名管道或者共享内存</h3><p>Windows中的，只要使用–enable-named-pipe</p>
<h3 id="Unix-域套接字"><a href="#Unix-域套接字" class="headerlink" title="Unix 域套接字"></a>Unix 域套接字</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u dbuser -s <span class="regexp">/tmp/my</span>sql.sock</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库与实例&quot;&gt;&lt;a href=&quot;#数据库与实例&quot; class=&quot;headerlink&quot; title=&quot;数据库与实例&quot;&gt;&lt;/a&gt;数据库与实例&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据库：物理操作系统文件或者其他文件类型的集合&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://caixueyuan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle</title>
    <link href="https://caixueyuan.github.io/2018/08/01/Oracle/"/>
    <id>https://caixueyuan.github.io/2018/08/01/Oracle/</id>
    <published>2018-07-31T16:01:18.000Z</published>
    <updated>2018-08-06T16:05:02.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><strong>多表插入</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">insert</span> all</div><div class="line"> <span class="keyword">when</span> sum_order &lt;<span class="number">10000</span> <span class="keyword">then</span></div><div class="line"> <span class="built_in">int</span> small_customers</div><div class="line"> <span class="keyword">when</span> sum_orders &gt;= <span class="number">10000</span> <span class="keyword">and</span> sum_orders &lt; <span class="number">100000</span> <span class="keyword">then</span></div><div class="line"> <span class="built_in">int</span> medium_customers</div><div class="line"> <span class="keyword">else</span></div><div class="line"> <span class="keyword">into</span> large_customers</div><div class="line"> <span class="keyword">select</span> customer_id,<span class="keyword">sum</span>(order_total)</div><div class="line"> <span class="keyword">from</span> oe.orders</div><div class="line"> <span class="keyword">group</span> <span class="keyword">by</span> customer_id;</div></pre></td></tr></table></figure></p>
<h2 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL执行</h2><h3 id="共享池"><a href="#共享池" class="headerlink" title="共享池"></a>共享池</h3><p>就是内存中缓存用户进行SQL查询的一块空间。不管有多少个用户想要执行同样的SQL语句，Oracle都会只解析该语句一次，然后在想要使用的用户之间共享。</p>
<p>在执行每一句SQL语句时必然会发生的事情是它必须被解析并载入到库高速缓存中，库高速缓存是共享池中用来保存之前已经解析过的语句区域。当解析通过之后，就要确定这个语句是否执行过。如果已经执行过，那就是软解析，直接得到解析的过程。如果没有找到语句，那就要生成执行计划，这叫做硬解析。<br>锁存器是为了检查你要执行的SQL语句是否已经存在而要在库高速缓存中获取一个锁存器。而互斥锁是为了阻止多个线程同时访问一个共享结构。</p>
<p>绑定变量能够很好地减少硬编码，提高效率</p>
<p><strong>重要</strong>：</p>
<blockquote>
<ul>
<li>数据的写入器不会阻塞数据读取器。重复一遍：写入不阻塞读取。这和其他大部分数据库从根本上是不同的，其他数据库写入阻塞读取。</li>
<li>用OPEN 命令返回<br>的结果集，当打开表时，接触的已不是表中的单块数据，而是已经确定好的结果。在提取数据之前，并不知道结果。然而从游标上看，结果是不会变的。打开游标时，Oracle 并不是把上面所有数据复制到其他地方；实际上是delete命令把数据复制到一个称为回滚段的数据区域保存。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本语句&quot;&gt;&lt;a href=&quot;#基本语句&quot; class=&quot;headerlink&quot; title=&quot;基本语句&quot;&gt;&lt;/a&gt;基本语句&lt;/h2&gt;&lt;h3 id=&quot;insert&quot;&gt;&lt;a href=&quot;#insert&quot; class=&quot;headerlink&quot; title=&quot;inser
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Oracle" scheme="https://caixueyuan.github.io/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>T-SQL</title>
    <link href="https://caixueyuan.github.io/2018/07/29/T-SQL/"/>
    <id>https://caixueyuan.github.io/2018/07/29/T-SQL/</id>
    <published>2018-07-29T08:49:12.000Z</published>
    <updated>2018-07-29T16:07:45.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>定义用户数据类型<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sp_addtype dbname2,<span class="symbol">'varchar</span>(<span class="number">10</span>)<span class="string">','</span><span class="keyword">not</span> null'</div></pre></td></tr></table></figure></p>
<p>显示用户定义的数据类型<strong>sp_help</strong><br>删除用户定义的数据类型<strong>sp_droptype dbname2</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="meta">@var</span>1 <span class="keyword">int</span><span class="comment">//定义局部变量</span></div><div class="line"><span class="keyword">declare</span> @<span class="meta">@var</span>2 <span class="keyword">int</span><span class="comment">//定义全局变量</span></div></pre></td></tr></table></figure>
<h3 id="数据库设备"><a href="#数据库设备" class="headerlink" title="数据库设备"></a>数据库设备</h3><p>使用SQL命令创建数据库设备<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Disk Init</div><div class="line">name = 'mydev2',</div><div class="line">physname = 'e:\devices\mydev2.dat',</div><div class="line">vdevno = 2,</div><div class="line">size = 1024</div><div class="line">go</div></pre></td></tr></table></figure></p>
<p>指定默认的数据库设备<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_diskdefault</span> mydev,defaulton</div></pre></td></tr></table></figure></p>
<p>显示数据库设别的信息<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_diskdefault</span> mydev,defaultoff</div></pre></td></tr></table></figure></p>
<p>删设备<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">sp_dropdevice</span> logical_name</div></pre></td></tr></table></figure></p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sp_rename objname,newname<span class="comment">//修改名字</span></div><div class="line">Alter <span class="keyword">table</span> newroysched <span class="comment">partition 4</span>//将表所在的段分割表</div><div class="line">sp_help,sp_helpartition.<span class="comment">//查看表的分割信息</span></div><div class="line">alter <span class="keyword">table</span> newroysched <span class="comment">unpartition</span>//删除表的分割</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">unique</span>(clustered) <span class="keyword">index</span> <span class="keyword">on</span> tablename.columnname//创建索引</div><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span> tablename.columnname//删除索引</div></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create <span class="keyword">default</span> datefault <span class="keyword">as</span> getdate()<span class="comment">//创建默认值</span></div><div class="line">sp_binddefault datefault,<span class="string">"sale.date"</span><span class="comment">//对列关联默认值</span></div></pre></td></tr></table></figure>
<p><strong>规则</strong>：当进行insert或者update操作时，自动用关联的规则，检查所输入的数据的有效性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> Rule daterule <span class="keyword">as</span> @pub_id <span class="keyword">between</span> <span class="string">"1900.1.1"</span> <span class="keyword">and</span> <span class="keyword">getdate</span>()//创建故障</div><div class="line">sp_birdrule Rule_Name <span class="string">"sale.date"</span>//对列关联规则</div></pre></td></tr></table></figure>
<p><strong>视图</strong>：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">view</span> pub_view <span class="keyword">as</span></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span></div></pre></td></tr></table></figure></p>
<p>使用With Check Option选项允许检查视图的数据，有利于从视图中删除不良的DML语句</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="数据库" scheme="https://caixueyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://caixueyuan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Spring Boot&#39;</title>
    <link href="https://caixueyuan.github.io/2018/06/22/Spring-Boot/"/>
    <id>https://caixueyuan.github.io/2018/06/22/Spring-Boot/</id>
    <published>2018-06-22T07:41:42.000Z</published>
    <updated>2018-06-22T08:03:17.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot核心"><a href="#Spring-Boot核心" class="headerlink" title="Spring Boot核心"></a>Spring Boot核心</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong>@SpringBootApplication</strong>:表示一个入口类<br><strong>@EnableAutoConfiguration</strong>:让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置</p>
<blockquote>
<ul>
<li>Spring-boot-starter-web:自动添加Tomcat和Spring MVC的依赖</li>
<li>spring-boot-starter-data-jpa:自动进行JPA相关的配置</li>
</ul>
</blockquote>
<p><strong>关闭特定的自动配置</strong>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**使用XML配置**:```@ImportResource(&#123;&quot;classpath:some-context.xml&quot;,&quot;classpath:another-context.xml&quot;&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Boot核心&quot;&gt;&lt;a href=&quot;#Spring-Boot核心&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot核心&quot;&gt;&lt;/a&gt;Spring Boot核心&lt;/h2&gt;&lt;h3 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot;
    
    </summary>
    
      <category term="Java框架" scheme="https://caixueyuan.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="https://caixueyuan.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>&#39;SpringBoot-Spring-Security-JWT-登陆&#39;</title>
    <link href="https://caixueyuan.github.io/2018/04/14/SpringBoot-Spring-Security-JWT-%E7%99%BB%E9%99%86/"/>
    <id>https://caixueyuan.github.io/2018/04/14/SpringBoot-Spring-Security-JWT-登陆/</id>
    <published>2018-04-14T15:59:24.000Z</published>
    <updated>2018-04-15T12:45:45.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-Spring-Security-JWT-登陆"><a href="#SpringBoot-Spring-Security-JWT-登陆" class="headerlink" title="SpringBoot Spring Security JWT 登陆"></a>SpringBoot Spring Security JWT 登陆</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/2409835-4798863c521de365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/641" alt="JWT SpringBoot"></p>
<p>传统的登陆验证方式主要是Cookie认证机制，为解决HTTP无状态协议下服务器如何识别用户的问题，其原理是在用户登陆通过验证后，服务器将数据加密后保存到客户端浏览器的Cookie中，同时，服务器保留相应的Session，用户之后发起的请求都会携带Cookie信息，服务端根据Cookie寻回对应的session，完成验证。<br>缺点：</p>
<blockquote>
<ul>
<li>session保存到服务器内存中，每次请求都要携带Cookie，占据带宽，服务器开销明显增大</li>
<li>扩展性：在分布式应用上，限制了负载均衡器的能力和扩展能力</li>
<li>CSRF和XSS攻击：Cookie存放在客户端，Cookie很容易被获取，进行跨站请求伪造攻击</li>
</ul>
</blockquote>
<p><strong>JWT Spring boot</strong><br>构成：</p>
<blockquote>
<ul>
<li>header，声明类型，加密算法</li>
<li>playload(载荷）,标准注册声明，公共声明，私有声明</li>
<li>signature：服务器端的私钥</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>使用JSON，可以进行跨语言支持</li>
<li>便于传输，构成简单，字节占用很小</li>
<li>不需要在服务器保存会话信息，易于应用扩展</li>
<li>防止XSS攻击</li>
<li>保证前后端分离</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>客户通过将其凭据发送给身份提供者进行登录。</li>
<li>身份提供者验证凭证; 如果一切正常，它将检索用户数据，生成一个包含将用于访问服务的用户详细信息和权限的JWT，并且还会在JWT（可能不受限制）上设置到期日期。</li>
<li>身份提供商签名，并在需要时加密JWT，并将其作为初始请求的凭据响应发送给客户端。</li>
<li>客户根据身份提供商设置的有效期限将JWT存储有限或无限的时间。</li>
<li>客户端将每个请求的授权标头中存储的JWT发送给服务提供商。</li>
<li>对于每个请求，服务提供者都从Authorization头部获取JWT 并对其进行解密（如果需要），验证签名，如果一切正常，则提取用户数据和权限。仅根据这些数据，再次查看数据库中的进一步细节或联系身份提供者，它可以接受或拒绝客户端请求。唯一的要求是身份和服务提供商就加密达成一致，以便服务可以验证签名或甚至解密哪个身份已加密。</li>
</ul>
</blockquote>
<p><a href="https://www.jianshu.com/p/ec9b7bc47de9" target="_blank" rel="external">查看博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot-Spring-Security-JWT-登陆&quot;&gt;&lt;a href=&quot;#SpringBoot-Spring-Security-JWT-登陆&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Spring Security
    
    </summary>
    
      <category term="毕业设计" scheme="https://caixueyuan.github.io/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="毕业设计" scheme="https://caixueyuan.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JQuery基础知识</title>
    <link href="https://caixueyuan.github.io/2018/04/06/JQuery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://caixueyuan.github.io/2018/04/06/JQuery基础知识/</id>
    <published>2018-04-06T07:26:55.000Z</published>
    <updated>2018-04-11T08:50:22.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识JQuery"><a href="#认识JQuery" class="headerlink" title="认识JQuery"></a>认识JQuery</h2><h3 id="JQuery和JavaScript的转换"><a href="#JQuery和JavaScript的转换" class="headerlink" title="JQuery和JavaScript的转换"></a>JQuery和JavaScript的转换</h3><hr>
<p>JQuery对象转换为DOM对象</p>
<blockquote>
<ul>
<li><p>通过[index]的方法得到相应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</div><div class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>通过get(index)方法得到相应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</div><div class="line"><span class="keyword">var</span> cr = $cr.get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<hr>
<hr>
<p>DOM对象转化为JQuery对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cr = <span class="built_in">document</span>.getElementById(<span class="string">"cr"</span>);</div><div class="line"><span class="keyword">var</span> $cr = $(cr);</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</div><div class="line">cr.checked</div><div class="line"></div><div class="line">$cr.is(<span class="string">":checked"</span>)</div></pre></td></tr></table></figure>
<h3 id="解决jQuery和其他库的冲突"><a href="#解决jQuery和其他库的冲突" class="headerlink" title="解决jQuery和其他库的冲突"></a>解决jQuery和其他库的冲突</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//(1)自定义快捷方式</span></div><div class="line"><span class="keyword">var</span> $j = jQuery.noConflict();</div><div class="line"></div><div class="line"><span class="comment">//(2)在函数内部默认都是指定jQuery</span></div><div class="line">jQuery.noconflict();</div><div class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert($(<span class="keyword">this</span>).text));</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="jQuery选择器的优势"><a href="#jQuery选择器的优势" class="headerlink" title="jQuery选择器的优势"></a>jQuery选择器的优势</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    $(<span class="string">'#tt'</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);<span class="comment">//如果没有元素tt的话，就不会执行下面的语句</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="jQuery选择器-1"><a href="#jQuery选择器-1" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><p><strong>层次选择器</strong>：</p>
<p><code>$(&quot;body div&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变<body>内所有<div>的背景色，将整个div的都改变背景色<br><code>$(&#39;body &gt; div&#39;).css(&#39;background&#39;,&quot;#bbffaa&quot;)</code>改变<body>内子<div>元素的背景色，将整个div中不包括子元素的空白部分改变背景色</div></body></div></body></p>
<p><strong>过滤选择器</strong><br><code>$(&#39;:header&#39;)</code>选取网页中的所有的</p><h1>，<h2>,<h3><br><code>$(&#39;:animated&#39;)</code>选取当前正在执行动画的所有元素<br><code>$(&#39;:focus&#39;)</code>选取当前获取焦点的元素<p></p>
<p><strong>内容过滤选择器</strong><br><code>$(&quot;div:parent&quot;)</code>选择拥有子元素的<div>元素</div></p>
<p><strong>可见性过滤选择器</strong><br><code>$(&quot;:hidden&quot;)</code>选取所有不可见的元素。包括<code>&lt;input type=&quot;hidden&quot;/&gt;</code>,<code>&lt;div style=&quot;display:none;&quot;&gt;</code>和<code>&lt;div style=&quot;visibility:hidden;&quot;&gt;</code><br><code>$(&#39;:visible)</code>选取所有可见的元素</p>
<p><strong>属性过滤选择器</strong><br><code>$(&quot;div[title|= &#39;en&#39;]&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变属性title等于en或者以en为前缀的元素的背景色<br><code>$(&quot;div[title ~= &#39;uk&#39;]&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;);</code>改变属性title用空格分隔的值中包含uk的元素的背景色</p>
<p><strong>子元素过滤选择器</strong><br><code>:nth-child(index/even/odd/equation)</code>选取每个父元素下的第index个子元素或者奇偶元素（index从1算起）</p>
<p><strong>表单对象属性过滤选择器</strong><br><code>:selected</code>:选取所有被选中的选项元素,下拉列表<br><code>:checked</code>:选取所有被选中的元素，单选框和复选框</p>
<h2 id="jQuery中的DOM操作"><a href="#jQuery中的DOM操作" class="headerlink" title="jQuery中的DOM操作"></a>jQuery中的DOM操作</h2><blockquote>
<ul>
<li><p><strong>remove()</strong>和<strong>detach()</strong>：都是从DOM中去掉所有匹配的元素，这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove()不同的是，所有绑定的事件、附加的数据都会保留下来</p>
</li>
<li><p><strong>empty()</strong>：清空节点，清空元素中的所有后代节点</p>
</li>
<li><p><strong>clone()</strong>复制节点后，被复制的新元素并不具有任何行为，如果需要新元素也具有复制功能（绑定在元素中的事件），应该加上true</p>
</li>
<li>replaceWith()将所有匹配的元素都替换成指定的HTML或者DOM元素</li>
<li>wrapAll()将所有匹配的元素用一个元素包裹起来</li>
<li>wrapInner()将每一个匹配的元素的子内容（包括文本节点）用其他结构的标记包裹起来</li>
<li>attr()可以获取或者设置元素的属性</li>
<li><p>toggle()交替执行代码3和代码4，如果元素原来是显示的，那么隐藏她，如果是隐藏的，那么显示它。也就是控制行为上的重复切换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$toggleBtn.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//3</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></div><div class="line">    <span class="regexp">//</span><span class="number">4</span></div><div class="line">));</div></pre></td></tr></table></figure>
</li>
<li><p>html()读取或者设置某个元素中的HTML内容，相当于innerHTML</p>
</li>
<li>text()读取或者设置某个元素中的文本内容，相当于innerText属性</li>
<li>this.defaultValue就是当前文本框的默认值</li>
<li><p>val()不仅能设置元素的值，通过也能够获取元素的值，还能够使得select，checkbox，radio相应的选项被选中</p>
</li>
<li><p>children()获取匹配元素的所有子元素的个数</p>
</li>
<li>next(),prev()匹配元素前面近邻的同辈元素</li>
<li>siblings()获取匹配元素的所有兄弟节点</li>
<li>closest()取得最近的匹配元素，首先检查当前元素是否匹配的，如果匹配则直接返回元素本身，如果不匹配，向上查找父元素，逐渐向上直到找到匹配选择器的元素。</li>
<li>offset()获取元素在当前视窗的相对偏移</li>
<li>position()获取元素相对于最近的一个position样式设置为relative或者absolute的祖先节点的相对偏移</li>
<li>scrollTop()和scrollLeft()获取元素的滚动条据顶端的距离和距离左侧的距离</li>
</ul>
</blockquote>
<hr>
<p><strong>parent()</strong>和<strong>parents()</strong>和<strong>closest</strong>的区别<br><strong>parent</strong>获取集合中的每个匹配元素的父级元素<br><strong>parents</strong>获取集合中的每个匹配元素的祖先元素，包括父级，父级以上</p>
<h2 id="closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素"><a href="#closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素" class="headerlink" title="closest：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素"></a><strong>closest</strong>：从元素本身开始，逐渐向上级元素匹配，并返回最先匹配的祖先元素</h2><h2 id="jQuery中的事件和动画"><a href="#jQuery中的事件和动画" class="headerlink" title="jQuery中的事件和动画"></a>jQuery中的事件和动画</h2><h3 id="jQuery中的事件"><a href="#jQuery中的事件" class="headerlink" title="jQuery中的事件"></a>jQuery中的事件</h3><p><strong>$(document).ready()</strong>和<strong>window.onload</strong></p>
<blockquote>
<ul>
<li>window.onload方法是在$(document).ready()网页中所有元素完全加载到浏览器后才执行，即JavaScript此时才可以访问网页中的任何元素<br>$(document).ready()在DOM完全就绪时就可以被调用，此时，网页中所有元素对jQuery而言都是可以访问的，但是，并不意味着这些元素关联按的文件都已经下载完备</li>
<li>window.onload事件一次只能够保存对一个函数的引用，因此不能在现有的行为上添加新的行为，<br>$(document).ready()会在现有的行为上追加新的行为，会根据注册的顺序依次执行</li>
</ul>
</blockquote>
<p><strong>event.stopPropagation()</strong>:停止事件冒泡<br><strong>event.preventDefault</strong>：阻止元素的默认行为<br><strong>event.type</strong>:获取到事件的类型<br><strong>event.target</strong>:获取到触发事件的元素<br><strong>event.pageX</strong>:获取到光标相对于页面的x坐标和y坐标<br><strong>event.which</strong>:在鼠标单击事件中获取到鼠标的左右中键<br><strong>event.metaKey</strong>:获取<ctrl>按键</ctrl></p>
<p><strong>trigger()</strong>:模拟操作，比如模拟单击按钮来触发click事件，或者触发自定义事件<br><strong>triggerHandler()</strong>触发事件而不是触发默认事件<br><strong>trigger(“click”)</strong>:匹配所有不包含在命名空间中的click方法</p>
<h3 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h3><p><strong>fadeIn()</strong>和<strong>fadeOut()</strong>只改变元素的不透明度，直到元素完全消失<br><strong>slideUp()</strong>和<strong>slideDown()</strong>:只会改变元素的高度，down是由上向下延伸显示，而up是由下到上缩短隐藏</p>
<p><strong>stop()</strong>:第一个参数设置为true，会吧当前元素接下来的动画队列都清空，第二个参数可以用于让正在执行的动画直接到达结束时刻的状态，通常用于后一个动画需要基于前一个动画的末状态的情况<br><strong><code>:animatd</code></strong>:判断元素是否正处于动画状态<br><strong><code>decay()</code></strong>:延迟操作</p>
<h2 id="jQuery对表单、表格的操作及更多应用"><a href="#jQuery对表单、表格的操作及更多应用" class="headerlink" title="jQuery对表单、表格的操作及更多应用"></a>jQuery对表单、表格的操作及更多应用</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.focus</span>&#123;</div><div class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#f00</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#fcc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="string">":input"</span>).focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="keyword">this</span>).addClass(<span class="string">"focus"</span>);</div><div class="line">    &#125;)</div><div class="line">    .blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="keyword">this</span>).removeClass(<span class="string">"focus"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>keyup</code>事件能在用户每次松开按键时触发，实现即时提醒</p>
<p><code>$(&quot;tr:odd&quot;)</code>和<code>$(&quot;tr:even&quot;)</code>选择器中索引是从0开始的，因为第1行是偶数</p>
<p>load()方法通常用来从Web服务器上获取静态的数据文件</p>
</h3></h2></h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;认识JQuery&quot;&gt;&lt;a href=&quot;#认识JQuery&quot; class=&quot;headerlink&quot; title=&quot;认识JQuery&quot;&gt;&lt;/a&gt;认识JQuery&lt;/h2&gt;&lt;h3 id=&quot;JQuery和JavaScript的转换&quot;&gt;&lt;a href=&quot;#JQuery和Ja
    
    </summary>
    
      <category term="JQuery学习笔记" scheme="https://caixueyuan.github.io/categories/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JQuery学习笔记" scheme="https://caixueyuan.github.io/tags/JQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 API</title>
    <link href="https://caixueyuan.github.io/2018/04/02/HTML5-API/"/>
    <id>https://caixueyuan.github.io/2018/04/02/HTML5-API/</id>
    <published>2018-04-02T12:33:51.000Z</published>
    <updated>2018-04-11T08:50:25.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><code>navigator.geolocation.getCurrentPosition()</code>获取用户当前位置<br><code>navigator.geolocation.watchPosition()</code>获取当前位置，同时不断地检视当前位置<br><code>navigator.gerlocation.clearWatch()</code>停止检视用户位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取经纬度</span></div><div class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">pos</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> latitude = pos.coords.latitude;</div><div class="line">    <span class="keyword">var</span> longitude = pos.coords.longitude;</div><div class="line">    alert(<span class="string">"Your position:"</span> + latitude+<span class="string">", "</span>+longitude);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过获取地理位置信息在地图上显示当前位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getmap</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!navigator.geolocation)</div><div class="line">        <span class="keyword">throw</span> <span class="string">"Geolocation not supported"</span>;</div><div class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">    navigator.geolocation.getCurrentPosition(setMapURL);</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMapURL</span>(<span class="params">pos</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> latitude = pos.coords.latitude;</div><div class="line">    <span class="keyword">var</span> longitude = pos.coords.longitude;</div><div class="line">    <span class="keyword">var</span> accuracy = pos.coords.accuracy;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> url = <span class="string">"http://maps.google.com/maps/api/staticmap"</span>+</div><div class="line">        <span class="string">"?center = "</span>+latitude + <span class="string">", "</span>+longitude +<span class="string">"&amp;size = 640*640&amp;sensor=true"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> zoomlevel = <span class="number">20</span>;</div><div class="line">    <span class="keyword">if</span>(accuracy &gt; <span class="number">80</span>)</div><div class="line">        zoomlevel -= <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.log(accuracy/<span class="number">50</span>)/<span class="built_in">Math</span>.LN2);</div><div class="line">        url += <span class="string">"&amp;zoom="</span>+zoomlevel;</div><div class="line"></div><div class="line">        image.src= url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="历史记录管理"><a href="#历史记录管理" class="headerlink" title="历史记录管理"></a>历史记录管理</h2><p><code>location.hash</code>会更新显示在地址栏中的URL，同时会在浏览器的历史记录中添加一条记录。hash属性设置URL的片段标识符，通过是用于指定要滚动到的文档中的某一部分的ID，它可以设置成任何的字符串</p>
<p>支持HTML5的浏览器一旦发现片段标识符发生了改变，就会在Window对象上触发一个hashchange事件，可以通过设置onhashChange为一个处理程序函数</p>
<p>HTML5，该方法包含了history.pushStatus()方法和popstate事件，当一个Web应用进入一个新的状态的时候，会调用history.pushState()方法将该状态添加到浏览器的浏览历史记录中。</p>
<p>还有另外一个方法，history.replaceState()，用新的状态来代替当前的历史状态</p>
<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><p>客户端JavaScript都是单线程</p>
<p>Web Workers处在一个自包含的执行环境中，无法访问Window对象和Document对象，和主线程之间的童心也只能通过异步消息传递机制来实现，并行改变DOM是不可能的</p>
<h3 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a>Worker对象</h3><p><code>var loader = new Worker(&quot;utils/loader.js&quot;);</code><br>如果指定的URL采用的是绝对路径，要保证该脚本的文档是同源的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;地理位置&quot;&gt;&lt;a href=&quot;#地理位置&quot; class=&quot;headerlink&quot; title=&quot;地理位置&quot;&gt;&lt;/a&gt;地理位置&lt;/h2&gt;&lt;p&gt;&lt;code&gt;navigator.geolocation.getCurrentPosition()&lt;/code&gt;获取用户当前位
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript学习笔记" scheme="https://caixueyuan.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
