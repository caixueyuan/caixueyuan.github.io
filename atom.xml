<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caixueyuan</title>
  <subtitle>SCUT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caixueyuan.github.io/"/>
  <updated>2017-07-23T14:53:18.196Z</updated>
  <id>https://caixueyuan.github.io/</id>
  
  <author>
    <name>caixueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java集合</title>
    <link href="https://caixueyuan.github.io/2017/07/23/Java%E9%9B%86%E5%90%88/"/>
    <id>https://caixueyuan.github.io/2017/07/23/Java集合/</id>
    <published>2017-07-23T08:10:23.000Z</published>
    <updated>2017-07-23T14:53:18.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="Java中集合的接口的继承关系图"><a href="#Java中集合的接口的继承关系图" class="headerlink" title="Java中集合的接口的继承关系图"></a>Java中集合的接口的继承关系图</h3><p><img src="http://images.cnitblog.com/blog/490648/201308/18174126-653273ab5abe491bb9724353360ed252.png" alt="Java集合"></p>
<p>1,<strong><code>Set</code></strong>:</p>
<p><strong>TreeSet</strong>：在这里是要进行排序的，</p>
<blockquote>
<ul>
<li>自然排序（Comparable）：<br>TreeSet类的add会对对象实例的compareTo()方法和集合中的对象进行比较，根据比较的结果来进行排序</li>
<li>比较器顺序（Comparator）：<br>在外部创建一个比较器来进行比较对象的大小</li>
</ul>
</blockquote>
<p><strong>HashSet</strong>：这是一个实现类</p>
<blockquote>
<ul>
<li>不能够保证元素的排列顺序</li>
</ul>
</blockquote>
<p><strong>LinkedHashSet</strong>：集成于HashSet</p>
<blockquote>
<ul>
<li>能够进行排序（根据hashcode来决定元素的存储位置，同时使用链表维护元素的次序</li>
</ul>
</blockquote>
<p><strong>EnumSet</strong>:专门为枚举类设计，能够枚举各个属性</p>
<p><strong>List接口</strong></p>
<blockquote>
<ul>
<li><strong>ArrayList</strong>:数组（适合随机的set和get）</li>
<li><strong>Vector</strong>：数组，线程安全，但是效率较低</li>
<li><strong>LinkedList</strong>：链表（适合更多的新增或者删除）（是一个双向链表）</li>
</ul>
</blockquote>
<p><strong>Queue</strong>:队列，先进先出</p>
<blockquote>
<ul>
<li>Deque:双端队列，能够在双端中增加或者删除，使用Stack</li>
<li>PriorityQueue:能够进行排序，也是先进先出的。</li>
</ul>
</blockquote>
<p><strong>HashMap</strong>：<br><strong>Hashtable</strong>：</p>
<blockquote>
<ul>
<li>Hashtable在遇到null时，会抛出NullPointException异常</li>
<li>线程安全</li>
<li>通过Initial Capacity和Load Factor两个参数来调整性能，通常来说Load Factor为0.75，较好地实现时间和空间的均衡，增大Load Factor可以节省空间但相应的查找时间会增加<br><strong>HashMap</strong>：</li>
<li>HashMap是支持null键和null值的</li>
<li>线程不安全</li>
<li>将Key做Hash算法，然后将Hash值映射到内存地址，直接取得Key对应的数据</li>
</ul>
</blockquote>
<p><strong>TreeMap</strong>:</p>
<blockquote>
<ul>
<li>按照顺序进行排列（红黑树）</li>
<li>插入和删除比HashMap的效率低一些，但是呢，有序</li>
</ul>
</blockquote>
<p><strong>WeakhashMap</strong>:是一种弄改进的HashMap，对Key实现“弱引用”,如果一个Key不再被外部引用，那么该Key可能被GC回收。如果Key没有其他的引用，那么Map会自动丢弃该值。</p>
<blockquote>
<ul>
<li>特别之处在于WeakHashMap里的Entry可能会被GC自动删除，即使程序员没有调用remove或者clear方法</li>
</ul>
<ul>
<li>可能会出现以下的现象：</li>
</ul>
<p>调用两次size()方法返回不同的值；<br>两次调用isEmpty()方法，第一次返回false，第二次返回true；<br>两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key；<br>两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。</p>
</blockquote>
<p>弱引用（WeakReference）：通过GC自动管理，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</p>
<p><strong>LinkedHashMap</strong>:根据元素增加或者访问的先后顺序进行排序，而TreeMap根据元素的Key的大小来进行排序</p>
<h3 id="Java的四种引用："><a href="#Java的四种引用：" class="headerlink" title="Java的四种引用："></a>Java的四种引用：</h3><blockquote>
<ul>
<li>强引用：垃圾收集机制绝不会回收它，当内存空间出现不足，Java虚拟机抛出OutOfMemoryError错误，使得程序异常终止</li>
<li>软引用：内存空间足够，不会回收；内存空间不足，回收</li>
<li>弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
<li>虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中</li>
</ul>
</blockquote>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><blockquote>
<ul>
<li><code>expungeStaleEntries</code>:会在大部分共有方法中被调用，将ReferenceQueue中所有的失效的引用从Map中去除</li>
<li>WeakHashMap的Key是弱引用，Value不是。WeakHashMap不会自动释放失效的弱引用，仅当包含了expungeStaleEntries（）的公有方法被调用的时候才会释放</li>
</ul>
</blockquote>
<h3 id="用弱引用堵住内存泄露"><a href="#用弱引用堵住内存泄露" class="headerlink" title="用弱引用堵住内存泄露"></a>用弱引用堵住内存泄露</h3><p>要让垃圾收集（GC）回收程序不再使用的对象，对象的逻辑 生命周期（应用程序使用它的时间）和对该对象拥有的引用的实际 生命周期必须是相同的</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new HashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">    public void removeUser(Socket s) &#123;</div><div class="line">        m.<span class="builtin-name">remove</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">SocketManager socketManager;</div><div class="line">socketManager.setUser(socket, user);</div></pre></td></tr></table></figure>
<p>如果没有显性的删除和增加，那么Socket和User对象都会一直存在于内存中，可能会出现OutOfMemoryError</p>
<p>对于大多数程序来说，可以将内存使用分为两部分：baseline 使用和 current load 使用。对于服务器应用程序，baseline 使用就是应用程序在没有任何负荷、但是已经准备好接受请求时的内存使用，current load 使用是在处理请求过程中使用的、但是在请求处理完成后会释放的内存。只要负荷大体上是恒定的，应用程序通常会很快达到一个稳定的内存使用水平。如果在应用程序已经完成了其初始化并且负荷没有增加的情况下，内存使用持续增加，那么程序就可能在处理前面的请求时保留了生成的对象。</p>
<p>SocketManager 的问题是 Socket-User 映射的生命周期应当与 Socket 的生命周期相匹配。弱引用是对一个对象（称为 referent）的引用的持有者。使用弱引用后，可以维持对 referent 的引用，而不会阻止它被垃圾收集。当垃圾收集器跟踪堆的时候，如果对一个对象的引用只有弱引用，那么这个 referent 就会成为垃圾收集的候选对象，就像没有任何剩余的引用一样，而且所有剩余的弱引用都被清除。（只有弱引用的对象称为弱可及（weakly reachable）。）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class SocketManager &#123;</div><div class="line">    private Map&lt;Socket,User&gt; m = new WeakHashMap&lt;Socket,User&gt;();</div><div class="line">     </div><div class="line">    public void setUser(Socket s,<span class="built_in"> User </span>u) &#123;</div><div class="line">        m.put(s, u);</div><div class="line">    &#125;</div><div class="line">    public<span class="built_in"> User </span>getUser(Socket s) &#123;</div><div class="line">        return m.<span class="builtin-name">get</span>(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WeakReference.get() 是否返回 null 来区分死的映射和活的映射.可以通过周期性地扫描 Map，对每一个弱引用调用 get()，并在 get() 返回 null 时删除那个映射而消除死映射</p>
<p>WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射.用引用队列代替定期扫描内容的方法来清理 Map 更有效，因为清理过程不会触及活的项，只有在有实际加入队列的引用时它才工作<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> expungeStaleEntries() &#123;</div><div class="line">Entry&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">while</span> ( (e = (Entry&lt;K,V&gt;) queue.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> hash = e.hash;</div><div class="line">        Entry&lt;K,V&gt; prev = getChain(hash);</div><div class="line">        Entry&lt;K,V&gt; cur = prev;</div><div class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; <span class="keyword">next</span> = cur.<span class="keyword">next</span>;</div><div class="line">            <span class="keyword">if</span> (cur == e) &#123;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    setChain(hash, <span class="keyword">next</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            prev = cur;</div><div class="line">            cur = <span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11225/index.html" target="_blank" rel="external">具体的链接如下：</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java集合&quot;&gt;&lt;a href=&quot;#Java集合&quot; class=&quot;headerlink&quot; title=&quot;Java集合&quot;&gt;&lt;/a&gt;Java集合&lt;/h2&gt;&lt;h3 id=&quot;Java中集合的接口的继承关系图&quot;&gt;&lt;a href=&quot;#Java中集合的接口的继承关系图&quot; cla
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java基础" scheme="https://caixueyuan.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程间通讯</title>
    <link href="https://caixueyuan.github.io/2017/07/19/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>https://caixueyuan.github.io/2017/07/19/进程间通讯/</id>
    <published>2017-07-19T15:46:57.000Z</published>
    <updated>2017-07-19T15:48:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><h3 id="1-管道-匿名管道（pipe）"><a href="#1-管道-匿名管道（pipe）" class="headerlink" title="1,管道/匿名管道（pipe）"></a>1,管道/匿名管道（pipe）</h3><blockquote>
<ul>
<li>管道都是半双工，数据只能向一个方向流动</li>
<li>只能用于父子进程或者兄弟进程之间</li>
<li>单独构成一种独立的文件系统（就是有输入输出)</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程间通讯&quot;&gt;&lt;a href=&quot;#进程间通讯&quot; class=&quot;headerlink&quot; title=&quot;进程间通讯&quot;&gt;&lt;/a&gt;进程间通讯&lt;/h2&gt;&lt;h3 id=&quot;1-管道-匿名管道（pipe）&quot;&gt;&lt;a href=&quot;#1-管道-匿名管道（pipe）&quot; class=&quot;he
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/JavaScript学习笔记/</id>
    <published>2017-07-04T15:10:15.000Z</published>
    <updated>2017-07-04T15:10:15.692Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring学习笔记</title>
    <link href="https://caixueyuan.github.io/2017/07/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://caixueyuan.github.io/2017/07/04/Spring学习笔记/</id>
    <published>2017-07-04T12:16:49.000Z</published>
    <updated>2017-07-04T12:27:28.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="1，Spring-Security功能性要求："><a href="#1，Spring-Security功能性要求：" class="headerlink" title="1，Spring Security功能性要求："></a>1，Spring Security功能性要求：</h3><blockquote>
<ul>
<li>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问</li>
<li>还能够使用Spring AOP保护方法调用————借助于对象代理和使用通知，能够保护只有具备适当权限的用户才能访问安全保护的方法。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Security&quot;&gt;&lt;a href=&quot;#Spring-Security&quot; class=&quot;headerlink&quot; title=&quot;Spring Security&quot;&gt;&lt;/a&gt;Spring Security&lt;/h2&gt;&lt;h3 id=&quot;1，Spring-Secu
    
    </summary>
    
      <category term="学习笔记" scheme="https://caixueyuan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java框架，笔记" scheme="https://caixueyuan.github.io/tags/Java%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP/</id>
    <published>2017-07-03T13:11:49.000Z</published>
    <updated>2017-07-03T13:32:05.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="1，对于告知服务器意图的HTTP方法："><a href="#1，对于告知服务器意图的HTTP方法：" class="headerlink" title="1，对于告知服务器意图的HTTP方法："></a>1，对于告知服务器意图的HTTP方法：</h3><blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<h3 id="2，持久连接节省通信量"><a href="#2，持久连接节省通信量" class="headerlink" title="2，持久连接节省通信量"></a>2，持久连接节省通信量</h3><blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<h3 id="3，使用Cookie的状态管理"><a href="#3，使用Cookie的状态管理" class="headerlink" title="3，使用Cookie的状态管理"></a>3，使用Cookie的状态管理</h3><p>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<h2 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h2></blockquote>
<h3 id="3，编码提升传输速率"><a href="#3，编码提升传输速率" class="headerlink" title="3，编码提升传输速率"></a>3，编码提升传输速率</h3><blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<h3 id="4，发送多种数据的多部分对象集合"><a href="#4，发送多种数据的多部分对象集合" class="headerlink" title="4，发送多种数据的多部分对象集合"></a>4，发送多种数据的多部分对象集合</h3><blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<h3 id="5，获取部分内容的范围请求（Range-Request）"><a href="#5，获取部分内容的范围请求（Range-Request）" class="headerlink" title="5，获取部分内容的范围请求（Range Request）"></a>5，获取部分内容的范围请求（Range Request）</h3><h3 id="6，内容协调Content-Negotiation返回最合适的内容"><a href="#6，内容协调Content-Negotiation返回最合适的内容" class="headerlink" title="6，内容协调Content Negotiation返回最合适的内容"></a>6，内容协调<code>Content Negotiation</code>返回最合适的内容</h3><blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<h2 id="返回结果的HTTP状态"><a href="#返回结果的HTTP状态" class="headerlink" title="返回结果的HTTP状态"></a>返回结果的HTTP状态</h2><h3 id="1，1XX接收的请求正在处理"><a href="#1，1XX接收的请求正在处理" class="headerlink" title="1，1XX接收的请求正在处理"></a>1，1XX接收的请求正在处理</h3><h3 id="2，2XX成功"><a href="#2，2XX成功" class="headerlink" title="2，2XX成功"></a>2，2XX成功</h3><blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<h3 id="3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"><a href="#3-3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求" class="headerlink" title="3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求"></a>3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</h3><blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<h3 id="4-4XX客户端是发生错误的原因"><a href="#4-4XX客户端是发生错误的原因" class="headerlink" title="4,4XX客户端是发生错误的原因"></a>4,4XX客户端是发生错误的原因</h3><blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<h3 id="5，5XX：服务器本身错误"><a href="#5，5XX：服务器本身错误" class="headerlink" title="5，5XX：服务器本身错误"></a>5，5XX：服务器本身错误</h3><blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<h2 id="与HTTP协作的Web服务器"><a href="#与HTTP协作的Web服务器" class="headerlink" title="与HTTP协作的Web服务器"></a>与HTTP协作的Web服务器</h2><h3 id="1-用单台虚拟主机实现多个域名"><a href="#1-用单台虚拟主机实现多个域名" class="headerlink" title="1,用单台虚拟主机实现多个域名"></a>1,用单台虚拟主机实现多个域名</h3><blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<h3 id="2-通信数据转发程序"><a href="#2-通信数据转发程序" class="headerlink" title="2,通信数据转发程序"></a>2,通信数据转发程序</h3><blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<h3 id="3，保存资源缓存"><a href="#3，保存资源缓存" class="headerlink" title="3，保存资源缓存"></a>3，保存资源缓存</h3><blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="1，HTTP首部字段传递重要信息"><a href="#1，HTTP首部字段传递重要信息" class="headerlink" title="1，HTTP首部字段传递重要信息"></a>1，HTTP首部字段传递重要信息</h3><blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<h2 id="2，HTTP首部字段类型："><a href="#2，HTTP首部字段类型：" class="headerlink" title="2，HTTP首部字段类型："></a>2，HTTP首部字段类型：</h2><blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<h3 id="3，HTTP-1-1通用首部字段"><a href="#3，HTTP-1-1通用首部字段" class="headerlink" title="3，HTTP/1.1通用首部字段"></a>3，HTTP/1.1通用首部字段</h3><blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<h3 id="4，Cookie："><a href="#4，Cookie：" class="headerlink" title="4，Cookie："></a>4，Cookie：</h3><blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<h2 id="确保Web安全的HTTPS"><a href="#确保Web安全的HTTPS" class="headerlink" title="确保Web安全的HTTPS"></a>确保Web安全的HTTPS</h2><h3 id="1，HTTP的缺点"><a href="#1，HTTP的缺点" class="headerlink" title="1，HTTP的缺点"></a>1，HTTP的缺点</h3><blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<h3 id="2，HTTPS（加密，认证，完整性保护）"><a href="#2，HTTPS（加密，认证，完整性保护）" class="headerlink" title="2，HTTPS（加密，认证，完整性保护）"></a>2，HTTPS（加密，认证，完整性保护）</h3><blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<h2 id="确保访问用户身份的认证"><a href="#确保访问用户身份的认证" class="headerlink" title="确保访问用户身份的认证"></a>确保访问用户身份的认证</h2><h3 id="1，BASIC认证"><a href="#1，BASIC认证" class="headerlink" title="1，BASIC认证"></a>1，BASIC认证</h3><blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<h3 id="2-DIGEST认证"><a href="#2-DIGEST认证" class="headerlink" title="2,DIGEST认证"></a>2,DIGEST认证</h3><blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<h3 id="3，SSL客户端认证"><a href="#3，SSL客户端认证" class="headerlink" title="3，SSL客户端认证"></a>3，SSL客户端认证</h3><blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<h3 id="4-基于表单认证"><a href="#4-基于表单认证" class="headerlink" title="4,基于表单认证"></a>4,基于表单认证</h3><blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<h2 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈："><a href="#HTTP的瓶颈：" class="headerlink" title="HTTP的瓶颈："></a>HTTP的瓶颈：</h3><blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<h3 id="WekSocket"><a href="#WekSocket" class="headerlink" title="WekSocket"></a>WekSocket</h3><blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的HTTP协议&quot;&gt;&lt;a href=&quot;#简单的HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;简单的HTTP协议&quot;&gt;&lt;/a&gt;简单的HTTP协议&lt;/h2&gt;&lt;h3 id=&quot;1，对于告知服务器意图的HTTP方法：&quot;&gt;&lt;a href=&quot;#1，对于告知
    
    </summary>
    
    
      <category term="网络协议" scheme="https://caixueyuan.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/hello-world/"/>
    <id>https://caixueyuan.github.io/2017/07/03/hello-world/</id>
    <published>2017-07-03T12:45:33.878Z</published>
    <updated>2017-07-03T12:45:33.879Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://caixueyuan.github.io/2017/07/03/%E5%9B%BE%E8%A7%A3HTTP%20(2)/"/>
    <id>https://caixueyuan.github.io/2017/07/03/图解HTTP (2)/</id>
    <published>2017-07-02T16:00:00.000Z</published>
    <updated>2017-07-03T13:27:48.143Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<p>##简单的HTTP协议</p>
<p>###1，对于告知服务器意图的HTTP方法：</p>
<blockquote>
<ul>
<li>GET:获取资源</li>
<li>POST:传输实体主体</li>
<li>PUT:传输文件</li>
<li>HEAD:只是获得报文的头文件</li>
<li>DELETE:删除文件</li>
<li>TRACE:追踪路径</li>
<li>CONNECT:要求用隧道协议链接代理</li>
</ul>
</blockquote>
<p>###2，持久连接节省通信量</p>
<blockquote>
<p>1,持久链接的好处在于减少了TCP链接的重复建立和断开造成的额外开销，减少了服务器的负载<br>2,管线化：并发发送多个请求</p>
<p>###3，使用Cookie的状态管理<br>在没有Cookie之前，服务器端生成Cookie，在客户端中写入Cookie信息来控制客户端的状态，客户端会根据从服务器发送的的相应报文中的<code>Set-Cookie</code>的首部字段信息，通知客户端来保存Cookie，在下次客户端再往该服务器发送请求时，<strong>自动</strong>在请求报文中加入Cookie值后发送出去。</p>
<p>##HTTP报文内的HTTP信息</p>
</blockquote>
<p>###3，编码提升传输速率</p>
<blockquote>
<ul>
<li>压缩传输：报文主体等于实体主体，只有在传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体发生差异</li>
<li>分块传输编码：在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</li>
</ul>
</blockquote>
<p>###4，发送多种数据的多部分对象集合</p>
<blockquote>
<p><code>multipart/form-data</code>在web表单文件上传时使用<br><code>multipart/byteranges</code>响应<strong>报文</strong>包含了多个范围的内容时使用</p>
</blockquote>
<p>###5，获取部分内容的范围请求（Range Request）</p>
<p>###6，内容协调<code>Content Negotiation</code>返回最合适的内容</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Acept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language<br>类型</li>
<li>Server-driven Negotiation</li>
<li>Agent-driven Negotiation</li>
<li>Transparent Negotiation</li>
</ul>
</blockquote>
<p>##返回结果的HTTP状态</p>
<p>###1，1XX接收的请求正在处理</p>
<p>###2，2XX成功</p>
<blockquote>
<ul>
<li>200 OK 成功处理</li>
<li>204 No Content:在返回的响应报文中不含实体的主题部分</li>
<li>206 Partial Content：范围请求，GET</li>
</ul>
</blockquote>
<p>###3,3XX重定向：浏览器需要执行某些特殊的处理一正确处理请求</p>
<blockquote>
<ul>
<li>301:Moved Permanently</li>
<li>302:Found 书签，URI临时性质改变</li>
<li>303:See Other:由于请求过程的资源存在了另一个URI，应使用GET方向定向获取请求的资源。</li>
<li>304:Not Modified:(服务器端资源没有改变，可直接使用客户端未过期的缓存）客户端发送附带条件的请求时，但因为请求未满足条件的情况后</li>
<li>307:Temporary Redirect</li>
</ul>
</blockquote>
<p>###4,4XX客户端是发生错误的原因</p>
<blockquote>
<ul>
<li>400:请求报文中存在语法错误</li>
<li>401 Unauthorized:需要通过HTTP认证的认证信息，返回含有401的响应必须包含一个用于被请求资源的WWW-Authenticate首部用以质询用户信息，当浏览器初次接收到401响应吗，会跳出认证用的对话窗口</li>
<li>403 Forbidden:对请求资源的访问被服务器拒绝了</li>
<li>404: Not Found:没有找到请求的资源</li>
</ul>
</blockquote>
<p>###5，5XX：服务器本身错误</p>
<blockquote>
<ul>
<li>500： Internal Server Error服务器在执行请求的时候出现错误</li>
<li>503： Service Unavailable:服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</blockquote>
<hr>
<p>##与HTTP协作的Web服务器</p>
<p>###1,用单台虚拟主机实现多个域名</p>
<blockquote>
<ul>
<li>在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</li>
</ul>
</blockquote>
<p>###2,通信数据转发程序</p>
<blockquote>
<ul>
<li>代理：代理不改变URL，会直接发送给前方持有资源的目标服务器，需要附加上Via首部字段以标记出经过的主机信息<br>可以分为两种（是否使用缓存，是否修改报文（透明和非透明）</li>
<li>网关：网关能使通信线路上的服务器提供非HTTP协议服务，提高通信的安全性</li>
<li>隧道：SSL通信，隧道本身不会去解析HTTP请求</li>
</ul>
</blockquote>
<p>###3，保存资源缓存</p>
<blockquote>
<ul>
<li>缓存的有效性</li>
<li>客户端缓存</li>
</ul>
</blockquote>
<p>##HTTP首部</p>
<p>###1，HTTP首部字段传递重要信息</p>
<blockquote>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
</blockquote>
<p>##2，HTTP首部字段类型：</p>
<blockquote>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</blockquote>
<p>1，端到端首部（End-to-end Header）：转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中<br>2，逐跳首部(Hop-by-hop Header):会因为通过缓存或代理而不再转发。</p>
<p>###3，HTTP/1.1通用首部字段</p>
<blockquote>
<p><strong>Cache-Controller</strong>：</p>
</blockquote>
<p><code>Cache-Control:public</code>:其他用户也可以利用缓存<br><code>Cache-Control:private</code>:响应只以特定的用户作为对象<br><code>Cache-Control:no-cache=Location</code>:防止从缓存中返回过期的资源<br><code>Cache-Control:no-store</code>:缓存中不能在本地存储请求或响应的任一部分。<br><code>Cache-Control:s-maxage=604800</code>(单位为秒）：只适用于供多位用户使用的公共缓存服务器<br><code>Cache-Control:max-age=604800</code>:当接收到客户端的请求时，缓存服务器直接向客户端返回<br><code>Cache-Control:min-fresh=60</code>：指令缓存服务器返回至少还没过指定时间的缓存资源<br><code>Cache-Control:max-stale=3600</code>:指示缓存资源，即使过期也照常接收</p>
<p>###4，Cookie：</p>
<blockquote>
<p>Set-Cookie:开始状态管理所使用的Cookie信息，响应首部字段<br>Cookie :服务器收到的Cookie信息（请求首部字段）</p>
</blockquote>
<p>##确保Web安全的HTTPS</p>
<p>###1，HTTP的缺点</p>
<blockquote>
<ul>
<li>1，通信使用明文，内容可能被窃听<br>TCP/IP是可能被窃听的网络<br>方法：通信加密(<strong>SSL</strong>(<code>Secure Socket Layer</code>安全套接层） TLS（Transport Layer Security）安全传输协议）的组合使用，内容的加密</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>方法：查明证书</li>
<li>无法证明报文的完整性，所以有可能被篡改<br>攻击：中间人攻击<br>方法：MD5和SHA-1等散列值校验，用来确认文件的数字签名方法</li>
</ul>
</blockquote>
<p>###2，HTTPS（加密，认证，完整性保护）</p>
<blockquote>
<ul>
<li>HTTPS是身披SSL外壳的HTTP</li>
<li>相互交换密钥的公开密钥加密技术（公开密钥加密，共享密钥加密）<br>HTTPS采用混合加密机制，首先，使用公开密钥进行加密来传送共享密钥，然后再通过共享密钥进行加密</li>
<li>证明公开密钥正确性的证书（证明公开密钥本身是正确的，由数字证书认证机构，如EV SSL证书</li>
<li>MAC(Message Authentication Code)：能够查知报文是否被篡改，保证报文的完整性。</li>
</ul>
</blockquote>
<p>##确保访问用户身份的认证</p>
<p>###1，BASIC认证</p>
<blockquote>
<p>使用Base64编码方式，基本上算是明文</p>
</blockquote>
<p>###2,DIGEST认证</p>
<blockquote>
<p>发送临时的质询码（随机数）给客户端，客户端发送摘要，以及由质询码计算出来的响应码，然后服务器进行验证</p>
</blockquote>
<p>###3，SSL客户端认证</p>
<blockquote>
<p>双因素：认证客户端计算机，通过密码来证明本人在使用<br>需要客户端证书</p>
</blockquote>
<p>###4,基于表单认证</p>
<blockquote>
<p>通过Session管理及Cookie应用</p>
</blockquote>
<p>##基于HTTP的功能追加协议</p>
<p>###HTTP的瓶颈：</p>
<blockquote>
<ul>
<li>1,一个连接只可发送一个请求</li>
<li>2,请求只能从客户端开始</li>
<li>3,请求/响应首部未经压缩就发送</li>
<li>4,发送冗长的首部</li>
<li>5,可任意选择数据压缩格式</li>
</ul>
</blockquote>
<p>###WekSocket</p>
<blockquote>
<p>在建立HTTP连接之后切换Upgrade到WebSocket中，具有推送功能和减少通信量（首部更少）</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
